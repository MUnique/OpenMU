@using System.Text
@using System.Globalization
@using MUnique.OpenMU.AdminPanel.Interop
@using MUnique.OpenMU.AdminPanel.Services
@using MUnique.OpenMU.DataModel.Configuration
@using MUnique.OpenMU.GameLogic
@using MUnique.OpenMU.Persistence
@using SixLabors.ImageSharp
@using SixLabors.ImageSharp.Formats.Png
@using SixLabors.ImageSharp.PixelFormats
@using System.ComponentModel

@implements IDisposable
@inject NavigationManager NavigationManager
@inject GameConfiguration GameConfiguration

<h3>@this.Map.Name</h3>

<div class="map-select">
    <label for="mapSelect">Selected Map:</label>
    <select title="Map" @onchange=this.OnMapSelected id="mapSelect" autocomplete="off">
        @foreach (var map in this.GameConfiguration.Maps.OrderBy(c => c.Number))
        {
            <option value="@map.GetId()" selected=@(object.Equals(this.Map, map))>Map: @map.ToString()</option>
        }
    </select>
</div>

<div class="btn-toolbar my-2" role="toolbar" aria-label="Toolbar">
    <div class="btn-group mr-2" role="group" aria-label="Creation Group">
        <button type="button" class="btn btn-secondary" @onclick="@this.CreateNewSpawnArea" disabled="@this.createMode">
            <span class="oi oi-plus"></span> Spawn Area
        </button>
        <button type="button" class="btn btn-secondary" @onclick="@this.CreateNewEnterGate" disabled="@this.createMode">
            <span class="oi oi-plus"></span> Enter Gate
        </button>
        <button type="button" class="btn btn-secondary" @onclick="@this.CreateNewExitGate" disabled="@this.createMode">
            <span class="oi oi-plus"></span> Exit Gate
        </button>
    </div>
    <div class="btn-group" role="group" aria-label="Control Group">
        @if (this.createMode)
        {
            <button id="applyCreate" type="button" class="btn btn-primary" @onclick="@(_ => this.createMode = false)"><span class="oi oi-circle-check"></span></button>
            <button id="cancelCreate" type="button" class="btn btn-secondary" @onclick="@this.CancelCreation"><span class="oi oi-circle-x"></span></button>
        }
        else if (this.focusedObject is not null)
        {
            <button id="removeFocused" type="button" class="btn btn-secondary" @onclick="@this.RemoveFocusedObject"><span class="oi oi-x"></span> Remove</button>
        }
    </div>
</div>

<div class="map-host" width="@(scale * 255)" height="@(scale * 255)" @onmousemove="@this.OnMouseMove" @onmouseup="() => resizerPosition = null">
    <img src="@(this.terrainImage.ToBase64String(PngFormat.Instance))"
         width="@(scale * 255)"
         height="@(scale * 255)" />
    @foreach (var enterGate in this.Map.EnterGates)
    {
        <div class="gate-enter"
             title="@enterGate.ToString()"
             style="@this.GetSizeAndPositionStyle(enterGate)"
             @onclick="@(_ => { if (!this.createMode) { this.focusedObject = enterGate; } })">
            @if (this.focusedObject == enterGate)
            {
                <Resizers Resizing="@this.OnStartResizing" />
            }
        </div>
    }

    @foreach (var exitGate in this.Map.ExitGates)
    {
        <div class="gate-exit"
             title="@exitGate.ToString()"
             style="@this.GetSizeAndPositionStyle(exitGate)"
             @onclick="@(_ => { if (!this.createMode) { this.focusedObject = exitGate; } })">
            @if (this.focusedObject == exitGate)
            {
                <Resizers Resizing="@this.OnStartResizing" />
            }
        </div>
    }

    @foreach (var spawn in this.Map.MonsterSpawns)
    {
        <div class="@this.GetSpawnClass(spawn)"
             title="@spawn.ToString()"
             style="@this.GetSizeAndPositionStyle(spawn)"
             @onclick="@(_ => { if (!this.createMode) { this.focusedObject = spawn; } })">
            @if (this.focusedObject == spawn)
            {
                if (spawn.X1 != spawn.X2 || spawn.Y1 != spawn.Y2)
                {
                    <Resizers Resizing="@this.OnStartResizing" />
                }
                else if (spawn.Direction != Direction.Undefined)
                {
                    <div class="arrow @this.GetFocusedRotation()"></div>
                }
                else
                {
                    // show nothing
                }
            }
        </div>
    }
</div>

@if (!this.createMode)
{
    <div class="map-object-select">
        <label for="objectSelect">Selected Object:</label>
        <select title="Object" @onchange=this.OnObjectSelected id="objectSelect" autocomplete="off" disabled="@this.createMode">
            <option value="@Guid.Empty" selected=@(this.focusedObject is null)></option>
            @foreach (var enterGate in this.Map.EnterGates)
            {
                <option value="@enterGate.GetId()" selected=@(object.Equals(this.focusedObject, enterGate))>EnterGate: @enterGate.ToString()</option>
            }
            @foreach (var exitGate in this.Map.ExitGates)
            {
                <option value="@exitGate.GetId()" selected=@(object.Equals(this.focusedObject, exitGate))>ExitGate: @exitGate.ToString()</option>
            }
            @foreach (var spawn in this.Map.MonsterSpawns)
            {
                <option value="@spawn.GetId()" selected=@(object.Equals(this.focusedObject, spawn))>Spawn: @spawn.ToString()</option>
            }
        </select>
    </div>
}

@if (this.focusedObject != null)
{
    <div class="map-object-form">
        @if (focusedObject is EnterGate enterGate)
        {
            <AutoForm Model="@enterGate" OnValidSubmit="@this.OnValidSubmit"></AutoForm>
        }
        else if (focusedObject is ExitGate exitGate)
        {
            <AutoForm Model="@exitGate" OnValidSubmit="@this.OnValidSubmit"></AutoForm>
        }
        else if (focusedObject is MonsterSpawnArea spawn)
        {
            <AutoForm Model="@spawn" OnValidSubmit="@this.OnValidSubmit"></AutoForm>
        }
    </div>
}

@code {

    private Image<Rgba32> terrainImage = null!;

    private float scale = 3;

    private object? focusedObject;
    private Resizers.ResizerPosition? resizerPosition;
    private bool createMode;

    /// <summary>
    /// Gets or sets the map which is edited in this component.
    /// </summary>
    [Parameter]
    public GameMapDefinition Map { get; set; } = null!;

    /// <summary>
    /// Gets or sets the <see cref="EditForm.OnValidSubmit"/> event callback.
    /// </summary>
    [Parameter]
    public EventCallback OnValidSubmit { get; set; }

    /// <summary>
    /// Gets or sets the persistence context.
    /// </summary>
    [CascadingParameter]
    public IContext PersistenceContext { get; set; } = null!;

    /// <summary>
    /// Gets or sets the javascript runtime.
    /// </summary>
    /// <remarks>
    /// It's used for the resizing stuff. There is room for improvement, though.
    /// Currently, every mouse move in the resize process causes additional network roundtrips.
    /// This means, the resizing might be laggy and a bit buggy. It may make sense to do more stuff in javascript instead.
    /// </remarks>
    [Inject]
    public IJSRuntime JsRuntime { get; set; } = null!;

    /// <summary>
    /// Gets or sets the change notification service.
    /// </summary>
    [Inject]
    public IChangeNotificationService NotificationService { get; set; } = null!;

    /// <inheritdoc />
    public void Dispose()
    {
        this.NotificationService.PropertyChanged -= this.OnPropertyChanged;
    }

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        this.NotificationService.PropertyChanged += this.OnPropertyChanged;
    }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        this.terrainImage = new GameMapTerrain(this.Map).ToImage();
    }

    private void OnPropertyChanged(object? sender, PropertyChangedEventArgs args)
    {
        if (sender == this.focusedObject)
        {
            this.StateHasChanged();
        }
    }

    private Task? OnCancel()
    {
        this.focusedObject = null;
        return null;
    }

    private string GetSpawnClass(MonsterSpawnArea spawn)
    {
        var result = "spawn-single";
        if (spawn.X1 != spawn.X2 || spawn.Y1 != spawn.Y2)
        {
            result = "spawn-area";
        }

        if (this.focusedObject == spawn)
        {
            result += "-focused";
        }

        return result;
    }

    private string GetSizeAndPositionStyle(Gate gate)
    {
        return string.Format("width: {0}px; height: {1}px; top: {2}px; left:{3}px;",
            (scale * (1 + gate.Y2 - gate.Y1)).ToString(CultureInfo.InvariantCulture),
            (scale * (1 + gate.X2 - gate.X1)).ToString(CultureInfo.InvariantCulture),
            (scale * gate.X1).ToString(CultureInfo.InvariantCulture),
            (scale * gate.Y1).ToString(CultureInfo.InvariantCulture));
    }

    private string GetSizeAndPositionStyle(MonsterSpawnArea spawn)
    {
        var objScale = 1.0f;

        var result = new StringBuilder();

        if (spawn.X1 == spawn.X2 && spawn.Y1 == spawn.Y2)
        {
            // We want the small point to be more visible, so it's bigger and has a higher opacity.
            objScale = 1.75f;
        }

        // X and Y are twisted, it's not an error!
        var width = objScale * this.scale * (1 + spawn.Y2 - spawn.Y1);
        var height = objScale * this.scale * (1 + spawn.X2 - spawn.X1);
        var xyOffset = (objScale - 1.0f) * this.scale;
        var top = this.scale * spawn.X1 - xyOffset;
        var left = this.scale * spawn.Y1 - xyOffset;
        result.Append($"width: {width.ToString(CultureInfo.InvariantCulture)}px;")
            .Append($"height: {height.ToString(CultureInfo.InvariantCulture)}px;")
            .Append($"top: {top.ToString(CultureInfo.InvariantCulture)}px;")
            .Append($"left: {left.ToString(CultureInfo.InvariantCulture)}px;");

        return result.ToString();
    }

    private void OnObjectSelected(ChangeEventArgs args)
    {
        var obj = this.Map.EnterGates.FirstOrDefault<object>(g => g.GetId().ToString() == args.Value?.ToString())
                  ?? this.Map.ExitGates.FirstOrDefault<object>(g => g.GetId().ToString() == args.Value?.ToString())
                  ?? this.Map.MonsterSpawns.FirstOrDefault(g => g.GetId().ToString() == args.Value?.ToString());
        this.focusedObject = obj;
    }

    private async Task<(byte X, byte Y)?> OnGetObjectCoordinates(MouseEventArgs args)
    {
        if (args.Buttons == 1)
        {
            // For GetMapHostBoundingClientRect(), see map.js
            // Warning: it's NOT working with the Edge Browser! BoundingClientRect gets all values with 0.
            var mapClientRect = await this.JsRuntime.InvokeAsync<BoundingClientRect>("GetMapHostBoundingClientRect");
            var x = (args.ClientY - mapClientRect.Top) / scale;
            var y = (args.ClientX - mapClientRect.Left) / scale;
            return ((byte)x, (byte)y);
        }

        return null;
    }

    private void OnStartResizing(Resizers.ResizerPosition? position)
    {
        this.resizerPosition = position;
    }

    private async Task OnMouseMove(MouseEventArgs args)
    {
        if (this.resizerPosition is null)
        {
            return;
        }

        if (await this.OnGetObjectCoordinates(args) is { } coordinates)
        {
            var (x, y) = coordinates;

            switch (this.focusedObject)
            {
                case MonsterSpawnArea spawnArea:
                    this.OnSpawnAreaResizing(spawnArea, x, y);
                    break;
                case Gate gate:
                    this.OnGateResizing(gate, x, y);
                    break;
            }

            this.NotificationService.NotifyChange(this.focusedObject, null);
        }
    }

    private void OnSpawnAreaResizing(MonsterSpawnArea spawnArea, byte x, byte y)
    {
        switch (this.resizerPosition)
        {
            case Resizers.ResizerPosition.TopLeft:
                spawnArea.X1 = x;
                spawnArea.Y1 = y;
                break;
            case Resizers.ResizerPosition.TopRight:
                spawnArea.X1 = x;
                spawnArea.Y2 = y;
                break;
            case Resizers.ResizerPosition.BottomRight:
                spawnArea.X2 = x;
                spawnArea.Y2 = y;
                break;
            case Resizers.ResizerPosition.BottomLeft:
                spawnArea.X2 = x;
                spawnArea.Y1 = y;
                break;
        }
    }

    private void OnGateResizing(Gate gate, byte x, byte y)
    {
        switch (this.resizerPosition)
        {
            case Resizers.ResizerPosition.TopLeft:
                gate.X1 = x;
                gate.Y1 = y;
                break;
            case Resizers.ResizerPosition.TopRight:
                gate.X1 = x;
                gate.Y2 = y;
                break;
            case Resizers.ResizerPosition.BottomRight:
                gate.X2 = x;
                gate.Y2 = y;
                break;
            case Resizers.ResizerPosition.BottomLeft:
                gate.X2 = x;
                gate.Y1 = y;
                break;
        }
    }

    private string? GetFocusedRotation()
    {
        if (this.focusedObject is MonsterSpawnArea spawn)
        {
            return spawn.Direction.ToString().ToLowerInvariant();
        }

        return null;
    }

    private void CreateNewSpawnArea()
    {
        this.createMode = true;

        var area = this.PersistenceContext.CreateNew<MonsterSpawnArea>();
        area.GameMap = this.Map;
        this.Map.MonsterSpawns.Add(area);
        area.X1 = 100;
        area.Y1 = 100;
        area.X2 = 200;
        area.Y2 = 200;
        area.Quantity = 1;

        this.focusedObject = area;
    }

    private void CreateNewEnterGate()
    {
        this.createMode = true;

        var enterGate = this.PersistenceContext.CreateNew<EnterGate>();
        this.Map.EnterGates.Add(enterGate);
        enterGate.X1 = 120;
        enterGate.Y1 = 120;
        enterGate.X2 = 140;
        enterGate.Y2 = 140;

        this.focusedObject = enterGate;
    }

    private void CreateNewExitGate()
    {
        this.createMode = true;

        var exitGate = this.PersistenceContext.CreateNew<ExitGate>();
        this.Map.ExitGates.Add(exitGate);
        exitGate.X1 = 120;
        exitGate.Y1 = 120;
        exitGate.X2 = 140;
        exitGate.Y2 = 140;

        this.focusedObject = exitGate;
    }

    private void CancelCreation()
    {
        if (!this.createMode)
        {
            return;
        }

        this.createMode = false;
        this.RemoveFocusedObject();
    }

    private void RemoveFocusedObject()
    {
        switch (this.focusedObject)
        {
            case MonsterSpawnArea spawnArea:
                this.Map.MonsterSpawns.Remove(spawnArea);
                break;
            case EnterGate enterGate:
                this.Map.EnterGates.Remove(enterGate);
                break;
            case ExitGate exitGate:
                this.Map.ExitGates.Remove(exitGate);
                break;
            default:
                return;
        }

        this.PersistenceContext.Delete(this.focusedObject);
        this.focusedObject = null;
    }

    private void OnMapSelected (ChangeEventArgs args)
    {
        NavigationManager.NavigateTo($"/map-editor/{args.Value}");
    }
}
