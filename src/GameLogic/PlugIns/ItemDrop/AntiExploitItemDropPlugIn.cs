// <copyright file="AntiExploitItemDropPlugIn.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

namespace MUnique.OpenMU.GameLogic.PlugIns.ItemDrop;

using System.Runtime.InteropServices;
using MUnique.OpenMU.GameLogic.PlugIns;
using MUnique.OpenMU.Pathfinding;
using MUnique.OpenMU.PlugIns;

/// <summary>
/// Plugin that provides anti-exploit validation for item drops.
/// </summary>
[Guid("A3B45C67-89DE-4F12-8345-6789ABCDEF01")]
[PlugIn("Anti-Exploit Item Drop Validation", "Prevents item drop exploits and cheating attempts")]
public class AntiExploitItemDropPlugIn : IItemDropPlugIn
{
    private const int SuspiciousDropThreshold = 50; // Items dropped in short time
    private const int SuspiciousTimeWindowMinutes = 5;

    /// <inheritdoc />
    public async ValueTask HandleItemDropAsync(Player player, Item item, Point target, IItemDropPlugIn.ItemDropArguments dropArgs)
    {
        try
        {
            // Check for suspicious patterns
            if (await this.DetectSuspiciousActivityAsync(player, item).ConfigureAwait(false))
            {
                player.Logger.LogWarning(
                    "Suspicious item drop activity detected for player {PlayerId}: {ItemName}",
                    player.Id,
                    item.Definition?.Name ?? "Unknown");

                dropArgs.WasHandled = true;
                dropArgs.Success = false;
                return;
            }

            // Check for item duplication attempts
            if (this.DetectDuplicationAttempt(player, item, target))
            {
                player.Logger.LogWarning(
                    "Potential item duplication attempt detected for player {PlayerId}: {ItemName}",
                    player.Id,
                    item.Definition?.Name ?? "Unknown");

                dropArgs.WasHandled = true;
                dropArgs.Success = false;
                return;
            }

            // Check for teleport/speed hack attempts
            if (await this.DetectMovementExploitAsync(player, target).ConfigureAwait(false))
            {
                player.Logger.LogWarning(
                    "Movement exploit detected during item drop for player {PlayerId}",
                    player.Id);

                dropArgs.WasHandled = true;
                dropArgs.Success = false;
                return;
            }

            // Log legitimate drops of valuable items for monitoring
            if (this.IsValuableItem(item))
            {
                player.Logger.LogInformation(
                    "Valuable item dropped by player {PlayerId}: {ItemName} at {Position}",
                    player.Id,
                    item.Definition?.Name ?? "Unknown",
                    target);
            }
        }
        catch (Exception ex)
        {
            player.Logger.LogError(ex, "Error in anti-exploit item drop validation");
            // In case of errors, allow the drop to proceed to avoid blocking legitimate gameplay
        }
    }

    /// <summary>
    /// Detects suspicious drop activity patterns.
    /// </summary>
    /// <param name="player">The player being checked.</param>
    /// <param name="item">The item being dropped.</param>
    /// <returns>True if suspicious activity is detected.</returns>
    private async ValueTask<bool> DetectSuspiciousActivityAsync(Player player, Item item)
    {
        // Check if player is dropping too many items in a short time
        // This could indicate automated behavior or exploit attempts
        
        // Note: In a real implementation, you would store drop history in a cache or database
        // For this example, we'll use a simplified check based on player state
        
        if (player.Inventory?.Items.Count() > 100)
        {
            // Player has suspiciously many items
            return true;
        }

        // Check for identical items being dropped rapidly
        var identicalItemsInInventory = player.Inventory?.Items
            .Where(i => i.Definition?.Number == item.Definition?.Number && i.Level == item.Level)
            .Count() ?? 0;

        if (identicalItemsInInventory > 20)
        {
            // Too many identical items - possible duplication
            return true;
        }

        return false;
    }

    /// <summary>
    /// Detects potential item duplication attempts.
    /// </summary>
    /// <param name="player">The player being checked.</param>
    /// <param name="item">The item being dropped.</param>
    /// <param name="target">The drop target position.</param>
    /// <returns>True if a duplication attempt is detected.</returns>
    private bool DetectDuplicationAttempt(Player player, Item item, Point target)
    {
        // Check if an identical item already exists at the target location
        var droppedItems = player.CurrentMap?.GetAllObjectsInBounds(target, target, player.InfoRange)
            .OfType<DroppedItem>()
            .Where(di => di.Position.X == target.X && di.Position.Y == target.Y)
            .ToList();

        if (droppedItems?.Any(di => 
            di.Item.Definition?.Number == item.Definition?.Number &&
            di.Item.Level == item.Level &&
            di.Item.Durability == item.Durability) == true)
        {
            return true;
        }

        // Check for rapid successive drops of the same item type
        var recentDrops = player.CurrentMap?.GetAllObjectsInBounds(
            new Point((byte)Math.Max(0, target.X - 5), (byte)Math.Max(0, target.Y - 5)),
            new Point((byte)Math.Min(255, target.X + 5), (byte)Math.Min(255, target.Y + 5)),
            10)
            .OfType<DroppedItem>()
            .Where(di => di.Item.Definition?.Number == item.Definition?.Number)
            .Count();

        return recentDrops >= 5; // Too many similar items in nearby area
    }

    /// <summary>
    /// Detects movement exploits during item dropping.
    /// </summary>
    /// <param name="player">The player being checked.</param>
    /// <param name="target">The drop target position.</param>
    /// <returns>True if a movement exploit is detected.</returns>
    private async ValueTask<bool> DetectMovementExploitAsync(Player player, Point target)
    {
        // Check if player is trying to drop items while moving too fast
        if (player.IsWalking)
        {
            var currentPosition = player.Position;
            var walkTarget = player.WalkTarget;
            var distanceToWalkTarget = currentPosition.EuclideanDistanceTo(walkTarget);
            var distanceToDropTarget = currentPosition.EuclideanDistanceTo(target);

            // If player is walking far away but trying to drop items nearby, this might be suspicious
            if (distanceToWalkTarget > 10 && distanceToDropTarget < 2)
            {
                return true;
            }
        }

        // Check for impossible drop distances (teleport hacks)
        var playerPosition = player.IsWalking ? player.WalkTarget : player.Position;
        var dropDistance = playerPosition.EuclideanDistanceTo(target);
        
        // If drop distance is suspiciously far, it might be a teleport hack
        if (dropDistance > 8) // Normal max drop distance should be around 5
        {
            return true;
        }

        return false;
    }

    /// <summary>
    /// Determines if an item is considered valuable and should be logged.
    /// </summary>
    /// <param name="item">The item to check.</param>
    /// <returns>True if the item is valuable.</returns>
    private bool IsValuableItem(Item item)
    {
        if (item.Definition == null)
        {
            return false;
        }

        // Consider items valuable if they are:
        // - High level items (level 10+)
        // - Jewels (group 14)
        // - Wings (group 12)
        // - Excellent items
        // - Ancient items
        
        if (item.Level >= 10)
        {
            return true;
        }

        if (item.Definition.Group == 12 || item.Definition.Group == 14)
        {
            return true;
        }

        if (item.HasExcellentOptions || item.HasAncientBonus)
        {
            return true;
        }

        return false;
    }
}