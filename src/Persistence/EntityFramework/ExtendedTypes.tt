<#
// <copyright file="ExtendedTypes.tt" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>
#>
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ include file="..\BasicModel\Common.ttinclude" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <copyright file="ExtendedTypes.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by a T4 template.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All

namespace MUnique.OpenMU.Persistence.EntityFramework
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations.Schema;
    using Mapster;
    using MUnique.OpenMU.Persistence;

<#
List<Type> customTypes = null;
try {
    customTypes = this.GetCustomTypes();
}
catch(System.Reflection.ReflectionTypeLoadException ex)
{
    #>/* ReflectionTypeLoadException Loader Exceptions:
    <#
    foreach (var inner in ex.LoaderExceptions)
    {
        #>
        <#=inner.Message#>
        <#
    }
    #>*/
    }<#
    throw;
}
    
string customTypeSuffix = string.Empty;

foreach (Type type in customTypes)
{
    string className = type.Name + customTypeSuffix;
    string interfaceName = type.Name;
#>
    /// <summary>
    /// The Entity Framework Core implementation of <see cref="<#=type.FullName#>"/>.
    /// </summary>
    [Table("<#=type.Name#>", Schema = "<#=IsConfigurationType(type) ? "config" : "data" #>")]
    internal partial class <#=className #> : <#=type.FullName#>, IIdentifiable
    {<#
        var standaloneCollectionProperties = type.FullName != "MUnique.OpenMU.DataModel.Configuration.GameConfiguration" ? 
            type.GetProperties().Where(p => p.PropertyType.IsGenericType && p.PropertyType.GetGenericTypeDefinition() == typeof(ICollection<>) && standaloneTypes.Contains(p.PropertyType.GenericTypeArguments[0].FullName)).ToList() :
            Enumerable.Empty<PropertyInfo>();

        if (standaloneCollectionProperties.Any() || type.GetConstructors().Any(c => c.IsPublic && c.GetParameters().Length > 0) && type.GetConstructors().Any(c => c.IsPublic && c.GetParameters().Length == 0))
        {#>

        public <#=className #>()
        {
            this.InitJoinCollections();
        } <# 
        }
        foreach (var constructor in type.GetConstructors().Where(c => c.IsPublic && c.GetParameters().Length > 0))
        {
            var parameters = constructor.GetParameters();
        #>


        public <#=className #>(<# 
        foreach (var p in parameters) 
        { 
            string parameterTypeName;
            var parameterType = p.ParameterType;
            if (!parameterType.IsGenericType)
            {
                parameterTypeName = parameterType.FullName;
            }
            else
            {
                parameterTypeName = parameterType.Name.Split('`')[0] + "<" + string.Join(", ", parameterType.GetGenericArguments().Select(x => x.FullName).ToArray()) + ">";
            }
        #><#=parameterTypeName#> <#=p.Name#><#
            if (parameters.Length > p.Position + 1 ) { #>, <# }
        } //end for each parameter
        #>)
          : base (<# 
        foreach (var p in parameters) 
        { 
        #><#=p.Name#><#
            if (parameters.Length > p.Position + 1 ) { #>, <# }
        } //end for each parameter
        #>)
        {
            this.InitJoinCollections();
        }<#
        } // end foreach constructor
        #>
        

        protected void InitJoinCollections()
        {
        <#
        foreach (PropertyInfo propertyInfo in standaloneCollectionProperties)
        {
            var elementType = propertyInfo.PropertyType.GenericTypeArguments[0];
            var joinTypeName = propertyInfo.DeclaringType.Name + elementType.Name;
#>  
            this.<#=propertyInfo.Name#> = new ManyToManyCollectionAdapter<<#=elementType.FullName#>, <#=joinTypeName#>>(this.Joined<#=propertyInfo.Name#>, joinEntity => joinEntity.<#=elementType.Name#>, entity => new <#=joinTypeName#> { <#=type.Name #> = this, <#=type.Name #>Id = this.Id, <#=elementType.Name#> = (<#=elementType.Name + customTypeSuffix#>)entity, <#=elementType.Name#>Id = ((<#=elementType.Name + customTypeSuffix#>)entity).Id});
        <#
        } // end foreach standalone property
        #>}
<#
        if (type.GetProperty("Id") == null)
        {
#>

        /// <summary>
        /// Gets or sets the identifier of this instance.
        /// </summary>
        public Guid Id { get; set; }

<#
        }
        
        foreach (var property in type
                                    .GetProperties()
                                    .Where(p => p.GetGetMethod().IsVirtual && !p.GetGetMethod().IsFinal && !p.PropertyType.IsValueType && !p.PropertyType.IsArray)
                                    .Where(p => !(p.PropertyType.IsGenericType 
                                        && p.PropertyType.GetGenericTypeDefinition() == typeof(ICollection<>) 
                                        && standaloneTypes.Contains(p.PropertyType.GenericTypeArguments[0].FullName)) || type.FullName == "MUnique.OpenMU.DataModel.Configuration.GameConfiguration")
            )
        {
                      string propertyTypeName;
                      string originalPropertyTypeName;
            var propertyType = property.PropertyType;
            string genericParameterType = string.Empty;
            if (!propertyType.IsGenericType)
            {
                originalPropertyTypeName = propertyType.FullName;
                propertyTypeName = propertyType.Name + customTypeSuffix;
            }
            else
            {
                originalPropertyTypeName =propertyType.Name.Split('`')[0] + "<" + string.Join(", ", propertyType.GetGenericArguments().Select(x => x.FullName).ToArray()) + ">";
                var genericType = propertyType.GetGenericTypeDefinition();
                if (genericType == typeof(IDictionary<,>))
                {
                    genericParameterType = type.Name + propertyType.GetGenericArguments()[1].Name;
                    propertyTypeName = "ICollection<" + genericParameterType + ">";
                }
                else
                {          
                    genericParameterType = string.Join(", ", propertyType.GetGenericArguments().Select(x => x.Name + customTypeSuffix).ToArray());
                    propertyTypeName = propertyType.Name.Split('`')[0] + "<" + genericParameterType + ">";
                }
            }

            if (!propertyType.IsInterface)
            {
#>
        /// <summary>
        /// Gets or sets the identifier of <see cref="<#=property.Name#>"/>.
        /// </summary>
        public Guid? <#=property.Name#>Id { get; set; }
        
        [ForeignKey("<#=property.Name#>Id")]
        public <#=propertyTypeName#> Raw<#=property.Name#>
        { 
            get { return base.<#=property.Name#> as <#=propertyTypeName#>; }
            <#if (property.GetSetMethod(true) != null) {#>set { base.<#=property.Name#> = value; } 
<#}#>
        }
        <#} else if (property.PropertyType.GenericTypeArguments.Length == 1 && property.PropertyType.GenericTypeArguments[0].IsPrimitive) {#>[Column("<#=property.Name#>")]
        [Newtonsoft.Json.JsonProperty("<#=property.Name#>")]
        [System.Text.Json.Serialization.JsonPropertyName("<#=ToCamelCase(property.Name)#>")]
        public string Raw<#=property.Name#> { get; set; }
        <#} else {#>public <#=propertyTypeName#> Raw<#=property.Name#> { get; } = new List<<#=genericParameterType#>>();<#}#>
        
        /// <inheritdoc/>
<#if (property.PropertyType.GenericTypeArguments.Length == 1 && property.PropertyType.GenericTypeArguments[0].IsPrimitive) {#>        [Newtonsoft.Json.JsonIgnore]
        [System.Text.Json.Serialization.JsonIgnore]
<#}#>
        [NotMapped]
        public override <#=originalPropertyTypeName#> <#=property.Name#>
        {
            get
            {
<# if (!propertyType.IsInterface) {#>
                return base.<#=property.Name#>;
<#} else if (propertyType.IsGenericType) {
  
  string adapterClass = null;
  if (propertyType.GetGenericTypeDefinition() == typeof(IList<>))
  {
      adapterClass = "ListAdapter";
  } 
  else if (propertyType.GetGenericTypeDefinition() == typeof(ICollection<>))
  {
    if (propertyType.GenericTypeArguments[0].IsPrimitive)
    {
        adapterClass = "CollectionToStringAdapter";
    }
    else
    {
        adapterClass = "CollectionAdapter";
    }
  }
  else if (propertyType.GetGenericTypeDefinition() == typeof(IDictionary<,>))
  {
      adapterClass = "CollectionToDictionaryAdapter";
  }

  string returnStatement = null;
  if (adapterClass == null)
  {
      returnStatement = string.Format("this.Raw{0}", property.Name);
  }
  else if (adapterClass == "CollectionToStringAdapter")
  {
      var genericArgumentName = propertyType.GetGenericArguments()[0].FullName;
      returnStatement = string.Format("base.{0} ?? (base.{0} = new {1}<{2}>(this.Raw{0}, newString => this.Raw{0} = newString))", property.Name, adapterClass, genericArgumentName);
  }
  else if (adapterClass != "CollectionToDictionaryAdapter")
  {
      var efCoreClassName = propertyType.GetGenericArguments()[0].Name + customTypeSuffix;
      var originalClassName = propertyType.GetGenericArguments()[0].FullName;
      returnStatement = string.Format("base.{0} ?? (base.{0} = new {1}<{2}, {3}>(this.Raw{0}))", property.Name,adapterClass, originalClassName, efCoreClassName);
  }
  else
  {
      var efCoreClassName = propertyType.GetGenericArguments()[1].Name + customTypeSuffix;
      var originalClassName = propertyType.GetGenericArguments()[1].FullName;
      var keyTypeName = propertyType.GetGenericArguments()[0].Name;
      var joinEntityClassName = type.Name+propertyType.GetGenericArguments()[1].Name;

      returnStatement = string.Format("base.{0} ?? (base.{0} = new {1}<{2}, {3}, {4}, {5}>(this.Raw{0}))", property.Name, adapterClass, keyTypeName, originalClassName, efCoreClassName, joinEntityClassName);
  }
  
#>
                return <#=returnStatement#>; 
<#}#>            }
<#          if (property.GetSetMethod(true) != null && !propertyType.IsInterface)
            {#>
            
            <#if (property.GetSetMethod() == null) {#>protected <#}#>set
            {
                base.<#=property.Name#> = value;
                this.<#=property.Name#>Id = this.Raw<#=property.Name#>?.Id;
            }
<#}#>        }

        <#}#>
        
        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            var baseObject = obj as IIdentifiable;
            if (baseObject != null)
            {
                return baseObject.Id == this.Id;
            }

            return base.Equals(obj);
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.Id.GetHashCode();
        }
    }

<#   
}
#>
    /// <summary>
    /// DbContext which sets all extended base types to ignore.
    /// </summary>
    public class ExtendedTypeContext : Microsoft.EntityFrameworkCore.DbContext
    {
        /// <inheritdoc/>
        protected override void OnModelCreating(Microsoft.EntityFrameworkCore.ModelBuilder modelBuilder)
        {
<#foreach (Type type in customTypes)
{#>
            modelBuilder.Ignore<<#=type.FullName#>>();
<#}


#>
        }

        /// <summary>
        /// Adds the generated join definitions.
        /// </summary>
        /// <param name="modelBuilder">The model builder.</param>
        protected void AddJoinDefinitions(Microsoft.EntityFrameworkCore.ModelBuilder modelBuilder)
        {
<#
var allStandaloneCollectionProperties = customTypes
    .Where(t => t.FullName != "MUnique.OpenMU.DataModel.Configuration.GameConfiguration")
    .SelectMany(t => t.GetProperties().Where(p => p.PropertyType.IsGenericType && p.PropertyType.GetGenericTypeDefinition() == typeof(ICollection<>) && standaloneTypes.Contains(p.PropertyType.GenericTypeArguments[0].FullName))).ToList();

foreach (PropertyInfo propertyInfo in allStandaloneCollectionProperties)
{
    var elementType = propertyInfo.PropertyType.GenericTypeArguments[0];
    var joinTypeName = propertyInfo.DeclaringType.Name + elementType.Name;
#>
            modelBuilder.Entity<<#=propertyInfo.DeclaringType.Name + customTypeSuffix#>>().HasMany(entity => entity.Joined<#=propertyInfo.Name#>).WithOne(join => join.<#=propertyInfo.DeclaringType.Name#>);
            modelBuilder.Entity<<#=joinTypeName#>>().HasKey(join => new { join.<#=propertyInfo.DeclaringType.Name#>Id, join.<#=elementType.Name#>Id });
<#
}

#>
        }
    }
        
    /// <summary>
    /// Configures Mapster to properly map these classes to the Persistence.BasicModel.
    /// </summary>
    public static class MapsterConfigurator
    {
        private static bool isConfigured;

        /// <summary>
        /// Ensures that Mapster is configured to properly map these EF-Core persistence classes to the Persistence.BasicModel.
        /// </summary>
        public static void EnsureConfigured()
        {
            if (isConfigured)
            {
                return;
            }

            Mapster.TypeAdapterConfig.GlobalSettings.Default.PreserveReference(true);
            Mapster.TypeAdapterConfig.GlobalSettings.Default.IgnoreMember((member, side) => member.Name.StartsWith("Raw"));
<#foreach (Type type in customTypes)
{#>
            Mapster.TypeAdapterConfig.GlobalSettings.NewConfig<<#=type.FullName#>, <#=type.FullName#>>()
                            .Include<<#=type.Name#>, BasicModel.<#=type.Name#>>();
<#
    foreach (var property in type
                        .GetProperties()
                        .Where(p => p.GetGetMethod().IsVirtual && !p.GetGetMethod().IsFinal && !p.PropertyType.IsValueType && !p.PropertyType.IsArray)
                        .Where(p => p.PropertyType.IsGenericType && p.PropertyType.GetGenericTypeDefinition() == typeof(IDictionary<,>)))
{
    var keyType = property.PropertyType.GetGenericArguments()[0];
    var valueType = property.PropertyType.GetGenericArguments()[1];
#>
            Mapster.TypeAdapterConfig.GlobalSettings.ForDestinationType<IDictionary<<#=keyType.FullName#>, <#=valueType.FullName#>>>()
                .ConstructUsing(() => new Dictionary<<#=keyType.FullName#>, <#=valueType.FullName#>>());
<#}#>

<#}#>
            isConfigured = true;
        }
    }
}
