<# 
// <copyright file="ExtendedJoinEntities.tt" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>
#>
<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ include file="..\BasicModel\Common.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <copyright file="ExtendedJoinEntities.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by a T4 template.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Persistence.EntityFramework
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations.Schema;
    
<#
var customTypes = this.GetCustomTypes();
string customTypeSuffix = string.Empty;

var joinProperties = customTypes.SelectMany(t => t.GetProperties().Where(p => p.PropertyType.IsGenericType && p.PropertyType.GetGenericTypeDefinition() == typeof(IDictionary<,>))).ToList();

foreach (PropertyInfo propertyInfo in joinProperties)
{
    var keyType = propertyInfo.PropertyType.GenericTypeArguments[0];
    var elementType = propertyInfo.PropertyType.GenericTypeArguments[1];
    var joinTypeName = propertyInfo.DeclaringType.Name + elementType.Name;
    #>
    [Table("<#=joinTypeName#>", Schema = "<#=IsConfigurationType(propertyInfo.DeclaringType) ? "config" : "data" #>")]
    internal partial class <#=joinTypeName#> : IDictionaryEntity<<#=keyType.Name#>, <#=elementType.Name + customTypeSuffix#>>
    {
        public <#=keyType.Name#> Key { get; set; }

        public Guid ValueId { get; set; }

        [ForeignKey("ValueId")]
        public <#=elementType.Name + customTypeSuffix#> Value { get; set; }
    }

<#
}
#>
<#
var standaloneCollectionProperties = customTypes
    .Where(t => t.FullName != "MUnique.OpenMU.DataModel.Configuration.GameConfiguration")
    .SelectMany(t => t.GetProperties().Where(p => p.PropertyType.IsGenericType && p.PropertyType.GetGenericTypeDefinition() == typeof(ICollection<>) && standaloneTypes.Contains(p.PropertyType.GenericTypeArguments[0].FullName)))
    .ToList();

foreach (PropertyInfo propertyInfo in standaloneCollectionProperties)
{
    var elementType = propertyInfo.PropertyType.GenericTypeArguments[0];
    var joinTypeName = propertyInfo.DeclaringType.Name + elementType.Name;
    #>
    [Table("<#=joinTypeName#>", Schema = "<#=IsConfigurationType(propertyInfo.DeclaringType) ? "config" : "data" #>")]
    internal partial class <#=joinTypeName#> 
    {
        public Guid <#=propertyInfo.DeclaringType.Name#>Id { get; set; }
        public <#=propertyInfo.DeclaringType.Name + customTypeSuffix#> <#=propertyInfo.DeclaringType.Name#> { get; set; }

        public Guid <#=elementType.Name#>Id { get; set; }
        public <#=elementType.Name + customTypeSuffix#> <#=elementType.Name#> { get; set; }
    }

    internal partial class <#=propertyInfo.DeclaringType.Name + customTypeSuffix#>
    {
        public ICollection<<#=joinTypeName#>> Joined<#=propertyInfo.Name#> { get; } = new List<<#=joinTypeName#>>();
    }

<#
}
#>
}