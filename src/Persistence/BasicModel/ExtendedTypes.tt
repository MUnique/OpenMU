<#
// <copyright file="ExtendedTypes.tt" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>
#>
<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ include file="Common.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <copyright file="ExtendedTypes.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by a T4 template.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All

namespace MUnique.OpenMU.Persistence.BasicModel
{
    using System;
    using System.Collections.Generic;
    using MUnique.OpenMU.Persistence.Json;

<#
List<Type> customTypes = this.GetCustomTypes();
foreach (Type type in customTypes)
{
    string className = type.Name;
#>
    /// <summary>
    /// A plain implementation of <see cref="<#=type.FullName#>"/>.
    /// </summary>
    public partial class <#=className #> : <#=type.FullName#>, IIdentifiable, IConvertibleTo<<#=className#>>
    {<#
        if (type.GetConstructors().Any(c => c.IsPublic && c.GetParameters().Length > 0) && type.GetConstructors().Any(c => c.GetParameters().Length == 0))
        {#>

        /// <inheritdoc />
        public <#=className #>()
        {
        } <# 
        }
        foreach (var constructor in type.GetConstructors().Where(c => c.IsPublic && c.GetParameters().Length > 0))
        {
            var parameters = constructor.GetParameters();
        #>


        /// <inheritdoc />
        public <#=className #>(<# 
        foreach (var p in parameters) 
        { 
            string parameterTypeName;
            var parameterType = p.ParameterType;
            if (!parameterType.IsGenericType)
            {
                parameterTypeName = parameterType.FullName;
            }
            else
            {
                parameterTypeName = parameterType.Name.Split('`')[0] + "<" + string.Join(", ", parameterType.GetGenericArguments().Select(x => x.FullName).ToArray()) + ">";
            }
        #><#=parameterTypeName#> <#=p.Name#><#
            if (parameters.Length > p.Position + 1 ) { #>, <# }
        } //end for each parameter
        #>)
          : base (<# 
        foreach (var p in parameters) 
        { 
        #><#=p.Name#><#
            if (parameters.Length > p.Position + 1 ) { #>, <# }
        } //end for each parameter
        #>)
        {
        }<#
        } // end foreach constructor
        #>
<#
        if (type.GetProperty("Id") == null)
        {
#>

        /// <summary>
        /// Gets or sets the identifier of this instance.
        /// </summary>
        public Guid Id { get; set; }
<#
        }

        var virtualNavigationProperties = type.GetProperties().Where(p => p.GetGetMethod().IsVirtual && !p.GetGetMethod().IsFinal && !p.PropertyType.IsValueType && !p.PropertyType.IsArray);
       
        var dictionaryProperties = virtualNavigationProperties.Where(p => p.PropertyType.IsGenericType && p.PropertyType.GetGenericTypeDefinition() == typeof(IDictionary<,>));
        
        foreach (var property in dictionaryProperties)
        {
            // we're building a 
            var propertyType = property.PropertyType;
            var originalPropertyTypeName =propertyType.Name.Split('`')[0] + "<" + string.Join(", ", propertyType.GetGenericArguments().Select(x => x.FullName).ToArray()) + ">";
            var keyType = propertyType.GetGenericArguments()[0];
            var valueType = propertyType.GetGenericArguments()[1];
            var rawPropertyTypeName = string.Format("IDictionary<{0}, {1}>", keyType.Name, valueType.Name);
            var persistentClassName = valueType.Name;
            var originalClassName = valueType.FullName;
            // var returnStatement = string.Format("base.{0} ?? (base.{0} = new DictionaryAdapter<{1}, {2}>(this.Raw{0}))", property.Name, originalClassName, persistentClassName);
            #>

        /// <summary>
        /// Gets the raw dictionary of <see cref="<#=property.Name#>" />.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("<#=ToCamelCase(property.Name)#>")]
        [System.Text.Json.Serialization.JsonPropertyName("<#=ToCamelCase(property.Name)#>")]
        public IDictionary<<#=keyType.Name#>, <#=persistentClassName#>> Raw<#=property.Name#> { get; } = new Dictionary<<#=keyType.Name#>, <#=persistentClassName#>>();
        
        /// <inheritdoc/>
        [Newtonsoft.Json.JsonIgnore]
        [System.Text.Json.Serialization.JsonIgnore]
        public override <#=originalPropertyTypeName#> <#=property.Name#>
        {
            get
            {
                return base.<#=property.Name#> ?? (base.<#=property.Name#> = new DictionaryAdapter<<#=keyType.Name#>, <#=originalClassName#>, <#=persistentClassName#>>(this.Raw<#=property.Name#>));
            }
            protected set
            {
                this.<#=property.Name#>.Clear();
                foreach (var item in value)
                {
                    this.<#=property.Name#>.Add(item);
                }
            }
        }
<#
        }

        var collectionProperties = virtualNavigationProperties.Where(p => p.PropertyType.IsGenericType 
                                        && (p.PropertyType.GetGenericTypeDefinition() == typeof(ICollection<>) 
                                            || p.PropertyType.GetGenericTypeDefinition() == typeof(IList<>))
                                        && !p.PropertyType.GenericTypeArguments[0].IsPrimitive);
        foreach (var property in collectionProperties)
        {
            var propertyType = property.PropertyType;
            var persistentClassName = propertyType.GetGenericArguments()[0].Name;
            var originalClassName = propertyType.GetGenericArguments()[0].FullName;
            
            var originalPropertyTypeName = propertyType.Name.Split('`')[0] + "<" + originalClassName + ">";
            var propertyTypeName = propertyType.Name.Split('`')[0] + "<" + persistentClassName + ">";
         
            
            
#>

        /// <summary>
        /// Gets the raw collection of <see cref="<#=property.Name#>" />.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("<#=ToCamelCase(property.Name)#>")]
        [System.Text.Json.Serialization.JsonPropertyName("<#=ToCamelCase(property.Name)#>")]
        public <#=propertyTypeName#> Raw<#=property.Name#> { get; } = new List<<#=persistentClassName#>>();
        
        /// <inheritdoc/>
        [Newtonsoft.Json.JsonIgnore]
        [System.Text.Json.Serialization.JsonIgnore]
        public override <#=originalPropertyTypeName#> <#=property.Name#>
        {
            get
            {
<#  
  
            string adapterClass = null;
            if (propertyType.GetGenericTypeDefinition() == typeof(IList<>))
            {
                adapterClass = "ListAdapter";
            } 
            else
            {
                adapterClass = "CollectionAdapter";
            }

            var returnStatement = string.Format("base.{0} ?? (base.{0} = new {1}<{2}, {3}>(this.Raw{0}))", property.Name, adapterClass, originalClassName, persistentClassName);
  
 
#>
                return <#=returnStatement#>; 
            }
            protected set
            {
                this.<#=property.Name#>.Clear();
                foreach (var item in value)
                {
                    this.<#=property.Name#>.Add(item);
                }
            }
        }
<#      }

        var navigationProperties = virtualNavigationProperties.Where(p => !p.PropertyType.IsGenericType);
        foreach (var property in navigationProperties)
        {
            var propertyTypeName = property.PropertyType.Name.Split('.').Last();
            var propertyType = property.PropertyType;
            
        #>

        /// <summary>
        /// Gets the raw object of <see cref="<#=property.Name#>" />.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("<#=ToCamelCase(property.Name)#>")]
        [System.Text.Json.Serialization.JsonPropertyName("<#=ToCamelCase(property.Name)#>")]
        public <#=propertyTypeName#> Raw<#=property.Name#>
        { 
            get { return base.<#=property.Name#> as <#=propertyTypeName#>; }
            <#if (property.GetSetMethod(true) != null) {#>set { base.<#=property.Name#> = value; } 
<#}#>
        }
        
        /// <inheritdoc/>
        [Newtonsoft.Json.JsonIgnore]
        [System.Text.Json.Serialization.JsonIgnore]
        public override <#=propertyType.FullName#> <#=property.Name#>
        {
            get
            {
                return base.<#=property.Name#>;
            }
<#          if (property.GetSetMethod(true) != null)
            {#>
            
            <#if (property.GetSetMethod() == null) {#>protected <#}#>set
            {
                base.<#=property.Name#> = value;
            }
<#}#>
        }
<#
        } // end foreach navigation properties
#>
        
        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            var baseObject = obj as IIdentifiable;
            if (baseObject != null)
            {
                return baseObject.Id == this.Id;
            }

            return base.Equals(obj);
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            return this.Id.GetHashCode();
        }

        /// <inheritdoc/>
        public <#=className#> Convert() => this;
    }

<#   
}
#>    
}