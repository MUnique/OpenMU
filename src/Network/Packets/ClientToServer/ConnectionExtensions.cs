// <copyright file="ConnectionExtensions.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable RedundantVerbatimPrefix
// ReSharper disable AssignmentIsFullyDiscarded
// ReSharper disable UnusedMember.Global
// ReSharper disable UseObjectOrCollectionInitializer

#nullable enable
namespace MUnique.OpenMU.Network.Packets.ClientToServer;

using System;
using System.Threading;
using MUnique.OpenMU.Network;

/// <summary>
/// Extension methods to start writing messages of this namespace on a <see cref="IConnection"/>.
/// </summary>
public static class ConnectionExtensions
{

    /// <summary>
    /// Sends a <see cref="Ping" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="tickCount">The tick count.</param>
    /// <param name="attackSpeed">The attack speed.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client every few seconds. It contains the current "TickCount" of the client operating system and the attack speed of the selected character.
    /// Causes reaction on server side: By the original server this is used to detect speed hacks.
    /// </remarks>
    public static async ValueTask SendPingAsync(this IConnection? connection, uint @tickCount, ushort @attackSpeed)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PingRef.Length;
            var packet = new PingRef(connection.Output.GetSpan(length)[..length]);
            packet.TickCount = @tickCount;
            packet.AttackSpeed = @attackSpeed;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ChecksumResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="checksum">The checksum.</param>
    /// <remarks>
    /// Is sent by the client when: This packet is sent by the client as a response to a request with a challenge value.
    /// Causes reaction on server side: By the original server, this is used to detect a modified client.
    /// </remarks>
    public static async ValueTask SendChecksumResponseAsync(this IConnection? connection, uint @checksum)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ChecksumResponseRef.Length;
            var packet = new ChecksumResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Checksum = @checksum;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PublicChatMessage" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="character">The character.</param>
    /// <param name="message">The message.</param>
    /// <remarks>
    /// Is sent by the client when: A player sends a public chat message.
    /// Causes reaction on server side: The message is forwarded to all surrounding players, including the sender.
    /// </remarks>
    public static async ValueTask SendPublicChatMessageAsync(this IConnection? connection, string @character, string @message)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PublicChatMessageRef.GetRequiredSize(message);
            var packet = new PublicChatMessageRef(connection.Output.GetSpan(length)[..length]);
            packet.Character = @character;
            packet.Message = @message;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="WhisperMessage" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="receiverName">The receiver name.</param>
    /// <param name="message">The message.</param>
    /// <remarks>
    /// Is sent by the client when: A player sends a private chat message to a specific target player.
    /// Causes reaction on server side: The message is forwarded to the target player.
    /// </remarks>
    public static async ValueTask SendWhisperMessageAsync(this IConnection? connection, string @receiverName, string @message)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = WhisperMessageRef.GetRequiredSize(message);
            var packet = new WhisperMessageRef(connection.Output.GetSpan(length)[..length]);
            packet.ReceiverName = @receiverName;
            packet.Message = @message;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LoginLongPassword" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="username">The user name, "encrypted" with Xor3.</param>
    /// <param name="password">The password, "encrypted" with Xor3.</param>
    /// <param name="tickCount">The tick count.</param>
    /// <param name="clientVersion">The client version.</param>
    /// <param name="clientSerial">The client serial.</param>
    /// <remarks>
    /// Is sent by the client when: The player tries to log into the game.
    /// Causes reaction on server side: The server is authenticating the sent login name and password. If it's correct, the state of the player is proceeding to be logged in.
    /// </remarks>
    public static async ValueTask SendLoginLongPasswordAsync(this IConnection? connection, Memory<byte> @username, Memory<byte> @password, uint @tickCount, Memory<byte> @clientVersion, Memory<byte> @clientSerial)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LoginLongPasswordRef.Length;
            var packet = new LoginLongPasswordRef(connection.Output.GetSpan(length)[..length]);
            @username.Span.CopyTo(packet.Username);
            @password.Span.CopyTo(packet.Password);
            packet.TickCount = @tickCount;
            @clientVersion.Span.CopyTo(packet.ClientVersion);
            @clientSerial.Span.CopyTo(packet.ClientSerial);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LoginShortPassword" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="username">The user name, "encrypted" with Xor3.</param>
    /// <param name="password">The password, "encrypted" with Xor3.</param>
    /// <param name="tickCount">The tick count.</param>
    /// <param name="clientVersion">The client version.</param>
    /// <param name="clientSerial">The client serial.</param>
    /// <remarks>
    /// Is sent by the client when: The player tries to log into the game.
    /// Causes reaction on server side: The server is authenticating the sent login name and password. If it's correct, the state of the player is proceeding to be logged in.
    /// </remarks>
    public static async ValueTask SendLoginShortPasswordAsync(this IConnection? connection, Memory<byte> @username, Memory<byte> @password, uint @tickCount, Memory<byte> @clientVersion, Memory<byte> @clientSerial)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LoginShortPasswordRef.Length;
            var packet = new LoginShortPasswordRef(connection.Output.GetSpan(length)[..length]);
            @username.Span.CopyTo(packet.Username);
            @password.Span.CopyTo(packet.Password);
            packet.TickCount = @tickCount;
            @clientVersion.Span.CopyTo(packet.ClientVersion);
            @clientSerial.Span.CopyTo(packet.ClientSerial);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="Login075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="username">The user name, "encrypted" with Xor3.</param>
    /// <param name="password">The password, "encrypted" with Xor3.</param>
    /// <param name="tickCount">The tick count.</param>
    /// <param name="clientVersion">The client version.</param>
    /// <param name="clientSerial">The client serial.</param>
    /// <remarks>
    /// Is sent by the client when: The player tries to log into the game.
    /// Causes reaction on server side: The server is authenticating the sent login name and password. If it's correct, the state of the player is proceeding to be logged in.
    /// </remarks>
    public static async ValueTask SendLogin075Async(this IConnection? connection, Memory<byte> @username, Memory<byte> @password, uint @tickCount, Memory<byte> @clientVersion, Memory<byte> @clientSerial)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = Login075Ref.Length;
            var packet = new Login075Ref(connection.Output.GetSpan(length)[..length]);
            @username.Span.CopyTo(packet.Username);
            @password.Span.CopyTo(packet.Password);
            packet.TickCount = @tickCount;
            @clientVersion.Span.CopyTo(packet.ClientVersion);
            @clientSerial.Span.CopyTo(packet.ClientSerial);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LogOut" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="type">The type.</param>
    /// <remarks>
    /// Is sent by the client when: When the client wants to leave the game in various ways.
    /// Causes reaction on server side: Depending on the LogOutType, the game server does several checks and sends a response back to the client. If the request was successful, the game client either closes the game, goes back to server or character selection.
    /// </remarks>
    public static async ValueTask SendLogOutAsync(this IConnection? connection, LogOutType @type)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LogOutRef.Length;
            var packet = new LogOutRef(connection.Output.GetSpan(length)[..length]);
            packet.Type = @type;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LogOutByCheatDetection" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="param">The param.</param>
    /// <param name="type">The type.</param>
    /// <remarks>
    /// Is sent by the client when: When the client wants to leave the game in various ways.
    /// Causes reaction on server side: Depending on the LogOutType, the game server does several checks and sends a response back to the client. If the request was successful, the game client either closes the game, goes back to server or character selection.
    /// </remarks>
    public static async ValueTask SendLogOutByCheatDetectionAsync(this IConnection? connection, byte @param, byte @type = 4)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LogOutByCheatDetectionRef.Length;
            var packet = new LogOutByCheatDetectionRef(connection.Output.GetSpan(length)[..length]);
            packet.Type = @type;
            packet.Param = @param;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ResetCharacterPointRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: Unknown?
    /// Causes reaction on server side: Unknown?
    /// </remarks>
    public static async ValueTask SendResetCharacterPointRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ResetCharacterPointRequestRef.Length;
            var packet = new ResetCharacterPointRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PlayerShopSetItemPrice" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="itemSlot">The item slot.</param>
    /// <param name="price">The price.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to set a price of an item which is inside his personal item shop.
    /// Causes reaction on server side: The price is set for the specified item. Works only if the shop is currently closed.
    /// </remarks>
    public static async ValueTask SendPlayerShopSetItemPriceAsync(this IConnection? connection, byte @itemSlot, uint @price)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PlayerShopSetItemPriceRef.Length;
            var packet = new PlayerShopSetItemPriceRef(connection.Output.GetSpan(length)[..length]);
            packet.ItemSlot = @itemSlot;
            packet.Price = @price;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PlayerShopOpen" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="storeName">The store name.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to open his personal item shop.
    /// Causes reaction on server side: The personal item shop is opened and the surrounding players are informed about it, including the own player.
    /// </remarks>
    public static async ValueTask SendPlayerShopOpenAsync(this IConnection? connection, string @storeName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PlayerShopOpenRef.Length;
            var packet = new PlayerShopOpenRef(connection.Output.GetSpan(length)[..length]);
            packet.StoreName = @storeName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PlayerShopClose" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to close his personal item shop.
    /// Causes reaction on server side: The personal item shop is closed and the surrounding players are informed about it, including the own player.
    /// </remarks>
    public static async ValueTask SendPlayerShopCloseAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PlayerShopCloseRef.Length;
            var packet = new PlayerShopCloseRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PlayerShopItemListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="playerName">The player name.</param>
    /// <remarks>
    /// Is sent by the client when: A player opens a shop of another player.
    /// Causes reaction on server side: The list of items is sent back, if the shop of the player is currently open.
    /// </remarks>
    public static async ValueTask SendPlayerShopItemListRequestAsync(this IConnection? connection, ushort @playerId, string @playerName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PlayerShopItemListRequestRef.Length;
            var packet = new PlayerShopItemListRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.PlayerId = @playerId;
            packet.PlayerName = @playerName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PlayerShopItemBuyRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="playerName">The player name.</param>
    /// <param name="itemSlot">The item slot.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to buy the item of another players shop.
    /// Causes reaction on server side: If the buyer has enough money, the item is sold to the player. Both players will get notifications about that.
    /// </remarks>
    public static async ValueTask SendPlayerShopItemBuyRequestAsync(this IConnection? connection, ushort @playerId, string @playerName, byte @itemSlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PlayerShopItemBuyRequestRef.Length;
            var packet = new PlayerShopItemBuyRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.PlayerId = @playerId;
            packet.PlayerName = @playerName;
            packet.ItemSlot = @itemSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PlayerShopCloseOther" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="playerName">The player name.</param>
    /// <remarks>
    /// Is sent by the client when: A player closes the dialog of another players shop.
    /// Causes reaction on server side: The server handles that by unsubscribing the player from changes of the shop.
    /// </remarks>
    public static async ValueTask SendPlayerShopCloseOtherAsync(this IConnection? connection, ushort @playerId, string @playerName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PlayerShopCloseOtherRef.Length;
            var packet = new PlayerShopCloseOtherRef(connection.Output.GetSpan(length)[..length]);
            packet.PlayerId = @playerId;
            packet.PlayerName = @playerName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PickupItemRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="itemId">The item id.</param>
    /// <remarks>
    /// Is sent by the client when: A player requests to pick up an item which is laying on the ground in the near of the players character.
    /// Causes reaction on server side: If the player is allowed to pick the item up, and is the first player which tried that, it tries to add the item to the inventory. The server sends a response about the result of the request.
    /// </remarks>
    public static async ValueTask SendPickupItemRequestAsync(this IConnection? connection, ushort @itemId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PickupItemRequestRef.Length;
            var packet = new PickupItemRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.ItemId = @itemId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PickupItemRequest075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="itemId">The item id.</param>
    /// <remarks>
    /// Is sent by the client when: A player requests to pick up an item which is laying on the ground in the near of the players character.
    /// Causes reaction on server side: If the player is allowed to pick the item up, and is the first player which tried that, it tries to add the item to the inventory. The server sends a response about the result of the request.
    /// </remarks>
    public static async ValueTask SendPickupItemRequest075Async(this IConnection? connection, ushort @itemId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PickupItemRequest075Ref.Length;
            var packet = new PickupItemRequest075Ref(connection.Output.GetSpan(length)[..length]);
            packet.ItemId = @itemId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DropItemRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="targetX">The target x.</param>
    /// <param name="targetY">The target y.</param>
    /// <param name="itemSlot">The item slot.</param>
    /// <remarks>
    /// Is sent by the client when: A player requests to drop on item of his inventory on the ground.
    /// Causes reaction on server side: When the specified coordinates are valid, and the item is allowed to be dropped, it will be dropped on the ground and the surrounding players are notified.
    /// </remarks>
    public static async ValueTask SendDropItemRequestAsync(this IConnection? connection, byte @targetX, byte @targetY, byte @itemSlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DropItemRequestRef.Length;
            var packet = new DropItemRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.TargetX = @targetX;
            packet.TargetY = @targetY;
            packet.ItemSlot = @itemSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ItemMoveRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="fromStorage">The from storage.</param>
    /// <param name="fromSlot">The from slot.</param>
    /// <param name="itemData">The item data.</param>
    /// <param name="toStorage">The to storage.</param>
    /// <param name="toSlot">The to slot.</param>
    /// <remarks>
    /// Is sent by the client when: A player requests to move an item within or between his available item storage, such as inventory, vault, trade or chaos machine.
    /// Causes reaction on server side: 
    /// </remarks>
    public static async ValueTask SendItemMoveRequestAsync(this IConnection? connection, ItemStorageKind @fromStorage, byte @fromSlot, Memory<byte> @itemData, ItemStorageKind @toStorage, byte @toSlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ItemMoveRequestRef.Length;
            var packet = new ItemMoveRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.FromStorage = @fromStorage;
            packet.FromSlot = @fromSlot;
            @itemData.Span.CopyTo(packet.ItemData);
            packet.ToStorage = @toStorage;
            packet.ToSlot = @toSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ConsumeItemRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="itemSlot">The inventory slot index of the item which should be consumed.</param>
    /// <param name="targetSlot">If the item has an effect on another item, e.g. upgrading it, this field contains the inventory slot index of the target item.</param>
    /// <param name="fruitConsumption">Defines how the fruit is used. Only applies, if the the item is a fruit.</param>
    /// <remarks>
    /// Is sent by the client when: A player requests to 'consume' an item. This can be a potion which recovers some kind of attribute, or a jewel to upgrade a target item.
    /// Causes reaction on server side: The server tries to 'consume' the specified item and responses accordingly.
    /// </remarks>
    public static async ValueTask SendConsumeItemRequestAsync(this IConnection? connection, byte @itemSlot, byte @targetSlot, ConsumeItemRequest.FruitUsage @fruitConsumption)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ConsumeItemRequestRef.Length;
            var packet = new ConsumeItemRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.ItemSlot = @itemSlot;
            packet.TargetSlot = @targetSlot;
            packet.FruitConsumption = @fruitConsumption;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ConsumeItemRequest075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="itemSlot">The inventory slot index of the item which should be consumed.</param>
    /// <param name="targetSlot">If the item has an effect on another item, e.g. upgrading it, this field contains the inventory slot index of the target item.</param>
    /// <remarks>
    /// Is sent by the client when: A player requests to 'consume' an item. This can be a potion which recovers some kind of attribute, or a jewel to upgrade a target item.
    /// Causes reaction on server side: The server tries to 'consume' the specified item and responses accordingly.
    /// </remarks>
    public static async ValueTask SendConsumeItemRequest075Async(this IConnection? connection, byte @itemSlot, byte @targetSlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ConsumeItemRequest075Ref.Length;
            var packet = new ConsumeItemRequest075Ref(connection.Output.GetSpan(length)[..length]);
            packet.ItemSlot = @itemSlot;
            packet.TargetSlot = @targetSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TalkToNpcRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="npcId">The npc id.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to talk to an NPC.
    /// Causes reaction on server side: Based on the NPC type, the server sends a response back to the game client. For example, if it's a merchant NPC, it sends back that a merchant dialog should be opened and which items are offered by this NPC.
    /// </remarks>
    public static async ValueTask SendTalkToNpcRequestAsync(this IConnection? connection, ushort @npcId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TalkToNpcRequestRef.Length;
            var packet = new TalkToNpcRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.NpcId = @npcId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CloseNpcRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: A player closes the dialog which was opened by an interaction with a NPC.
    /// Causes reaction on server side: The server updates the state of the player accordingly.
    /// </remarks>
    public static async ValueTask SendCloseNpcRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CloseNpcRequestRef.Length;
            var packet = new CloseNpcRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="BuyItemFromNpcRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="itemSlot">Item Slot (NPC Store)</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to buy an item from an opened NPC merchant.
    /// Causes reaction on server side: If the player has enough money, the item is added to the inventory and money is removed. Corresponding messages are sent back to the game client.
    /// </remarks>
    public static async ValueTask SendBuyItemFromNpcRequestAsync(this IConnection? connection, byte @itemSlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = BuyItemFromNpcRequestRef.Length;
            var packet = new BuyItemFromNpcRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.ItemSlot = @itemSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SellItemToNpcRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="itemSlot">Item Slot (Inventory)</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to sell an item of his inventory to the opened NPC merchant.
    /// Causes reaction on server side: The item is sold for money to the NPC. The item is removed from the inventory and money is added. Corresponding messages are sent back to the game client.
    /// </remarks>
    public static async ValueTask SendSellItemToNpcRequestAsync(this IConnection? connection, byte @itemSlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SellItemToNpcRequestRef.Length;
            var packet = new SellItemToNpcRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.ItemSlot = @itemSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RepairItemRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="itemSlot">Inventory item slot of the target item. If it's 0xFF, the player wants to repair all items - this is only possible with some opened NPC dialogs. Repairing the pet item slot (8) is only possible when the pet trainer npc is opened.</param>
    /// <param name="isSelfRepair">If the player repairs it over his inventory, it's true. However, a server should never rely on this flag and do his own checks.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to repair an item of his inventory.
    /// Causes reaction on server side: The item is repaired if the player has enough money in its inventory. A corresponding response is sent.
    /// </remarks>
    public static async ValueTask SendRepairItemRequestAsync(this IConnection? connection, byte @itemSlot, bool @isSelfRepair)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RepairItemRequestRef.Length;
            var packet = new RepairItemRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.ItemSlot = @itemSlot;
            packet.IsSelfRepair = @isSelfRepair;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="WarpCommandRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="commandKey">A command key, which is generated by a 'secret' algorithm. Not considered in OpenMU.</param>
    /// <param name="warpInfoIndex">The index of the entry in the warp list.</param>
    /// <remarks>
    /// Is sent by the client when: A player selected to warp by selecting an entry in the warp list (configured in game client files).
    /// Causes reaction on server side: If the player has enough money and is allowed to enter the map, it's getting moved to there.
    /// </remarks>
    public static async ValueTask SendWarpCommandRequestAsync(this IConnection? connection, uint @commandKey, ushort @warpInfoIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = WarpCommandRequestRef.Length;
            var packet = new WarpCommandRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.CommandKey = @commandKey;
            packet.WarpInfoIndex = @warpInfoIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="EnterGateRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="gateNumber">The gate number.</param>
    /// <param name="teleportTargetX">The teleport target x.</param>
    /// <param name="teleportTargetY">The teleport target y.</param>
    /// <remarks>
    /// Is sent by the client when: Usually: When the player enters an area on the game map which is configured as gate at the client data files. In the special case of wizards, this packet is also used for the teleport skill. When this is the case, GateNumber is 0 and the target coordinates are specified.
    /// Causes reaction on server side: If the player is allowed to enter the "gate", it's moved to the corresponding exit gate area.
    /// </remarks>
    public static async ValueTask SendEnterGateRequestAsync(this IConnection? connection, ushort @gateNumber, byte @teleportTargetX, byte @teleportTargetY)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = EnterGateRequestRef.Length;
            var packet = new EnterGateRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.GateNumber = @gateNumber;
            packet.TeleportTargetX = @teleportTargetX;
            packet.TeleportTargetY = @teleportTargetY;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="EnterGateRequest075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="gateNumber">The gate number.</param>
    /// <param name="teleportTargetX">The teleport target x.</param>
    /// <param name="teleportTargetY">The teleport target y.</param>
    /// <remarks>
    /// Is sent by the client when: Usually: When the player enters an area on the game map which is configured as gate at the client data files. In the special case of wizards, this packet is also used for the teleport skill. When this is the case, GateNumber is 0 and the target coordinates are specified.
    /// Causes reaction on server side: If the player is allowed to enter the "gate", it's moved to the corresponding exit gate area.
    /// </remarks>
    public static async ValueTask SendEnterGateRequest075Async(this IConnection? connection, byte @gateNumber, byte @teleportTargetX, byte @teleportTargetY)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = EnterGateRequest075Ref.Length;
            var packet = new EnterGateRequest075Ref(connection.Output.GetSpan(length)[..length]);
            packet.GateNumber = @gateNumber;
            packet.TeleportTargetX = @teleportTargetX;
            packet.TeleportTargetY = @teleportTargetY;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TeleportTarget" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="targetId">The target id.</param>
    /// <param name="teleportTargetX">The teleport target x.</param>
    /// <param name="teleportTargetY">The teleport target y.</param>
    /// <remarks>
    /// Is sent by the client when: A wizard uses the 'Teleport Ally' skill to teleport a party member of his view range to a nearby coordinate.
    /// Causes reaction on server side: If the target player is in the same party and in the range, it will teleported to the specified coordinates.
    /// </remarks>
    public static async ValueTask SendTeleportTargetAsync(this IConnection? connection, ushort @targetId, byte @teleportTargetX, byte @teleportTargetY)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TeleportTargetRef.Length;
            var packet = new TeleportTargetRef(connection.Output.GetSpan(length)[..length]);
            packet.TargetId = @targetId;
            packet.TeleportTargetX = @teleportTargetX;
            packet.TeleportTargetY = @teleportTargetY;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ServerChangeAuthentication" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="accountXor3">The account xor 3.</param>
    /// <param name="characterNameXor3">The character name xor 3.</param>
    /// <param name="authCode1">The auth code 1.</param>
    /// <param name="authCode2">The auth code 2.</param>
    /// <param name="authCode3">The auth code 3.</param>
    /// <param name="authCode4">The auth code 4.</param>
    /// <param name="tickCount">The tick count.</param>
    /// <param name="clientVersion">The client version.</param>
    /// <param name="clientSerial">The client serial.</param>
    /// <remarks>
    /// Is sent by the client when: After the client connected to another server due map change.
    /// Causes reaction on server side: The player spawns on the new server.
    /// </remarks>
    public static async ValueTask SendServerChangeAuthenticationAsync(this IConnection? connection, Memory<byte> @accountXor3, Memory<byte> @characterNameXor3, uint @authCode1, uint @authCode2, uint @authCode3, uint @authCode4, uint @tickCount, Memory<byte> @clientVersion, Memory<byte> @clientSerial)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ServerChangeAuthenticationRef.Length;
            var packet = new ServerChangeAuthenticationRef(connection.Output.GetSpan(length)[..length]);
            @accountXor3.Span.CopyTo(packet.AccountXor3);
            @characterNameXor3.Span.CopyTo(packet.CharacterNameXor3);
            packet.AuthCode1 = @authCode1;
            packet.AuthCode2 = @authCode2;
            packet.AuthCode3 = @authCode3;
            packet.AuthCode4 = @authCode4;
            packet.TickCount = @tickCount;
            @clientVersion.Span.CopyTo(packet.ClientVersion);
            @clientSerial.Span.CopyTo(packet.ClientSerial);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeStatusRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player opened a castle siege npc and requests the current castle siege status information.
    /// Causes reaction on server side: The server returns the status of the castle siege event.
    /// </remarks>
    public static async ValueTask SendCastleSiegeStatusRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeStatusRequestRef.Length;
            var packet = new CastleSiegeStatusRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeRegistrationRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player opened a castle siege npc to register his guild alliance.
    /// Causes reaction on server side: The server returns the result of the castle siege registration.
    /// </remarks>
    public static async ValueTask SendCastleSiegeRegistrationRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeRegistrationRequestRef.Length;
            var packet = new CastleSiegeRegistrationRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeUnregisterRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="isGivingUp">The is giving up.</param>
    /// <remarks>
    /// Is sent by the client when: The player opened a castle siege npc to un-register his guild alliance.
    /// Causes reaction on server side: The server returns the result of the castle siege un-registration.
    /// </remarks>
    public static async ValueTask SendCastleSiegeUnregisterRequestAsync(this IConnection? connection, bool @isGivingUp = true)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeUnregisterRequestRef.Length;
            var packet = new CastleSiegeUnregisterRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.IsGivingUp = @isGivingUp;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeRegistrationStateRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player opened a castle siege npc and requests the state about the own registration.
    /// Causes reaction on server side: The server returns the state of the castle siege registration, which includes the number of submitted guild marks.
    /// </remarks>
    public static async ValueTask SendCastleSiegeRegistrationStateRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeRegistrationStateRequestRef.Length;
            var packet = new CastleSiegeRegistrationStateRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeMarkRegistration" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="itemIndex">The item index.</param>
    /// <remarks>
    /// Is sent by the client when: The player opened a castle siege npc and adds a guild mark to his guilds registration.
    /// Causes reaction on server side: The server returns a response, which includes the number of submitted guild marks.
    /// </remarks>
    public static async ValueTask SendCastleSiegeMarkRegistrationAsync(this IConnection? connection, byte @itemIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeMarkRegistrationRef.Length;
            var packet = new CastleSiegeMarkRegistrationRef(connection.Output.GetSpan(length)[..length]);
            packet.ItemIndex = @itemIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeDefenseBuyRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="npcNumber">The npc number.</param>
    /// <param name="npcIndex">The npc index.</param>
    /// <remarks>
    /// Is sent by the client when: The player opened a castle siege npc and requests to buy a gate or statue for a specific position (index)..
    /// Causes reaction on server side: The server returns a response.
    /// </remarks>
    public static async ValueTask SendCastleSiegeDefenseBuyRequestAsync(this IConnection? connection, uint @npcNumber, uint @npcIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeDefenseBuyRequestRef.Length;
            var packet = new CastleSiegeDefenseBuyRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.NpcNumber = @npcNumber;
            packet.NpcIndex = @npcIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeDefenseRepairRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="npcNumber">The npc number.</param>
    /// <param name="npcIndex">The npc index.</param>
    /// <remarks>
    /// Is sent by the client when: The player opened a castle siege npc and requests to repair a gate or statue at a specific position (index)..
    /// Causes reaction on server side: The server returns a response.
    /// </remarks>
    public static async ValueTask SendCastleSiegeDefenseRepairRequestAsync(this IConnection? connection, uint @npcNumber, uint @npcIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeDefenseRepairRequestRef.Length;
            var packet = new CastleSiegeDefenseRepairRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.NpcNumber = @npcNumber;
            packet.NpcIndex = @npcIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeDefenseUpgradeRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="npcNumber">The npc number.</param>
    /// <param name="npcIndex">The npc index.</param>
    /// <param name="npcUpgradeType">The npc upgrade type.</param>
    /// <param name="npcUpgradeValue">The npc upgrade value.</param>
    /// <remarks>
    /// Is sent by the client when: The player opened a castle siege npc and requests to upgrade a gate or statue at a specific position (index)..
    /// Causes reaction on server side: The server returns a response.
    /// </remarks>
    public static async ValueTask SendCastleSiegeDefenseUpgradeRequestAsync(this IConnection? connection, uint @npcNumber, uint @npcIndex, uint @npcUpgradeType, uint @npcUpgradeValue)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeDefenseUpgradeRequestRef.Length;
            var packet = new CastleSiegeDefenseUpgradeRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.NpcNumber = @npcNumber;
            packet.NpcIndex = @npcIndex;
            packet.NpcUpgradeType = @npcUpgradeType;
            packet.NpcUpgradeValue = @npcUpgradeValue;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeTaxInfoRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The guild master opened a castle siege npc to manage the castle.
    /// Causes reaction on server side: The server returns the tax information.
    /// </remarks>
    public static async ValueTask SendCastleSiegeTaxInfoRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeTaxInfoRequestRef.Length;
            var packet = new CastleSiegeTaxInfoRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeTaxChangeRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="taxType">0=Undefined, 1=ChaosMachine, 2 = Normal, 3 = EntranceFeeLandOfTrials</param>
    /// <param name="taxRate">The tax rate.</param>
    /// <remarks>
    /// Is sent by the client when: The guild master wants to change the tax rate in the castle npc.
    /// Causes reaction on server side: The server changes the tax rates accordingly.
    /// </remarks>
    public static async ValueTask SendCastleSiegeTaxChangeRequestAsync(this IConnection? connection, byte @taxType, uint @taxRate)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeTaxChangeRequestRef.Length;
            var packet = new CastleSiegeTaxChangeRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.TaxType = @taxType;
            packet.TaxRate = @taxRate;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeTaxMoneyWithdraw" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="amount">The amount.</param>
    /// <remarks>
    /// Is sent by the client when: The guild master wants to withdraw the tax money from the castle npc.
    /// Causes reaction on server side: The server moves the money into the inventory of the guild master.
    /// </remarks>
    public static async ValueTask SendCastleSiegeTaxMoneyWithdrawAsync(this IConnection? connection, uint @amount)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeTaxMoneyWithdrawRef.Length;
            var packet = new CastleSiegeTaxMoneyWithdrawRef(connection.Output.GetSpan(length)[..length]);
            packet.Amount = @amount;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ToggleCastleGateRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="closeState">The close state.</param>
    /// <param name="gateId">The gate id.</param>
    /// <remarks>
    /// Is sent by the client when: The guild member of the castle owner wants to toggle the gate switch.
    /// Causes reaction on server side: The castle gate is getting opened or closed.
    /// </remarks>
    public static async ValueTask SendToggleCastleGateRequestAsync(this IConnection? connection, bool @closeState, ushort @gateId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ToggleCastleGateRequestRef.Length;
            var packet = new ToggleCastleGateRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.CloseState = @closeState;
            packet.GateId = @gateId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleGuildCommand" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="team">Team Number 0 to 7.</param>
    /// <param name="positionX">The position x.</param>
    /// <param name="positionY">The position y.</param>
    /// <param name="command">0 = Attack, 1 = Defend, 2 = Wait</param>
    /// <remarks>
    /// Is sent by the client when: The guild master sent a command to his guild during the castle siege event.
    /// Causes reaction on server side: The command is shown on the mini map of the guild members.
    /// </remarks>
    public static async ValueTask SendCastleGuildCommandAsync(this IConnection? connection, byte @team, byte @positionX, byte @positionY, byte @command)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleGuildCommandRef.Length;
            var packet = new CastleGuildCommandRef(connection.Output.GetSpan(length)[..length]);
            packet.Team = @team;
            packet.PositionX = @positionX;
            packet.PositionY = @positionY;
            packet.Command = @command;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeHuntingZoneEntranceSetting" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="isPublic">The is public.</param>
    /// <remarks>
    /// Is sent by the client when: A guild member of the castle owners wants to enter the hunting zone (e.g. Land of Trials).
    /// Causes reaction on server side: The server changes the entrance setting of the hunting zone.
    /// </remarks>
    public static async ValueTask SendCastleSiegeHuntingZoneEntranceSettingAsync(this IConnection? connection, bool @isPublic)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeHuntingZoneEntranceSettingRef.Length;
            var packet = new CastleSiegeHuntingZoneEntranceSettingRef(connection.Output.GetSpan(length)[..length]);
            packet.IsPublic = @isPublic;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeGateListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The guild master opened the castle npc and the client needs a list of all gates.
    /// Causes reaction on server side: The server returns the list of gates and their status.
    /// </remarks>
    public static async ValueTask SendCastleSiegeGateListRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeGateListRequestRef.Length;
            var packet = new CastleSiegeGateListRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeStatueListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The guild master opened the castle npc and the client needs a list of all statues.
    /// Causes reaction on server side: The server returns the list of statues and their status.
    /// </remarks>
    public static async ValueTask SendCastleSiegeStatueListRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeStatueListRequestRef.Length;
            var packet = new CastleSiegeStatueListRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeRegisteredGuildsListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The guild master opened an npc and needs the list of registered guilds for the next siege.
    /// Causes reaction on server side: The server returns the list of guilds for the next siege.
    /// </remarks>
    public static async ValueTask SendCastleSiegeRegisteredGuildsListRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeRegisteredGuildsListRequestRef.Length;
            var packet = new CastleSiegeRegisteredGuildsListRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleOwnerListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The guild master opened an npc and needs the list of current guilds which are the castle owners.
    /// Causes reaction on server side: The server returns the list of guilds which are the castle owners.
    /// </remarks>
    public static async ValueTask SendCastleOwnerListRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleOwnerListRequestRef.Length;
            var packet = new CastleOwnerListRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="FireCatapultRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="catapultId">The catapult id.</param>
    /// <param name="targetAreaIndex">The target area index.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to fire a catapult during the castle siege event.
    /// Causes reaction on server side: The server fires the catapult.
    /// </remarks>
    public static async ValueTask SendFireCatapultRequestAsync(this IConnection? connection, ushort @catapultId, byte @targetAreaIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = FireCatapultRequestRef.Length;
            var packet = new FireCatapultRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.CatapultId = @catapultId;
            packet.TargetAreaIndex = @targetAreaIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="WeaponExplosionRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="catapultId">The catapult id.</param>
    /// <remarks>
    /// Is sent by the client when: After the player fired a catapult and hit another catapult.
    /// Causes reaction on server side: The server damages the other catapult.
    /// </remarks>
    public static async ValueTask SendWeaponExplosionRequestAsync(this IConnection? connection, ushort @catapultId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = WeaponExplosionRequestRef.Length;
            var packet = new WeaponExplosionRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.CatapultId = @catapultId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildLogoOfCastleOwnerRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The client requests the guild logo of the current castle owner guild.
    /// Causes reaction on server side: The server returns the guild logo.
    /// </remarks>
    public static async ValueTask SendGuildLogoOfCastleOwnerRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildLogoOfCastleOwnerRequestRef.Length;
            var packet = new GuildLogoOfCastleOwnerRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CastleSiegeHuntingZoneEnterRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="money">The money.</param>
    /// <remarks>
    /// Is sent by the client when: A guild member of the castle owners wants to enter the hunting zone (e.g. Land of Trials).
    /// Causes reaction on server side: The server takes the entrance money, puts it into the tax wallet and warps the player to the hunting zone.
    /// </remarks>
    public static async ValueTask SendCastleSiegeHuntingZoneEnterRequestAsync(this IConnection? connection, uint @money)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CastleSiegeHuntingZoneEnterRequestRef.Length;
            var packet = new CastleSiegeHuntingZoneEnterRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.Money = @money;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CrywolfInfoRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: A player enters the crywolf map.
    /// Causes reaction on server side: The server returns data about the state of the crywolf map.
    /// </remarks>
    public static async ValueTask SendCrywolfInfoRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CrywolfInfoRequestRef.Length;
            var packet = new CrywolfInfoRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CrywolfContractRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="statueId">The statue id.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to make a contract at the crywolf statue for the crywolf event.
    /// Causes reaction on server side: The server tries to enter a contract with the player and the specified statue.
    /// </remarks>
    public static async ValueTask SendCrywolfContractRequestAsync(this IConnection? connection, ushort @statueId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CrywolfContractRequestRef.Length;
            var packet = new CrywolfContractRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.StatueId = @statueId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CrywolfChaosRateBenefitRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: A player opens an item crafting dialog, e.g. the chaos machine.
    /// Causes reaction on server side: The server returns data about the state of the benefit of the crywolf event. If it was won before, the chaos rate wents up a few percent.
    /// </remarks>
    public static async ValueTask SendCrywolfChaosRateBenefitRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CrywolfChaosRateBenefitRequestRef.Length;
            var packet = new CrywolfChaosRateBenefitRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="WhiteAngelItemRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: ?.
    /// Causes reaction on server side: ?.
    /// </remarks>
    public static async ValueTask SendWhiteAngelItemRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = WhiteAngelItemRequestRef.Length;
            var packet = new WhiteAngelItemRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="EnterOnWerewolfRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: A player is running the quest "Infiltrate The Barracks of Balgass" (nr. 5), talking to the Werewolf npc in Crywolf.
    /// Causes reaction on server side: It will warp the player to the map 'Barracks of Balgass' where the required monsters have to be killed to proceed with the quest.
    /// </remarks>
    public static async ValueTask SendEnterOnWerewolfRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = EnterOnWerewolfRequestRef.Length;
            var packet = new EnterOnWerewolfRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="EnterOnGatekeeperRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: A player is running the quest "Into the 'Darkness' Zone" (nr. 6), talking to the gatekeeper npc in 'Barracks of Balgass'.
    /// Causes reaction on server side: It will warp the player to the map 'Balgass Refuge' where the required monsters have to be killed to proceed with the quest.
    /// </remarks>
    public static async ValueTask SendEnterOnGatekeeperRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = EnterOnGatekeeperRequestRef.Length;
            var packet = new EnterOnGatekeeperRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LeoHelperItemRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player talks to the npc "Leo the Helper" and requests an item.
    /// Causes reaction on server side: The item will drop on the ground.
    /// </remarks>
    public static async ValueTask SendLeoHelperItemRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LeoHelperItemRequestRef.Length;
            var packet = new LeoHelperItemRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MoveToDeviasBySnowmanRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player talks to the npc "Snowman" in Santa Village and requests to warp back to devias.
    /// Causes reaction on server side: The player will be warped back to Devias.
    /// </remarks>
    public static async ValueTask SendMoveToDeviasBySnowmanRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MoveToDeviasBySnowmanRequestRef.Length;
            var packet = new MoveToDeviasBySnowmanRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SantaClausItemRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player talks to the npc "Santa Claus" and requests an item.
    /// Causes reaction on server side: The item will drop on the ground.
    /// </remarks>
    public static async ValueTask SendSantaClausItemRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SantaClausItemRequestRef.Length;
            var packet = new SantaClausItemRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="KanturuInfoRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: A player talks with the kanturu entrance npc, and shows the enter dialog.
    /// Causes reaction on server side: The server returns data about the state of the kanturu event map.
    /// </remarks>
    public static async ValueTask SendKanturuInfoRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = KanturuInfoRequestRef.Length;
            var packet = new KanturuInfoRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="KanturuEnterRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: A player requests to enter the kanturu event map.
    /// Causes reaction on server side: The server checks, if entrance is possible and acts accordingly.
    /// </remarks>
    public static async ValueTask SendKanturuEnterRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = KanturuEnterRequestRef.Length;
            var packet = new KanturuEnterRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RaklionStateInfoRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: ?
    /// Causes reaction on server side: ?
    /// </remarks>
    public static async ValueTask SendRaklionStateInfoRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RaklionStateInfoRequestRef.Length;
            var packet = new RaklionStateInfoRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CashShopPointInfoRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The client needs information about how many cash shop points (WCoinC, WCoinP, GoblinPoints) are available to the player.
    /// Causes reaction on server side: The server returns the cash shop points information.
    /// </remarks>
    public static async ValueTask SendCashShopPointInfoRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CashShopPointInfoRequestRef.Length;
            var packet = new CashShopPointInfoRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CashShopOpenState" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="isClosed">The is closed.</param>
    /// <remarks>
    /// Is sent by the client when: The player opens or closes the cash shop dialog.
    /// Causes reaction on server side: In case of opening, the server returns if the cash shop is available. If the player is in the safezone, it's not.
    /// </remarks>
    public static async ValueTask SendCashShopOpenStateAsync(this IConnection? connection, bool @isClosed)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CashShopOpenStateRef.Length;
            var packet = new CashShopOpenStateRef(connection.Output.GetSpan(length)[..length]);
            packet.IsClosed = @isClosed;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CashShopItemBuyRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="packageMainIndex">The package main index.</param>
    /// <param name="category">The category.</param>
    /// <param name="productMainIndex">The product main index.</param>
    /// <param name="itemIndex">The item index.</param>
    /// <param name="coinIndex">The coin index.</param>
    /// <param name="mileageFlag">The mileage flag.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to buy an item in the cash shop.
    /// Causes reaction on server side: The item is bought and added to the cash shop item storage of the player.
    /// </remarks>
    public static async ValueTask SendCashShopItemBuyRequestAsync(this IConnection? connection, uint @packageMainIndex, uint @category, uint @productMainIndex, ushort @itemIndex, uint @coinIndex, byte @mileageFlag)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CashShopItemBuyRequestRef.Length;
            var packet = new CashShopItemBuyRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.PackageMainIndex = @packageMainIndex;
            packet.Category = @category;
            packet.ProductMainIndex = @productMainIndex;
            packet.ItemIndex = @itemIndex;
            packet.CoinIndex = @coinIndex;
            packet.MileageFlag = @mileageFlag;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CashShopItemGiftRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="packageMainIndex">The package main index.</param>
    /// <param name="category">The category.</param>
    /// <param name="productMainIndex">The product main index.</param>
    /// <param name="itemIndex">The item index.</param>
    /// <param name="coinIndex">The coin index.</param>
    /// <param name="mileageFlag">The mileage flag.</param>
    /// <param name="giftReceiverName">The gift receiver name.</param>
    /// <param name="giftText">The gift text.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to send a gift to another player.
    /// Causes reaction on server side: The server buys the item with the credits of the player and sends it as gift to the other player.
    /// </remarks>
    public static async ValueTask SendCashShopItemGiftRequestAsync(this IConnection? connection, uint @packageMainIndex, uint @category, uint @productMainIndex, ushort @itemIndex, uint @coinIndex, byte @mileageFlag, string @giftReceiverName, string @giftText)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CashShopItemGiftRequestRef.Length;
            var packet = new CashShopItemGiftRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.PackageMainIndex = @packageMainIndex;
            packet.Category = @category;
            packet.ProductMainIndex = @productMainIndex;
            packet.ItemIndex = @itemIndex;
            packet.CoinIndex = @coinIndex;
            packet.MileageFlag = @mileageFlag;
            packet.GiftReceiverName = @giftReceiverName;
            packet.GiftText = @giftText;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CashShopStorageListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="pageIndex">The page index.</param>
    /// <param name="inventoryType">The inventory type.</param>
    /// <remarks>
    /// Is sent by the client when: The player opened the cash shop dialog or used paging of the storage.
    /// Causes reaction on server side: In case of opening, the server returns if the cash shop is available. If the player is in the safezone, it's not.
    /// </remarks>
    public static async ValueTask SendCashShopStorageListRequestAsync(this IConnection? connection, uint @pageIndex, byte @inventoryType)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CashShopStorageListRequestRef.Length;
            var packet = new CashShopStorageListRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.PageIndex = @pageIndex;
            packet.InventoryType = @inventoryType;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CashShopDeleteStorageItemRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="baseItemCode">The base item code.</param>
    /// <param name="mainItemCode">The main item code.</param>
    /// <param name="productType">The product type.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to delete an item of the cash shop storage.
    /// Causes reaction on server side: The server removes the item from cash shop storage.
    /// </remarks>
    public static async ValueTask SendCashShopDeleteStorageItemRequestAsync(this IConnection? connection, uint @baseItemCode, uint @mainItemCode, byte @productType)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CashShopDeleteStorageItemRequestRef.Length;
            var packet = new CashShopDeleteStorageItemRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.BaseItemCode = @baseItemCode;
            packet.MainItemCode = @mainItemCode;
            packet.ProductType = @productType;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CashShopStorageItemConsumeRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="baseItemCode">The base item code.</param>
    /// <param name="mainItemCode">The main item code.</param>
    /// <param name="itemIndex">The item index.</param>
    /// <param name="productType">The product type.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to get or consume an item which is in the cash shop storage.
    /// Causes reaction on server side: The item is applied or added to the inventory.
    /// </remarks>
    public static async ValueTask SendCashShopStorageItemConsumeRequestAsync(this IConnection? connection, uint @baseItemCode, uint @mainItemCode, ushort @itemIndex, byte @productType)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CashShopStorageItemConsumeRequestRef.Length;
            var packet = new CashShopStorageItemConsumeRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.BaseItemCode = @baseItemCode;
            packet.MainItemCode = @mainItemCode;
            packet.ItemIndex = @itemIndex;
            packet.ProductType = @productType;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CashShopEventItemListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="categoryIndex">The category index.</param>
    /// <remarks>
    /// Is sent by the client when: When the player wants to see through the event item list.
    /// Causes reaction on server side: The server sends a list with event items back.
    /// </remarks>
    public static async ValueTask SendCashShopEventItemListRequestAsync(this IConnection? connection, uint @categoryIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CashShopEventItemListRequestRef.Length;
            var packet = new CashShopEventItemListRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.CategoryIndex = @categoryIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="UnlockVault" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="pin">The pin.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to unlock the protected vault with a pin.
    /// Causes reaction on server side: The vault lock state on the server is updated. VaultProtectionInformation is sent as response.
    /// </remarks>
    public static async ValueTask SendUnlockVaultAsync(this IConnection? connection, ushort @pin)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = UnlockVaultRef.Length;
            var packet = new UnlockVaultRef(connection.Output.GetSpan(length)[..length]);
            packet.Pin = @pin;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SetVaultPin" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="pin">The pin.</param>
    /// <param name="password">The password of the account, which is required to set a new vault pin.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to set a new pin for the vault when it's in unlocked state.
    /// Causes reaction on server side: The vault pin is set. VaultProtectionInformation is sent as response.
    /// </remarks>
    public static async ValueTask SendSetVaultPinAsync(this IConnection? connection, ushort @pin, string @password)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SetVaultPinRef.Length;
            var packet = new SetVaultPinRef(connection.Output.GetSpan(length)[..length]);
            packet.Pin = @pin;
            packet.Password = @password;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RemoveVaultPin" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="password">The password of the account, which is required to remove the vault pin.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to remove the pin for the vault when it's in unlocked state.
    /// Causes reaction on server side: The vault pin is removed. VaultProtectionInformation is sent as response.
    /// </remarks>
    public static async ValueTask SendRemoveVaultPinAsync(this IConnection? connection, string @password)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RemoveVaultPinRef.Length;
            var packet = new RemoveVaultPinRef(connection.Output.GetSpan(length)[..length]);
            packet.Password = @password;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="VaultClosed" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player closed an opened vault dialog.
    /// Causes reaction on server side: The state on the server is updated.
    /// </remarks>
    public static async ValueTask SendVaultClosedAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = VaultClosedRef.Length;
            var packet = new VaultClosedRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="VaultMoveMoneyRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="direction">The direction.</param>
    /// <param name="amount">The amount.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to move money from or to the vault storage.
    /// Causes reaction on server side: The money is moved, if possible.
    /// </remarks>
    public static async ValueTask SendVaultMoveMoneyRequestAsync(this IConnection? connection, VaultMoveMoneyRequest.VaultMoneyMoveDirection @direction, uint @amount)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = VaultMoveMoneyRequestRef.Length;
            var packet = new VaultMoveMoneyRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.Direction = @direction;
            packet.Amount = @amount;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LahapJewelMixRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="operation">The operation.</param>
    /// <param name="item">The item.</param>
    /// <param name="mixingStackSize">The mixing stack size.</param>
    /// <param name="unmixingSourceSlot">The unmixing source slot.</param>
    /// <remarks>
    /// Is sent by the client when: When a player has the Lahap npc dialog open and wants to combine or disband jewel stacks.
    /// Causes reaction on server side: If successful, the inventory is updated and the game client gets corresponding responses.
    /// </remarks>
    public static async ValueTask SendLahapJewelMixRequestAsync(this IConnection? connection, LahapJewelMixRequest.MixType @operation, LahapJewelMixRequest.ItemType @item, LahapJewelMixRequest.StackSize @mixingStackSize, byte @unmixingSourceSlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LahapJewelMixRequestRef.Length;
            var packet = new LahapJewelMixRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.Operation = @operation;
            packet.Item = @item;
            packet.MixingStackSize = @mixingStackSize;
            packet.UnmixingSourceSlot = @unmixingSourceSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PartyListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: When the player opens the party menu in the game client.
    /// Causes reaction on server side: If the player is in a party, the server sends back a list with information about all players of the party.
    /// </remarks>
    public static async ValueTask SendPartyListRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PartyListRequestRef.Length;
            var packet = new PartyListRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PartyPlayerKickRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerIndex">The player index.</param>
    /// <remarks>
    /// Is sent by the client when: A party master wants to kick another player from his party, or when a player wants to kick himself from his party.
    /// Causes reaction on server side: If the sending player is the party master, or the player wants to kick himself, the target player is removed from the party.
    /// </remarks>
    public static async ValueTask SendPartyPlayerKickRequestAsync(this IConnection? connection, byte @playerIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PartyPlayerKickRequestRef.Length;
            var packet = new PartyPlayerKickRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.PlayerIndex = @playerIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PartyInviteRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="targetPlayerId">The target player id.</param>
    /// <remarks>
    /// Is sent by the client when: A party master wants to invite another player to his party.
    /// Causes reaction on server side: If the requesting player has no party, or is the party master, a request is sent to the target player.
    /// </remarks>
    public static async ValueTask SendPartyInviteRequestAsync(this IConnection? connection, ushort @targetPlayerId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PartyInviteRequestRef.Length;
            var packet = new PartyInviteRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.TargetPlayerId = @targetPlayerId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PartyInviteResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="accepted">The accepted.</param>
    /// <param name="requesterId">The requester id.</param>
    /// <remarks>
    /// Is sent by the client when: A player was invited by another player to join a party and this player sent the response back.
    /// Causes reaction on server side: If the sender accepts the request, it's added to the party.
    /// </remarks>
    public static async ValueTask SendPartyInviteResponseAsync(this IConnection? connection, bool @accepted, ushort @requesterId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PartyInviteResponseRef.Length;
            var packet = new PartyInviteResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Accepted = @accepted;
            packet.RequesterId = @requesterId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="WalkRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="sourceX">The source x.</param>
    /// <param name="sourceY">The source y.</param>
    /// <param name="stepCount">The step count.</param>
    /// <param name="targetRotation">The target rotation.</param>
    /// <param name="directions">The directions of the walking path. The target is calculated by taking the source coordinates and applying the directions to it.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to walk on the game map.
    /// Causes reaction on server side: The player gets moved on the map, visible for other surrounding players.
    /// </remarks>
    public static async ValueTask SendWalkRequestAsync(this IConnection? connection, byte @sourceX, byte @sourceY, byte @stepCount, byte @targetRotation, Memory<byte> @directions)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = WalkRequestRef.GetRequiredSize(directions.Length);
            var packet = new WalkRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.SourceX = @sourceX;
            packet.SourceY = @sourceY;
            packet.StepCount = @stepCount;
            packet.TargetRotation = @targetRotation;
            @directions.Span.CopyTo(packet.Directions);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="WalkRequest075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="sourceX">The source x.</param>
    /// <param name="sourceY">The source y.</param>
    /// <param name="stepCount">The step count.</param>
    /// <param name="targetRotation">The target rotation.</param>
    /// <param name="directions">The directions of the walking path. The target is calculated by taking the source coordinates and applying the directions to it.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to walk on the game map.
    /// Causes reaction on server side: The player gets moved on the map, visible for other surrounding players.
    /// </remarks>
    public static async ValueTask SendWalkRequest075Async(this IConnection? connection, byte @sourceX, byte @sourceY, byte @stepCount, byte @targetRotation, Memory<byte> @directions)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = WalkRequest075Ref.GetRequiredSize(directions.Length);
            var packet = new WalkRequest075Ref(connection.Output.GetSpan(length)[..length]);
            packet.SourceX = @sourceX;
            packet.SourceY = @sourceY;
            packet.StepCount = @stepCount;
            packet.TargetRotation = @targetRotation;
            @directions.Span.CopyTo(packet.Directions);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="InstantMoveRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="targetX">The target x.</param>
    /// <param name="targetY">The target y.</param>
    /// <remarks>
    /// Is sent by the client when: It's sent when the player performs specific skills.
    /// Causes reaction on server side: Usually, the player is moved instantly to the specified coordinates on the current map. In OpenMU, this request is not handled, because it allows hackers to "teleport" to any coordinates.
    /// </remarks>
    public static async ValueTask SendInstantMoveRequestAsync(this IConnection? connection, byte @targetX, byte @targetY)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = InstantMoveRequestRef.Length;
            var packet = new InstantMoveRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.TargetX = @targetX;
            packet.TargetY = @targetY;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="AnimationRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="rotation">The rotation.</param>
    /// <param name="animationNumber">The animation number.</param>
    /// <remarks>
    /// Is sent by the client when: A player does any kind of animation.
    /// Causes reaction on server side: The animation number and rotation is forwarded to all surrounding players.
    /// </remarks>
    public static async ValueTask SendAnimationRequestAsync(this IConnection? connection, byte @rotation, byte @animationNumber)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = AnimationRequestRef.Length;
            var packet = new AnimationRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.Rotation = @rotation;
            packet.AnimationNumber = @animationNumber;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RequestCharacterList" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="language">The language.</param>
    /// <remarks>
    /// Is sent by the client when: After a successful login or after the player decided to leave the game world to go back to the character selection screen.
    /// Causes reaction on server side: The server sends the character list with all available characters.
    /// </remarks>
    public static async ValueTask SendRequestCharacterListAsync(this IConnection? connection, byte @language)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RequestCharacterListRef.Length;
            var packet = new RequestCharacterListRef(connection.Output.GetSpan(length)[..length]);
            packet.Language = @language;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CreateCharacter" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="name">The name of the character which should be created.</param>
    /// <param name="class">The character class of the character which should be created.</param>
    /// <remarks>
    /// Is sent by the client when: The game client is at the character selection screen and the player requests to add a new character.
    /// Causes reaction on server side: The server checks if the player is allowed to create the character and sends a response back.
    /// </remarks>
    public static async ValueTask SendCreateCharacterAsync(this IConnection? connection, string @name, CharacterClassNumber @class)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CreateCharacterRef.Length;
            var packet = new CreateCharacterRef(connection.Output.GetSpan(length)[..length]);
            packet.Name = @name;
            packet.Class = @class;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DeleteCharacter" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="name">The name of the character which should be deleted.</param>
    /// <param name="securityCode">A security code (7 bytes long). Some game clients/servers also expect to transmit the account password (up to 20 bytes long) here. In OpenMU, we work with the security here, but are not limiting to a length of 7 bytes.</param>
    /// <remarks>
    /// Is sent by the client when: The game client is at the character selection screen and the player requests to delete an existing character.
    /// Causes reaction on server side: The server checks if the player transmitted the correct security code and if the character actually exists. If all is valid, it deletes the character from the account. It then sends a response with a result code back to the game client.
    /// </remarks>
    public static async ValueTask SendDeleteCharacterAsync(this IConnection? connection, string @name, string @securityCode)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DeleteCharacterRef.Length;
            var packet = new DeleteCharacterRef(connection.Output.GetSpan(length)[..length]);
            packet.Name = @name;
            packet.SecurityCode = @securityCode;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SelectCharacter" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="name">The name of the character with which the player wants to join the game world</param>
    /// <remarks>
    /// Is sent by the client when: The player selects a character to enter the game world on the character selection screen.
    /// Causes reaction on server side: The player joins the game world with the specified character.
    /// </remarks>
    public static async ValueTask SendSelectCharacterAsync(this IConnection? connection, string @name)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SelectCharacterRef.Length;
            var packet = new SelectCharacterRef(connection.Output.GetSpan(length)[..length]);
            packet.Name = @name;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="FocusCharacter" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="name">The name.</param>
    /// <remarks>
    /// Is sent by the client when: The player focuses (clicks on it) a character with which he plans to enter the game world on the character selection screen.
    /// Causes reaction on server side: The server checks if this character exists and sends a response back. If successful, the game client highlights the focused character.
    /// </remarks>
    public static async ValueTask SendFocusCharacterAsync(this IConnection? connection, string @name)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = FocusCharacterRef.Length;
            var packet = new FocusCharacterRef(connection.Output.GetSpan(length)[..length]);
            packet.Name = @name;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="IncreaseCharacterStatPoint" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="statType">The stat type.</param>
    /// <remarks>
    /// Is sent by the client when: The player decides to add a stat point to a specific stat type, by pressing a plus-button in the character info menu.
    /// Causes reaction on server side: The server checks if a level-up-point is available. If yes, it adds the point to the specified stat type. It sends a response back to the client.
    /// </remarks>
    public static async ValueTask SendIncreaseCharacterStatPointAsync(this IConnection? connection, CharacterStatAttribute @statType)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = IncreaseCharacterStatPointRef.Length;
            var packet = new IncreaseCharacterStatPointRef(connection.Output.GetSpan(length)[..length]);
            packet.StatType = @statType;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="InventoryRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player bought or sold an item through his personal shop.
    /// Causes reaction on server side: The server sends the inventory list back to the client.
    /// </remarks>
    public static async ValueTask SendInventoryRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = InventoryRequestRef.Length;
            var packet = new InventoryRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ClientReadyAfterMapChange" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: After the server sent a map change message and the client has initialized the game map visualization.
    /// Causes reaction on server side: The character is added to the internal game map and ready to interact with other entities.
    /// </remarks>
    public static async ValueTask SendClientReadyAfterMapChangeAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ClientReadyAfterMapChangeRef.Length;
            var packet = new ClientReadyAfterMapChangeRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SaveKeyConfiguration" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="configuration">The binary data of the key configuration</param>
    /// <remarks>
    /// Is sent by the client when: When leaving the game world with a character.
    /// Causes reaction on server side: The server saves this configuration in its database.
    /// </remarks>
    public static async ValueTask SendSaveKeyConfigurationAsync(this IConnection? connection, Memory<byte> @configuration)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SaveKeyConfigurationRef.GetRequiredSize(configuration.Length);
            var packet = new SaveKeyConfigurationRef(connection.Output.GetSpan(length)[..length]);
            @configuration.Span.CopyTo(packet.Configuration);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="AddMasterSkillPoint" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to add or increase the level of a specific master skill of the master skill tree.
    /// Causes reaction on server side: Adds or increases the master skill level of the specified skill, if the character is allowed to do that. A response is sent back to the client.
    /// </remarks>
    public static async ValueTask SendAddMasterSkillPointAsync(this IConnection? connection, ushort @skillId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = AddMasterSkillPointRef.Length;
            var packet = new AddMasterSkillPointRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="HitRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="targetId">The target id.</param>
    /// <param name="attackAnimation">The attack animation.</param>
    /// <param name="lookingDirection">The looking direction.</param>
    /// <remarks>
    /// Is sent by the client when: A player attacks a target without using a skill.
    /// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
    /// </remarks>
    public static async ValueTask SendHitRequestAsync(this IConnection? connection, ushort @targetId, byte @attackAnimation, byte @lookingDirection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = HitRequestRef.Length;
            var packet = new HitRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.TargetId = @targetId;
            packet.AttackAnimation = @attackAnimation;
            packet.LookingDirection = @lookingDirection;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TargetedSkill" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="targetId">The target id.</param>
    /// <remarks>
    /// Is sent by the client when: A player performs a skill with a target, e.g. attacking or buffing.
    /// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
    /// </remarks>
    public static async ValueTask SendTargetedSkillAsync(this IConnection? connection, ushort @skillId, ushort @targetId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TargetedSkillRef.Length;
            var packet = new TargetedSkillRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TargetedSkill075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillIndex">The index of the skill in the skill list.</param>
    /// <param name="targetId">The target id.</param>
    /// <remarks>
    /// Is sent by the client when: A player performs a skill with a target, e.g. attacking or buffing.
    /// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
    /// </remarks>
    public static async ValueTask SendTargetedSkill075Async(this IConnection? connection, byte @skillIndex, ushort @targetId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TargetedSkill075Ref.Length;
            var packet = new TargetedSkill075Ref(connection.Output.GetSpan(length)[..length]);
            packet.SkillIndex = @skillIndex;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TargetedSkill095" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillIndex">The index of the skill in the skill list.</param>
    /// <param name="targetId">The target id.</param>
    /// <remarks>
    /// Is sent by the client when: A player performs a skill with a target, e.g. attacking or buffing.
    /// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
    /// </remarks>
    public static async ValueTask SendTargetedSkill095Async(this IConnection? connection, byte @skillIndex, ushort @targetId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TargetedSkill095Ref.Length;
            var packet = new TargetedSkill095Ref(connection.Output.GetSpan(length)[..length]);
            packet.SkillIndex = @skillIndex;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MagicEffectCancelRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="playerId">The player id.</param>
    /// <remarks>
    /// Is sent by the client when: A player cancels a specific magic effect of a skill, usually 'Infinity Arrow' and 'Wizardy Enhance'.
    /// Causes reaction on server side: The effect is cancelled and an update is sent to the player and all surrounding players.
    /// </remarks>
    public static async ValueTask SendMagicEffectCancelRequestAsync(this IConnection? connection, ushort @skillId, ushort @playerId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MagicEffectCancelRequestRef.Length;
            var packet = new MagicEffectCancelRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.PlayerId = @playerId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="AreaSkill" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="targetX">The target x.</param>
    /// <param name="targetY">The target y.</param>
    /// <param name="rotation">The rotation.</param>
    /// <param name="extraTargetId">The extra target id.</param>
    /// <param name="animationCounter">Animation counter which acts as a reference to the previously sent Area Skill Animation packet.</param>
    /// <remarks>
    /// Is sent by the client when: A player is performing an skill which affects an area of the map.
    /// Causes reaction on server side: It's forwarded to all surrounding players, so that the animation is visible. In the original server implementation, no damage is done yet for attack skills - there are separate hit packets.
    /// </remarks>
    public static async ValueTask SendAreaSkillAsync(this IConnection? connection, ushort @skillId, byte @targetX, byte @targetY, byte @rotation, ushort @extraTargetId, byte @animationCounter)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = AreaSkillRef.Length;
            var packet = new AreaSkillRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.TargetX = @targetX;
            packet.TargetY = @targetY;
            packet.Rotation = @rotation;
            packet.ExtraTargetId = @extraTargetId;
            packet.AnimationCounter = @animationCounter;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="AreaSkill075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillIndex">The index of the skill in the skill list.</param>
    /// <param name="targetX">The target x.</param>
    /// <param name="targetY">The target y.</param>
    /// <param name="rotation">The rotation.</param>
    /// <remarks>
    /// Is sent by the client when: A player is performing an skill which affects an area of the map.
    /// Causes reaction on server side: It's forwarded to all surrounding players, so that the animation is visible. In the original server implementation, no damage is done yet for attack skills - there are separate hit packets.
    /// </remarks>
    public static async ValueTask SendAreaSkill075Async(this IConnection? connection, byte @skillIndex, byte @targetX, byte @targetY, byte @rotation)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = AreaSkill075Ref.Length;
            var packet = new AreaSkill075Ref(connection.Output.GetSpan(length)[..length]);
            packet.SkillIndex = @skillIndex;
            packet.TargetX = @targetX;
            packet.TargetY = @targetY;
            packet.Rotation = @rotation;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="AreaSkill095" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillIndex">The index of the skill in the skill list.</param>
    /// <param name="targetX">The target x.</param>
    /// <param name="targetY">The target y.</param>
    /// <param name="rotation">The rotation.</param>
    /// <remarks>
    /// Is sent by the client when: A player is performing an skill which affects an area of the map.
    /// Causes reaction on server side: It's forwarded to all surrounding players, so that the animation is visible. In the original server implementation, no damage is done yet for attack skills - there are separate hit packets.
    /// </remarks>
    public static async ValueTask SendAreaSkill095Async(this IConnection? connection, byte @skillIndex, byte @targetX, byte @targetY, byte @rotation)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = AreaSkill095Ref.Length;
            var packet = new AreaSkill095Ref(connection.Output.GetSpan(length)[..length]);
            packet.SkillIndex = @skillIndex;
            packet.TargetX = @targetX;
            packet.TargetY = @targetY;
            packet.Rotation = @rotation;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RageAttackRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="targetId">The target id.</param>
    /// <remarks>
    /// Is sent by the client when: A player performs a skill with a target, e.g. attacking or buffing.
    /// Causes reaction on server side: Damage is calculated and the target is hit, if the attack was successful. A response is sent back with the caused damage, and all surrounding players get an animation message.
    /// </remarks>
    public static async ValueTask SendRageAttackRequestAsync(this IConnection? connection, ushort @skillId, ushort @targetId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RageAttackRequestRef.Length;
            var packet = new RageAttackRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RageAttackRangeRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="targetId">The target id.</param>
    /// <remarks>
    /// Is sent by the client when: A player (rage fighter) performs the dark side skill on a target.
    /// Causes reaction on server side: The targets (up to 5) are determined and sent back to the player with the RageAttackRangeResponse.
    /// </remarks>
    public static async ValueTask SendRageAttackRangeRequestAsync(this IConnection? connection, ushort @skillId, ushort @targetId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RageAttackRangeRequestRef.Length;
            var packet = new RageAttackRangeRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TradeCancel" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to cancel the trade.
    /// Causes reaction on server side: The trade is cancelled and the previous inventory state is restored.
    /// </remarks>
    public static async ValueTask SendTradeCancelAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TradeCancelRef.Length;
            var packet = new TradeCancelRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TradeButtonStateChange" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="newState">The new state.</param>
    /// <remarks>
    /// Is sent by the client when: The player presses the trade button.
    /// Causes reaction on server side: The state change is forwarded to the trade partner. If both players press the trade button at the same time, the server will try to complete the trade by exchanging the items and money.
    /// </remarks>
    public static async ValueTask SendTradeButtonStateChangeAsync(this IConnection? connection, TradeButtonState @newState)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TradeButtonStateChangeRef.Length;
            var packet = new TradeButtonStateChangeRef(connection.Output.GetSpan(length)[..length]);
            packet.NewState = @newState;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TradeRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerId">The player id.</param>
    /// <remarks>
    /// Is sent by the client when: The player requests to open a trade with another player.
    /// Causes reaction on server side: The request is forwarded to the requested player.
    /// </remarks>
    public static async ValueTask SendTradeRequestAsync(this IConnection? connection, ushort @playerId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TradeRequestRef.Length;
            var packet = new TradeRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.PlayerId = @playerId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TradeRequestResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="tradeAccepted">The trade accepted.</param>
    /// <remarks>
    /// Is sent by the client when: A requested player responded to a trade request of another player.
    /// Causes reaction on server side: When the trade request was accepted, the server tries to open a new trade and sends corresponding responses to both players. 
    /// </remarks>
    public static async ValueTask SendTradeRequestResponseAsync(this IConnection? connection, bool @tradeAccepted)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TradeRequestResponseRef.Length;
            var packet = new TradeRequestResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.TradeAccepted = @tradeAccepted;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SetTradeMoney" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="amount">The amount.</param>
    /// <remarks>
    /// Is sent by the client when: A player requests to set an amount of money in the trade.
    /// Causes reaction on server side: It's taken from the available money of the inventory. If the new money amount is lower than the amount which was set before, it's added back to the inventory. The trade partner is informed about any change.
    /// </remarks>
    public static async ValueTask SendSetTradeMoneyAsync(this IConnection? connection, uint @amount)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SetTradeMoneyRef.Length;
            var packet = new SetTradeMoneyRef(connection.Output.GetSpan(length)[..length]);
            packet.Amount = @amount;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LetterDeleteRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="letterIndex">The letter index.</param>
    /// <remarks>
    /// Is sent by the client when: A player requests to delete a letter.
    /// Causes reaction on server side: The letter is getting deleted.
    /// </remarks>
    public static async ValueTask SendLetterDeleteRequestAsync(this IConnection? connection, ushort @letterIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LetterDeleteRequestRef.Length;
            var packet = new LetterDeleteRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.LetterIndex = @letterIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LetterListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The game client requests the current list of letters.
    /// Causes reaction on server side: The server sends the list of available letters to the client.
    /// </remarks>
    public static async ValueTask SendLetterListRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LetterListRequestRef.Length;
            var packet = new LetterListRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LetterSendRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="letterId">The letter id.</param>
    /// <param name="receiver">The receiver.</param>
    /// <param name="title">The title.</param>
    /// <param name="rotation">The rotation.</param>
    /// <param name="animation">The animation.</param>
    /// <param name="messageLength">The message length.</param>
    /// <param name="message">The message.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to send a letter to another players character.
    /// Causes reaction on server side: The letter is sent to the other character, if it exists and the player has the required money.
    /// </remarks>
    public static async ValueTask SendLetterSendRequestAsync(this IConnection? connection, uint @letterId, string @receiver, string @title, byte @rotation, byte @animation, ushort @messageLength, string @message)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LetterSendRequestRef.GetRequiredSize(message);
            var packet = new LetterSendRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.LetterId = @letterId;
            packet.Receiver = @receiver;
            packet.Title = @title;
            packet.Rotation = @rotation;
            packet.Animation = @animation;
            packet.MessageLength = @messageLength;
            packet.Message = @message;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LetterReadRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="letterIndex">The letter index.</param>
    /// <remarks>
    /// Is sent by the client when: A player requests to read a specific letter of his letter list.
    /// Causes reaction on server side: The server sends the requested letter content back to the game client.
    /// </remarks>
    public static async ValueTask SendLetterReadRequestAsync(this IConnection? connection, ushort @letterIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LetterReadRequestRef.Length;
            var packet = new LetterReadRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.LetterIndex = @letterIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildKickPlayerRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerName">The player name.</param>
    /// <param name="securityCode">The security code.</param>
    /// <remarks>
    /// Is sent by the client when: A guild member wants to kick himself or a guild master wants to kick another player from its guild.
    /// Causes reaction on server side: If the player is allowed to kick the player, it's removed from the guild. If the guild master kicks himself, the guild is disbanded. Corresponding responses are sent to all involved players.
    /// </remarks>
    public static async ValueTask SendGuildKickPlayerRequestAsync(this IConnection? connection, string @playerName, string @securityCode)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildKickPlayerRequestRef.GetRequiredSize(securityCode);
            var packet = new GuildKickPlayerRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.PlayerName = @playerName;
            packet.SecurityCode = @securityCode;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildJoinRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="guildMasterPlayerId">The guild master player id.</param>
    /// <remarks>
    /// Is sent by the client when: A player (non-guild member) requests to join a guild.
    /// Causes reaction on server side: The request is forwarded to the guild master. There can only be one request at a time. If the guild master already has an open request, a corresponding response is directly sent back to the requesting player.
    /// </remarks>
    public static async ValueTask SendGuildJoinRequestAsync(this IConnection? connection, ushort @guildMasterPlayerId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildJoinRequestRef.Length;
            var packet = new GuildJoinRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.GuildMasterPlayerId = @guildMasterPlayerId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildJoinResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="accepted">The accepted.</param>
    /// <param name="requesterId">The requester id.</param>
    /// <remarks>
    /// Is sent by the client when: A guild master responded to a previously sent request.
    /// Causes reaction on server side: If the request was accepted by the guild master, the previously requesting player is added to the guild.
    /// </remarks>
    public static async ValueTask SendGuildJoinResponseAsync(this IConnection? connection, bool @accepted, ushort @requesterId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildJoinResponseRef.Length;
            var packet = new GuildJoinResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Accepted = @accepted;
            packet.RequesterId = @requesterId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: A guild player opens its guild menu in the game client.
    /// Causes reaction on server side: A list of all guild members and their state is sent back as response.
    /// </remarks>
    public static async ValueTask SendGuildListRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildListRequestRef.Length;
            var packet = new GuildListRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildCreateRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="guildName">The guild name.</param>
    /// <param name="guildEmblem">The guild emblem in a custom bitmap format. It supports 16 colors (one transparent) per pixel and has a size of 8 * 8 pixel.</param>
    /// <remarks>
    /// Is sent by the client when: When a player wants to create a guild.
    /// Causes reaction on server side: The guild is created and the player is set as the new guild master of the guild.
    /// </remarks>
    public static async ValueTask SendGuildCreateRequestAsync(this IConnection? connection, string @guildName, Memory<byte> @guildEmblem)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildCreateRequestRef.Length;
            var packet = new GuildCreateRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.GuildName = @guildName;
            @guildEmblem.Span.CopyTo(packet.GuildEmblem);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildCreateRequest075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="guildName">The guild name.</param>
    /// <param name="guildEmblem">The guild emblem in a custom bitmap format. It supports 16 colors (one transparent) per pixel and has a size of 8 * 8 pixel.</param>
    /// <remarks>
    /// Is sent by the client when: When a player wants to create a guild.
    /// Causes reaction on server side: The guild is created and the player is set as the new guild master of the guild.
    /// </remarks>
    public static async ValueTask SendGuildCreateRequest075Async(this IConnection? connection, string @guildName, Memory<byte> @guildEmblem)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildCreateRequest075Ref.Length;
            var packet = new GuildCreateRequest075Ref(connection.Output.GetSpan(length)[..length]);
            packet.GuildName = @guildName;
            @guildEmblem.Span.CopyTo(packet.GuildEmblem);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildMasterAnswer" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="showCreationDialog">A value whether the guild creation dialog should be shown. Otherwise, the guild creation is cancelled and the dialog was closed.</param>
    /// <remarks>
    /// Is sent by the client when: The player has the dialog of the guild master NPC opened and decided about its next step.
    /// Causes reaction on server side: It either cancels the guild creation or proceeds with the guild creation dialog where the player can enter the guild name and symbol.
    /// </remarks>
    public static async ValueTask SendGuildMasterAnswerAsync(this IConnection? connection, bool @showCreationDialog)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildMasterAnswerRef.Length;
            var packet = new GuildMasterAnswerRef(connection.Output.GetSpan(length)[..length]);
            packet.ShowCreationDialog = @showCreationDialog;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CancelGuildCreation" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player has the dialog of the guild creation dialog opened and decided against creating a guild.
    /// Causes reaction on server side: It either cancels the guild creation.
    /// </remarks>
    public static async ValueTask SendCancelGuildCreationAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CancelGuildCreationRef.Length;
            var packet = new CancelGuildCreationRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildWarResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="accepted">The accepted.</param>
    /// <remarks>
    /// Is sent by the client when: A guild master requested a guild war against another guild.
    /// Causes reaction on server side: If the guild master confirms, the war is declared.
    /// </remarks>
    public static async ValueTask SendGuildWarResponseAsync(this IConnection? connection, bool @accepted)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildWarResponseRef.Length;
            var packet = new GuildWarResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Accepted = @accepted;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildInfoRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="guildId">The guild id.</param>
    /// <remarks>
    /// Is sent by the client when: A player gets another player into view range which is in a guild, and the guild identifier is unknown (=not cached yet by previous requests) to him.
    /// Causes reaction on server side: The server sends a response which includes the guild name and emblem.
    /// </remarks>
    public static async ValueTask SendGuildInfoRequestAsync(this IConnection? connection, uint @guildId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildInfoRequestRef.Length;
            var packet = new GuildInfoRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.GuildId = @guildId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildRoleAssignRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="role">The role.</param>
    /// <param name="playerName">The player name.</param>
    /// <param name="type">Unknown value between 1 and 3.</param>
    /// <remarks>
    /// Is sent by the client when: A guild master wants to change the role of a guild member.
    /// Causes reaction on server side: The server changes the role of the guild member.
    /// </remarks>
    public static async ValueTask SendGuildRoleAssignRequestAsync(this IConnection? connection, ServerToClient.GuildMemberRole @role, string @playerName, byte @type = 1)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildRoleAssignRequestRef.Length;
            var packet = new GuildRoleAssignRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.Type = @type;
            packet.Role = @role;
            packet.PlayerName = @playerName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildTypeChangeRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="guildType">0 = Common, 1 = Guard, FF = None.</param>
    /// <remarks>
    /// Is sent by the client when: A guild master wants to change the type of its guild. Didn't find any place in the client where this is sent.
    /// Causes reaction on server side: The server changes the kind of the guild. We assume it's whether the guild should be the main guild of an alliance, or not. Shouldn't be handled, because this is constant for the lifetime of an alliance.
    /// </remarks>
    public static async ValueTask SendGuildTypeChangeRequestAsync(this IConnection? connection, byte @guildType)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildTypeChangeRequestRef.Length;
            var packet = new GuildTypeChangeRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.GuildType = @guildType;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildRelationshipChangeRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="relationshipType">The relationship type.</param>
    /// <param name="requestType">The request type.</param>
    /// <param name="targetPlayerId">The target player id.</param>
    /// <remarks>
    /// Is sent by the client when: A guild master sends a request to another guild master about changing the relationship between their guilds.
    /// Causes reaction on server side: The server sends a response with the result.
    /// </remarks>
    public static async ValueTask SendGuildRelationshipChangeRequestAsync(this IConnection? connection, GuildRelationshipType @relationshipType, GuildRequestType @requestType, ushort @targetPlayerId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildRelationshipChangeRequestRef.Length;
            var packet = new GuildRelationshipChangeRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.RelationshipType = @relationshipType;
            packet.RequestType = @requestType;
            packet.TargetPlayerId = @targetPlayerId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildRelationshipChangeResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="relationshipType">The relationship type.</param>
    /// <param name="requestType">The request type.</param>
    /// <param name="response">The response.</param>
    /// <param name="targetPlayerId">The target player id.</param>
    /// <remarks>
    /// Is sent by the client when: A guild master answered the request to another guild master about changing the relationship between their guilds.
    /// Causes reaction on server side: The server sends a response back to the requester. If the guild master agreed, it takes the necessary actions.
    /// </remarks>
    public static async ValueTask SendGuildRelationshipChangeResponseAsync(this IConnection? connection, GuildRelationshipType @relationshipType, GuildRequestType @requestType, bool @response, ushort @targetPlayerId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildRelationshipChangeResponseRef.Length;
            var packet = new GuildRelationshipChangeResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.RelationshipType = @relationshipType;
            packet.RequestType = @requestType;
            packet.Response = @response;
            packet.TargetPlayerId = @targetPlayerId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RequestAllianceList" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player opens the alliance list dialog.
    /// Causes reaction on server side: The server answers with the list of the guilds of the alliance.
    /// </remarks>
    public static async ValueTask SendRequestAllianceListAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RequestAllianceListRef.Length;
            var packet = new RequestAllianceListRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RemoveAllianceGuildRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="guildName">The guild name.</param>
    /// <remarks>
    /// Is sent by the client when: An alliance guild master wants to remove a guild from the alliance.
    /// Causes reaction on server side: The server removes the guild from the alliance.
    /// </remarks>
    public static async ValueTask SendRemoveAllianceGuildRequestAsync(this IConnection? connection, string @guildName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RemoveAllianceGuildRequestRef.Length;
            var packet = new RemoveAllianceGuildRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.GuildName = @guildName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PingResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: After the server sent a ping request.
    /// Causes reaction on server side: The server knows the latency between server and client.
    /// </remarks>
    public static async ValueTask SendPingResponseAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PingResponseRef.Length;
            var packet = new PingResponseRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ItemRepair" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="inventoryItemSlot">The inventory slot of the target item. If it's 0xFF, the player requests to repair all items with the help of an NPC. If it's 8 (Pet slot), using the pet trainer NPC is mandatory, too.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to repair an item of his inventory, either himself or with the usage of an NPC.
    /// Causes reaction on server side: If the item is damaged and repairable, the durability of the item is maximized and corresponding responses are sent back to the client.
    /// </remarks>
    public static async ValueTask SendItemRepairAsync(this IConnection? connection, byte @inventoryItemSlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ItemRepairRef.Length;
            var packet = new ItemRepairRef(connection.Output.GetSpan(length)[..length]);
            packet.InventoryItemSlot = @inventoryItemSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ChaosMachineMixRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="mixType">The identifier which tells the server which kind of mix should be executed.</param>
    /// <param name="socketSlot">The 0-based slot index of the socket at which a seed sphere should be mounted or removed. May only be available for the corresponding mixes, so access with care.</param>
    /// <remarks>
    /// Is sent by the client when: The player has the dialog of the chaos machine open and decided to mix (craft) the items which he put into the chaos machine dialog.
    /// Causes reaction on server side: Based on the type of mix and it's corresponding success rate, the mix succeeds or fails. The client gets a corresponding response with the created, changed or lost items.
    /// </remarks>
    public static async ValueTask SendChaosMachineMixRequestAsync(this IConnection? connection, ChaosMachineMixRequest.ChaosMachineMixType @mixType, byte @socketSlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ChaosMachineMixRequestRef.Length;
            var packet = new ChaosMachineMixRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.MixType = @mixType;
            packet.SocketSlot = @socketSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CraftingDialogCloseRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: A player closes the dialog which was opened by an interaction with the chaos machine goblin.
    /// Causes reaction on server side: The server updates the state of the player accordingly.
    /// </remarks>
    public static async ValueTask SendCraftingDialogCloseRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CraftingDialogCloseRequestRef.Length;
            var packet = new CraftingDialogCloseRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="FriendListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The client requests the current friend list.
    /// Causes reaction on server side: The server sends the friend list to the client.
    /// </remarks>
    public static async ValueTask SendFriendListRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = FriendListRequestRef.Length;
            var packet = new FriendListRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="FriendAddRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="friendName">The friend name.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to add another players character into his friend list of the messenger.
    /// Causes reaction on server side: A request is sent to the other player. If the player is currently offline, the request will be sent as soon as he is online again.
    /// </remarks>
    public static async ValueTask SendFriendAddRequestAsync(this IConnection? connection, string @friendName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = FriendAddRequestRef.Length;
            var packet = new FriendAddRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.FriendName = @friendName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="FriendDelete" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="friendName">The friend name.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to delete another players character from his friend list of the messenger.
    /// Causes reaction on server side: The entry in the friend list is removed. The player is shown as offline in the other players friends list.
    /// </remarks>
    public static async ValueTask SendFriendDeleteAsync(this IConnection? connection, string @friendName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = FriendDeleteRef.Length;
            var packet = new FriendDeleteRef(connection.Output.GetSpan(length)[..length]);
            packet.FriendName = @friendName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ChatRoomCreateRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="friendName">The friend name.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to open a chat with another player of his friend list.
    /// Causes reaction on server side: If both players are online, a chat room is created on the chat server. Authentication data is sent to both game clients, which will then try to connect to the chat server using this data.
    /// </remarks>
    public static async ValueTask SendChatRoomCreateRequestAsync(this IConnection? connection, string @friendName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ChatRoomCreateRequestRef.Length;
            var packet = new ChatRoomCreateRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.FriendName = @friendName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="FriendAddResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="accepted">The accepted.</param>
    /// <param name="friendRequesterName">The friend requester name.</param>
    /// <remarks>
    /// Is sent by the client when: A player received a friend request from another player and responded to it.
    /// Causes reaction on server side: If the player accepted, the friend is added to the players friend list and both players get subscribed about each others online status.
    /// </remarks>
    public static async ValueTask SendFriendAddResponseAsync(this IConnection? connection, bool @accepted, string @friendRequesterName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = FriendAddResponseRef.Length;
            var packet = new FriendAddResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Accepted = @accepted;
            packet.FriendRequesterName = @friendRequesterName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SetFriendOnlineState" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="onlineState">The online state.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to set himself on- or offline.
    /// Causes reaction on server side: Depending on the state, the player is shown as offline or online in all friend lists of his friends.
    /// </remarks>
    public static async ValueTask SendSetFriendOnlineStateAsync(this IConnection? connection, bool @onlineState)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SetFriendOnlineStateRef.Length;
            var packet = new SetFriendOnlineStateRef(connection.Output.GetSpan(length)[..length]);
            packet.OnlineState = @onlineState;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ChatRoomInvitationRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="friendName">The friend name.</param>
    /// <param name="roomId">The room id.</param>
    /// <param name="requestId">The request id.</param>
    /// <remarks>
    /// Is sent by the client when: A player wants to invite additional players from his friend list to an existing chat room.
    /// Causes reaction on server side: The player additional gets authentication data sent to his game client. It then connects to the chat server and joins the chat room.
    /// </remarks>
    public static async ValueTask SendChatRoomInvitationRequestAsync(this IConnection? connection, string @friendName, ushort @roomId, uint @requestId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ChatRoomInvitationRequestRef.Length;
            var packet = new ChatRoomInvitationRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.FriendName = @friendName;
            packet.RoomId = @roomId;
            packet.RequestId = @requestId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LegacyQuestStateRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: After the player entered the game world with a character.
    /// Causes reaction on server side: The quest state is sent back as response.
    /// </remarks>
    public static async ValueTask SendLegacyQuestStateRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LegacyQuestStateRequestRef.Length;
            var packet = new LegacyQuestStateRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LegacyQuestStateSetRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="questNumber">The quest number.</param>
    /// <param name="newState">The new state.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to change the state of a quest, e.g. to start or to finish a quest.
    /// Causes reaction on server side: Depending on the requested new state, a response is sent back.
    /// </remarks>
    public static async ValueTask SendLegacyQuestStateSetRequestAsync(this IConnection? connection, byte @questNumber, LegacyQuestState @newState)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LegacyQuestStateSetRequestRef.Length;
            var packet = new LegacyQuestStateSetRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.QuestNumber = @questNumber;
            packet.NewState = @newState;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PetCommandRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="petType">The pet type.</param>
    /// <param name="commandMode">The command mode.</param>
    /// <param name="targetId">The target id.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to command its equipped pet (raven).
    /// Causes reaction on server side: 
    /// </remarks>
    public static async ValueTask SendPetCommandRequestAsync(this IConnection? connection, PetType @petType, PetCommandMode @commandMode, ushort @targetId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PetCommandRequestRef.Length;
            var packet = new PetCommandRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.PetType = @petType;
            packet.CommandMode = @commandMode;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PetInfoRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="pet">The pet.</param>
    /// <param name="storage">The storage.</param>
    /// <param name="itemSlot">The item slot.</param>
    /// <remarks>
    /// Is sent by the client when: The player hovers over a pet. The client sends this request to retrieve information (level, experience) of the pet (dark raven, horse).
    /// Causes reaction on server side: The server sends a PetInfoResponse.
    /// </remarks>
    public static async ValueTask SendPetInfoRequestAsync(this IConnection? connection, PetType @pet, StorageType @storage, byte @itemSlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PetInfoRequestRef.Length;
            var packet = new PetInfoRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.Pet = @pet;
            packet.Storage = @storage;
            packet.ItemSlot = @itemSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="IllusionTempleEnterRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="mapNumber">The map number.</param>
    /// <param name="itemSlot">The item slot.</param>
    /// <remarks>
    /// Is sent by the client when: The client has the NPC dialog for the illusion temple opened, and wants to enter the event map.
    /// Causes reaction on server side: The server checks if the player has the required ticket and moves the player to the event map.
    /// </remarks>
    public static async ValueTask SendIllusionTempleEnterRequestAsync(this IConnection? connection, byte @mapNumber, byte @itemSlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = IllusionTempleEnterRequestRef.Length;
            var packet = new IllusionTempleEnterRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.MapNumber = @mapNumber;
            packet.ItemSlot = @itemSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="IllusionTempleSkillRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillNumber">The skill number.</param>
    /// <param name="targetObjectIndex">The target object index.</param>
    /// <param name="distance">The distance.</param>
    /// <remarks>
    /// Is sent by the client when: The player is in the illusion temple event and wants to perform a special skill (210 - 213), Order of Protection, Restraint, Tracking or Weaken.
    /// Causes reaction on server side: The server checks if the player is inside the event etc. and performs the skills accordingly.
    /// </remarks>
    public static async ValueTask SendIllusionTempleSkillRequestAsync(this IConnection? connection, ushort @skillNumber, byte @targetObjectIndex, byte @distance)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = IllusionTempleSkillRequestRef.Length;
            var packet = new IllusionTempleSkillRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillNumber = @skillNumber;
            packet.TargetObjectIndex = @targetObjectIndex;
            packet.Distance = @distance;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="IllusionTempleRewardRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player requests the reward of the event.
    /// Causes reaction on server side: The server checks if the player is in the winning game and returns a reward, usually as item drop.
    /// </remarks>
    public static async ValueTask SendIllusionTempleRewardRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = IllusionTempleRewardRequestRef.Length;
            var packet = new IllusionTempleRewardRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LuckyCoinCountRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player has the lucky coin dialog open and requests the current count of the registered coins.
    /// Causes reaction on server side: The server returns the count of the registered coins.
    /// </remarks>
    public static async ValueTask SendLuckyCoinCountRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LuckyCoinCountRequestRef.Length;
            var packet = new LuckyCoinCountRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LuckyCoinRegistrationRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player has the lucky coin dialog open and requests to register one lucky coin, which is in his inventory.
    /// Causes reaction on server side: The server returns the result of the registration increases the coin count and decreases the coin durability by one.
    /// </remarks>
    public static async ValueTask SendLuckyCoinRegistrationRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LuckyCoinRegistrationRequestRef.Length;
            var packet = new LuckyCoinRegistrationRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LuckyCoinExchangeRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="coinCount">The coin count.</param>
    /// <remarks>
    /// Is sent by the client when: The player has the lucky coin dialog open and requests an exchange for the specified number of registered coins.
    /// Causes reaction on server side: The server adds an item to the inventory of the character and sends a response with a result code.
    /// </remarks>
    public static async ValueTask SendLuckyCoinExchangeRequestAsync(this IConnection? connection, uint @coinCount)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LuckyCoinExchangeRequestRef.Length;
            var packet = new LuckyCoinExchangeRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.CoinCount = @coinCount;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DoppelgangerEnterRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="ticketItemSlot">The ticket item slot.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to enter the doppelganger event.
    /// Causes reaction on server side: The server checks the event ticket and moves the player to the event map.
    /// </remarks>
    public static async ValueTask SendDoppelgangerEnterRequestAsync(this IConnection? connection, byte @ticketItemSlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DoppelgangerEnterRequestRef.Length;
            var packet = new DoppelgangerEnterRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.TicketItemSlot = @ticketItemSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="EnterMarketPlaceRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to enter the market place map.
    /// Causes reaction on server side: The server moves the player to the market place map.
    /// </remarks>
    public static async ValueTask SendEnterMarketPlaceRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = EnterMarketPlaceRequestRef.Length;
            var packet = new EnterMarketPlaceRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MuHelperStatusChangeRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="pauseStatus">The pause status.</param>
    /// <remarks>
    /// Is sent by the client when: The client clicked on MU Helper play or pause button.
    /// Causes reaction on server side: The server validates, if user can use the helper and sends the status back.
    /// </remarks>
    public static async ValueTask SendMuHelperStatusChangeRequestAsync(this IConnection? connection, bool @pauseStatus)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MuHelperStatusChangeRequestRef.Length;
            var packet = new MuHelperStatusChangeRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.PauseStatus = @pauseStatus;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MuHelperSaveDataRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="helperData">The helper data.</param>
    /// <remarks>
    /// Is sent by the client when: The client want to save current MU Helper data.
    /// Causes reaction on server side: The server should save supplied MU Helper data.
    /// </remarks>
    public static async ValueTask SendMuHelperSaveDataRequestAsync(this IConnection? connection, Memory<byte> @helperData)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MuHelperSaveDataRequestRef.Length;
            var packet = new MuHelperSaveDataRequestRef(connection.Output.GetSpan(length)[..length]);
            @helperData.Span.CopyTo(packet.HelperData);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="QuestSelectRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="questNumber">The quest number.</param>
    /// <param name="questGroup">The quest group.</param>
    /// <param name="selectedTextIndex">A 1-based index of the selected index in the dialog. It's 0 when no text has been selected. It's not clear yet, when we need that.</param>
    /// <remarks>
    /// Is sent by the client when: The client opened an quest NPC dialog and selected an available quests.
    /// Causes reaction on server side: If the quest is already active, it responds with the QuestProgress. If the quest is inactive, the server decides if the character can start the quest and responds with a QuestStepInfo with the StartingNumber. A character can run up to 3 concurrent quests at a time.
    /// </remarks>
    public static async ValueTask SendQuestSelectRequestAsync(this IConnection? connection, ushort @questNumber, ushort @questGroup, byte @selectedTextIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = QuestSelectRequestRef.Length;
            var packet = new QuestSelectRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.QuestNumber = @questNumber;
            packet.QuestGroup = @questGroup;
            packet.SelectedTextIndex = @selectedTextIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="QuestProceedRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="questNumber">The quest number.</param>
    /// <param name="questGroup">The quest group.</param>
    /// <param name="proceedAction">The proceed action.</param>
    /// <remarks>
    /// Is sent by the client when: After the server started a quest (and sent a F60B message) the game client requests to proceed with the quest.
    /// Causes reaction on server side: The quest state is set accordingly on the server. The next response seems to depend on the quest configuration. Depending on the action of the next quest state, the server will send either a quest progress message (F60C) or again a quest start message (F60B).
    /// </remarks>
    public static async ValueTask SendQuestProceedRequestAsync(this IConnection? connection, ushort @questNumber, ushort @questGroup, QuestProceedRequest.QuestProceedAction @proceedAction)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = QuestProceedRequestRef.Length;
            var packet = new QuestProceedRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.QuestNumber = @questNumber;
            packet.QuestGroup = @questGroup;
            packet.ProceedAction = @proceedAction;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="QuestCompletionRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="questNumber">The quest number.</param>
    /// <param name="questGroup">The quest group.</param>
    /// <remarks>
    /// Is sent by the client when: The game client requests to complete an active quest.
    /// Causes reaction on server side: The server checks the conditions to complete the quest. If this fails, nothing happens. If all conditions are met, the reward is given to the player and the quest state is set accordingly, so that the player can select to start the next quest. Additionally, the quest completion response message (F60D) is sent to the client.
    /// </remarks>
    public static async ValueTask SendQuestCompletionRequestAsync(this IConnection? connection, ushort @questNumber, ushort @questGroup)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = QuestCompletionRequestRef.Length;
            var packet = new QuestCompletionRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.QuestNumber = @questNumber;
            packet.QuestGroup = @questGroup;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="QuestCancelRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="questNumber">The quest number.</param>
    /// <param name="questGroup">The quest group.</param>
    /// <remarks>
    /// Is sent by the client when: The game client requests to cancel an active quest.
    /// Causes reaction on server side: The server checks if the quest is currently in progress. In this case, the quest state is reset and a response (F60F) is sent back to the client.
    /// </remarks>
    public static async ValueTask SendQuestCancelRequestAsync(this IConnection? connection, ushort @questNumber, ushort @questGroup)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = QuestCancelRequestRef.Length;
            var packet = new QuestCancelRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.QuestNumber = @questNumber;
            packet.QuestGroup = @questGroup;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="QuestClientActionRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="questNumber">The quest number.</param>
    /// <param name="questGroup">The quest group.</param>
    /// <remarks>
    /// Is sent by the client when: The game client requests to complete a client action, e.g. completing a tutorial.
    /// Causes reaction on server side: The server checks if the specified quest is currently in progress. If the quest got a Condition (condition type 0x10) for this flag, the condition is flagged as fulfilled.
    /// </remarks>
    public static async ValueTask SendQuestClientActionRequestAsync(this IConnection? connection, ushort @questNumber, ushort @questGroup)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = QuestClientActionRequestRef.Length;
            var packet = new QuestClientActionRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.QuestNumber = @questNumber;
            packet.QuestGroup = @questGroup;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ActiveQuestListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The clients requests the states of all quests, usually after entering the game.
    /// Causes reaction on server side: The list of active quests is sent back (F61A) without changing any state. This list just contains all running or completed quests for each group.
    /// </remarks>
    public static async ValueTask SendActiveQuestListRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ActiveQuestListRequestRef.Length;
            var packet = new ActiveQuestListRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="QuestStateRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="questNumber">The quest number.</param>
    /// <param name="questGroup">The quest group.</param>
    /// <remarks>
    /// Is sent by the client when: The game client requests the state of a specific active quests.
    /// Causes reaction on server side: The quest state is sent back (F61B) without changing any state, if the quest is currently in progress.
    /// </remarks>
    public static async ValueTask SendQuestStateRequestAsync(this IConnection? connection, ushort @questNumber, ushort @questGroup)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = QuestStateRequestRef.Length;
            var packet = new QuestStateRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.QuestNumber = @questNumber;
            packet.QuestGroup = @questGroup;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="EventQuestStateListRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The game client requests the list of event quests, usually after entering the game.
    /// Causes reaction on server side: The server may answer with a response which seems to depend if the character is member of a Gen or not. If it's not in a gen, it sends a response (F603).
    /// </remarks>
    public static async ValueTask SendEventQuestStateListRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = EventQuestStateListRequestRef.Length;
            var packet = new EventQuestStateListRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="AvailableQuestsRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The client opened an quest NPC dialog and requests a list of available quests.
    /// Causes reaction on server side: The list of available quests of this NPC is sent back (F60A).
    /// </remarks>
    public static async ValueTask SendAvailableQuestsRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = AvailableQuestsRequestRef.Length;
            var packet = new AvailableQuestsRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="NpcBuffRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The game client requests to get a buff from the currently interacting quest npc. As far as we know, only the Elf Soldier NPC offers such a buff until a certain character level (150 or 220).
    /// Causes reaction on server side: The server should check if the correct Quest NPC (e.g. Elf Soldier) dialog is opened and the player didn't reach the level limit yet. If that's both the case, it adds a defined buff (MagicEffect) to the player; Otherwise, a message is sent to the player.
    /// </remarks>
    public static async ValueTask SendNpcBuffRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = NpcBuffRequestRef.Length;
            var packet = new NpcBuffRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="EnterEmpireGuardianEvent" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="itemSlot">The item slot of the event ticket. Not used by the server.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to enter the empire guardian event due an npc dialog.
    /// Causes reaction on server side: The checks if the player can enter the event, and moves it to the event, if possible.
    /// </remarks>
    public static async ValueTask SendEnterEmpireGuardianEventAsync(this IConnection? connection, byte @itemSlot = 01)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = EnterEmpireGuardianEventRef.Length;
            var packet = new EnterEmpireGuardianEventRef(connection.Output.GetSpan(length)[..length]);
            packet.ItemSlot = @itemSlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GensJoinRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="gensType">The gens type.</param>
    /// <remarks>
    /// Is sent by the client when: The player has opened one of the gens NPCs and requests to join it.
    /// Causes reaction on server side: The server checks if the player is not in a gens already and joins the player to the selected gens.
    /// </remarks>
    public static async ValueTask SendGensJoinRequestAsync(this IConnection? connection, GensType @gensType)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GensJoinRequestRef.Length;
            var packet = new GensJoinRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.GensType = @gensType;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GensLeaveRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player wants to leave the current gens.
    /// Causes reaction on server side: The server the player from the gens.
    /// </remarks>
    public static async ValueTask SendGensLeaveRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GensLeaveRequestRef.Length;
            var packet = new GensLeaveRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GensRewardRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="gensType">The gens type.</param>
    /// <remarks>
    /// Is sent by the client when: The game client requests to get a reward from the gens npc.
    /// Causes reaction on server side: The server checks if the player has enough points to get the reward, and sends a response.
    /// </remarks>
    public static async ValueTask SendGensRewardRequestAsync(this IConnection? connection, GensType @gensType)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GensRewardRequestRef.Length;
            var packet = new GensRewardRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.GensType = @gensType;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GensRankingRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The game client requests information about the current gens ranking.
    /// Causes reaction on server side: The server returns the current gens rankinginformation.
    /// </remarks>
    public static async ValueTask SendGensRankingRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GensRankingRequestRef.Length;
            var packet = new GensRankingRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DevilSquareEnterRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="squareLevel">The level of the devil square, minus 1.</param>
    /// <param name="ticketItemInventoryIndex">The index of the ticket item in the inventory. Be aware, that the value is 12 higher than it should be - it makes no sense, but it is what it is...</param>
    /// <remarks>
    /// Is sent by the client when: The player requests to enter the devil square through the Charon NPC.
    /// Causes reaction on server side: The server checks if the player can enter the event and sends a response (Code 0x90) back to the client. If it was successful, the character gets moved to the event map.
    /// </remarks>
    public static async ValueTask SendDevilSquareEnterRequestAsync(this IConnection? connection, byte @squareLevel, byte @ticketItemInventoryIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DevilSquareEnterRequestRef.Length;
            var packet = new DevilSquareEnterRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.SquareLevel = @squareLevel;
            packet.TicketItemInventoryIndex = @ticketItemInventoryIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MiniGameOpeningStateRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="eventType">The event type.</param>
    /// <param name="eventLevel">The event level.</param>
    /// <remarks>
    /// Is sent by the client when: The player requests to get the remaining time of the currently entered event.
    /// Causes reaction on server side: The remaining time is sent back to the client.
    /// </remarks>
    public static async ValueTask SendMiniGameOpeningStateRequestAsync(this IConnection? connection, MiniGameType @eventType, byte @eventLevel)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MiniGameOpeningStateRequestRef.Length;
            var packet = new MiniGameOpeningStateRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.EventType = @eventType;
            packet.EventLevel = @eventLevel;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="EventChipRegistrationRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="type">The type.</param>
    /// <param name="itemIndex">The item index.</param>
    /// <remarks>
    /// Is sent by the client when: The player registers an event item at an NPC, usually the golden archer.
    /// Causes reaction on server side: A response is sent back to the client with the current event chip count.
    /// </remarks>
    public static async ValueTask SendEventChipRegistrationRequestAsync(this IConnection? connection, byte @type, byte @itemIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = EventChipRegistrationRequestRef.Length;
            var packet = new EventChipRegistrationRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.Type = @type;
            packet.ItemIndex = @itemIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MutoNumberRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player requests information about the Muto number. Unused.
    /// Causes reaction on server side: A response is sent back to the client with the current Muto number.
    /// </remarks>
    public static async ValueTask SendMutoNumberRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MutoNumberRequestRef.Length;
            var packet = new MutoNumberRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="EventChipExitDialog" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: The player requests to close the event chip dialog.
    /// Causes reaction on server side: The event chip dialog will be closed.
    /// </remarks>
    public static async ValueTask SendEventChipExitDialogAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = EventChipExitDialogRef.Length;
            var packet = new EventChipExitDialogRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="EventChipExchangeRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="type">The type.</param>
    /// <remarks>
    /// Is sent by the client when: The player requests to exchange the event chips to something else.
    /// Causes reaction on server side: A response is sent back to the client with the exchange result.
    /// </remarks>
    public static async ValueTask SendEventChipExchangeRequestAsync(this IConnection? connection, byte @type)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = EventChipExchangeRequestRef.Length;
            var packet = new EventChipExchangeRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.Type = @type;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ServerImmigrationRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="securityCode">The security code.</param>
    /// <remarks>
    /// Is sent by the client when: Unknown?
    /// Causes reaction on server side: Unknown?
    /// </remarks>
    public static async ValueTask SendServerImmigrationRequestAsync(this IConnection? connection, string @securityCode)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ServerImmigrationRequestRef.GetRequiredSize(securityCode);
            var packet = new ServerImmigrationRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.SecurityCode = @securityCode;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LuckyNumberRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="serial1">The serial 1.</param>
    /// <param name="serial2">The serial 2.</param>
    /// <param name="serial3">The serial 3.</param>
    /// <remarks>
    /// Is sent by the client when: The player requests to redeem a coupon code (lucky number) which is 12 alphanumeric digits long.
    /// Causes reaction on server side: A response is sent back to the client with the result. An item could be rewarded to the inventory.
    /// </remarks>
    public static async ValueTask SendLuckyNumberRequestAsync(this IConnection? connection, string @serial1, string @serial2, string @serial3)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LuckyNumberRequestRef.Length;
            var packet = new LuckyNumberRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.Serial1 = @serial1;
            packet.Serial2 = @serial2;
            packet.Serial3 = @serial3;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="BloodCastleEnterRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="castleLevel">The level of the battle square.</param>
    /// <param name="ticketItemInventoryIndex">The index of the ticket item in the inventory. Be aware, that the value is 12 higher than it should be - it makes no sense, but it is what it is...</param>
    /// <remarks>
    /// Is sent by the client when: The player requests to enter the blood castle through the Archangel Messenger NPC.
    /// Causes reaction on server side: The server checks if the player can enter the event and sends a response (Code 0x9A) back to the client. If it was successful, the character gets moved to the event map.
    /// </remarks>
    public static async ValueTask SendBloodCastleEnterRequestAsync(this IConnection? connection, byte @castleLevel, byte @ticketItemInventoryIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = BloodCastleEnterRequestRef.Length;
            var packet = new BloodCastleEnterRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.CastleLevel = @castleLevel;
            packet.TicketItemInventoryIndex = @ticketItemInventoryIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MiniGameEventCountRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="miniGame">The mini game.</param>
    /// <remarks>
    /// Is sent by the client when: The player requests to get the entering count of the specified mini game.
    /// Causes reaction on server side: The remaining time is sent back to the client. However, it's not really handled on the known server sources.
    /// </remarks>
    public static async ValueTask SendMiniGameEventCountRequestAsync(this IConnection? connection, MiniGameType @miniGame)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MiniGameEventCountRequestRef.Length;
            var packet = new MiniGameEventCountRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.MiniGame = @miniGame;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ChaosCastleEnterRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="castleLevel">The level of the chaos castle. Appears to always be 0.</param>
    /// <param name="ticketItemInventoryIndex">The index of the ticket item in the inventory.</param>
    /// <remarks>
    /// Is sent by the client when: The player requests to enter the chaos castle by using the 'Armor of Guardsman' item.
    /// Causes reaction on server side: The server checks if the player can enter the event and sends a response (Code 0xAF) back to the client. If it was successful, the character gets moved to the event map.
    /// </remarks>
    public static async ValueTask SendChaosCastleEnterRequestAsync(this IConnection? connection, byte @castleLevel, byte @ticketItemInventoryIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ChaosCastleEnterRequestRef.Length;
            var packet = new ChaosCastleEnterRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.CastleLevel = @castleLevel;
            packet.TicketItemInventoryIndex = @ticketItemInventoryIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ChaosCastlePositionSet" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="positionX">The position x.</param>
    /// <param name="positionY">The position y.</param>
    /// <remarks>
    /// Is sent by the client when: The game client noticed, that the coordinates of the player is not on the ground anymore. It requests to set the specified coordinates.
    /// Causes reaction on server side: The server sets the player on the new coordinates. Not handled on OpenMU.
    /// </remarks>
    public static async ValueTask SendChaosCastlePositionSetAsync(this IConnection? connection, byte @positionX, byte @positionY)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ChaosCastlePositionSetRef.Length;
            var packet = new ChaosCastlePositionSetRef(connection.Output.GetSpan(length)[..length]);
            packet.PositionX = @positionX;
            packet.PositionY = @positionY;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelStartRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="playerName">The player name.</param>
    /// <remarks>
    /// Is sent by the client when: The player requests to start a duel with another player.
    /// Causes reaction on server side: The server sends a request to the other player.
    /// </remarks>
    public static async ValueTask SendDuelStartRequestAsync(this IConnection? connection, ushort @playerId, string @playerName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelStartRequestRef.Length;
            var packet = new DuelStartRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.PlayerId = @playerId;
            packet.PlayerName = @playerName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelStartResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="response">The response.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="playerName">The player name.</param>
    /// <remarks>
    /// Is sent by the client when: A player requested to start a duel with the sending player.
    /// Causes reaction on server side: Depending on the response, the server starts the duel, or not.
    /// </remarks>
    public static async ValueTask SendDuelStartResponseAsync(this IConnection? connection, bool @response, ushort @playerId, string @playerName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelStartResponseRef.Length;
            var packet = new DuelStartResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Response = @response;
            packet.PlayerId = @playerId;
            packet.PlayerName = @playerName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelStopRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: A player requested to stop the duel.
    /// Causes reaction on server side: The server stops the duel.
    /// </remarks>
    public static async ValueTask SendDuelStopRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelStopRequestRef.Length;
            var packet = new DuelStopRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelChannelJoinRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="channelId">The channel id.</param>
    /// <remarks>
    /// Is sent by the client when: A player requested to join the duel as a spectator.
    /// Causes reaction on server side: The server will add the player as spectator.
    /// </remarks>
    public static async ValueTask SendDuelChannelJoinRequestAsync(this IConnection? connection, byte @channelId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelChannelJoinRequestRef.Length;
            var packet = new DuelChannelJoinRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.ChannelId = @channelId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelChannelQuitRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the client when: A player requested to quit the duel as a spectator.
    /// Causes reaction on server side: The server will remove the player as spectator.
    /// </remarks>
    public static async ValueTask SendDuelChannelQuitRequestAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelChannelQuitRequestRef.Length;
            var packet = new DuelChannelQuitRequestRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }}