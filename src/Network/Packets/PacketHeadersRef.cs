// <copyright file="PacketHeadersRef.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Network.Packets;

using System;
using static System.Buffers.Binary.BinaryPrimitives;

/// <summary>
/// The structure for a C1 packet header. Usually encrypted by Xor32..
/// </summary>
public readonly ref struct C1HeaderRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C1HeaderRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C1HeaderRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public byte Length
    {
        get => this._data[1];
        set => this._data[1] = value;
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data[2];
        set => this._data[2] = value;
    }
}


/// <summary>
/// The structure for a C1 packet header with sub code. Usually encrypted by Xor32..
/// </summary>
public readonly ref struct C1HeaderWithSubCodeRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C1HeaderWithSubCodeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C1HeaderWithSubCodeRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public byte Length
    {
        get => this._data[1];
        set => this._data[1] = value;
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the sub code.
    /// </summary>
    public byte SubCode
    {
        get => this._data[3];
        set => this._data[3] = value;
    }
}


/// <summary>
/// The structure for a C2 packet header. Usually encrypted by Xor32..
/// </summary>
public readonly ref struct C2HeaderRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C2HeaderRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C2HeaderRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public ushort Length
    {
        get => ReadUInt16BigEndian(this._data[1..]);
        set => WriteUInt16BigEndian(this._data[1..], value);
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data[3];
        set => this._data[3] = value;
    }
}


/// <summary>
/// The structure for a C2 packet header. Usually encrypted by Xor32..
/// </summary>
public readonly ref struct C2HeaderWithSubCodeRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C2HeaderWithSubCodeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C2HeaderWithSubCodeRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public ushort Length
    {
        get => ReadUInt16BigEndian(this._data[1..]);
        set => WriteUInt16BigEndian(this._data[1..], value);
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the sub code.
    /// </summary>
    public byte SubCode
    {
        get => this._data[4];
        set => this._data[4] = value;
    }
}


/// <summary>
/// The structure for a C3 packet header. Usually encrypted by Xor32 and SimpleModulus..
/// </summary>
public readonly ref struct C3HeaderRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C3HeaderRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C3HeaderRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public byte Length
    {
        get => this._data[1];
        set => this._data[1] = value;
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data[2];
        set => this._data[2] = value;
    }
}


/// <summary>
/// The structure for a C3 packet header with sub code. Usually encrypted by Xor32 and SimpleModulus..
/// </summary>
public readonly ref struct C3HeaderWithSubCodeRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C3HeaderWithSubCodeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C3HeaderWithSubCodeRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public byte Length
    {
        get => this._data[1];
        set => this._data[1] = value;
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the sub code.
    /// </summary>
    public byte SubCode
    {
        get => this._data[3];
        set => this._data[3] = value;
    }
}


/// <summary>
/// The structure for a C4 packet header. Usually encrypted by Xor32 and SimpleModulus..
/// </summary>
public readonly ref struct C4HeaderRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C4HeaderRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C4HeaderRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public ushort Length
    {
        get => ReadUInt16BigEndian(this._data[1..]);
        set => WriteUInt16BigEndian(this._data[1..], value);
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data[3];
        set => this._data[3] = value;
    }
}


/// <summary>
/// The structure for a C4 packet header with sub code. Usually encrypted by Xor32 and SimpleModulus..
/// </summary>
public readonly ref struct C4HeaderWithSubCodeRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="C4HeaderWithSubCodeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public C4HeaderWithSubCodeRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the length.
    /// </summary>
    public ushort Length
    {
        get => ReadUInt16BigEndian(this._data[1..]);
        set => WriteUInt16BigEndian(this._data[1..], value);
    }

    /// <summary>
    /// Gets or sets the code.
    /// </summary>
    public byte Code
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the sub code.
    /// </summary>
    public byte SubCode
    {
        get => this._data[4];
        set => this._data[4] = value;
    }
}
