// <copyright file="ServerToClientPacketsRef.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Network.Packets.ServerToClient;

using System;
using static System.Buffers.Binary.BinaryPrimitives;

/// <summary>
/// The structure for a stored item, e.g. in the inventory or vault..
/// </summary>
public readonly ref struct StoredItemRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="StoredItemRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public StoredItemRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(1);
    }

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 1;
}


/// <summary>
/// Data of an item in a player shop..
/// </summary>
public readonly ref struct PlayerShopItemRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopItemRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 20;

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(1, 12);
    }

    /// <summary>
    /// Gets or sets the price.
    /// </summary>
    public uint Price
    {
        get => ReadUInt32LittleEndian(this._data[16..]);
        set => WriteUInt32LittleEndian(this._data[16..], value);
    }
}


/// <summary>
/// Defines the information which identifies a quest..
/// </summary>
public readonly ref struct QuestIdentificationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestIdentificationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestIdentificationRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets or sets the number.
    /// </summary>
    public ushort Number
    {
        get => ReadUInt16LittleEndian(this._data);
        set => WriteUInt16LittleEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the group.
    /// </summary>
    public ushort Group
    {
        get => ReadUInt16LittleEndian(this._data[2..]);
        set => WriteUInt16LittleEndian(this._data[2..], value);
    }
}


/// <summary>
/// Defines a condition which must be fulfilled to complete the quest..
/// </summary>
public readonly ref struct QuestConditionRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestConditionRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestConditionRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 26;

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public ConditionType Type
    {
        get => (ConditionType)this._data[0];
        set => this._data[0] = (byte)value;
    }

    /// <summary>
    /// Gets or sets depending on the condition type, this field contains the identifier of the required thing, e.g. Monster Number, Item Id, Level.
    /// </summary>
    public ushort RequirementId
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the required count.
    /// </summary>
    public uint RequiredCount
    {
        get => ReadUInt32LittleEndian(this._data[6..]);
        set => WriteUInt32LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the current count.
    /// </summary>
    public uint CurrentCount
    {
        get => ReadUInt32LittleEndian(this._data[10..]);
        set => WriteUInt32LittleEndian(this._data[10..], value);
    }

    /// <summary>
    /// Gets or sets if the condition type is 'Item', this field contains the item data, excluding the item id. The item id can be found in the RequirementId field.
    /// </summary>
    public Span<byte> RequiredItemData
    {
        get => this._data.Slice(14, 12);
    }
}


/// <summary>
/// Defines a reward which is given when the quest is completed..
/// </summary>
public readonly ref struct QuestRewardRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestRewardRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestRewardRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 22;

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public RewardType Type
    {
        get => (RewardType)this._data[0];
        set => this._data[0] = (byte)value;
    }

    /// <summary>
    /// Gets or sets depending on the condition type, this field contains the identifier of the required thing, e.g. Monster Number, Item Id, Level.
    /// </summary>
    public ushort RewardId
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the reward count.
    /// </summary>
    public uint RewardCount
    {
        get => ReadUInt32LittleEndian(this._data[6..]);
        set => WriteUInt32LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets if the reward type is 'Item', this field contains its item data.
    /// </summary>
    public Span<byte> RewardedItemData
    {
        get => this._data.Slice(10, 12);
    }
}


/// <summary>
/// Is sent by the server when: After a game client has connected to the game.
/// Causes reaction on client side: It shows the login dialog.
/// </summary>
public readonly ref struct GameServerEnteredRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GameServerEnteredRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GameServerEnteredRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GameServerEnteredRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GameServerEnteredRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Success = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the version string.
    /// </summary>
    public string VersionString
    {
        get => this._data.ExtractString(7, 5, System.Text.Encoding.UTF8);
        set => this._data.Slice(7, 5).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the version.
    /// </summary>
    public Span<byte> Version
    {
        get => this._data.Slice(7, 5);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GameServerEntered"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GameServerEnteredRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GameServerEntered"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GameServerEnteredRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A magic effect was added or removed to the own or another player.
/// Causes reaction on client side: The user interface updates itself. If it's the effect of the own player, it's shown as icon at the top of the interface.
/// </summary>
public readonly ref struct MagicEffectStatusRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectStatusRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MagicEffectStatusRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectStatusRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MagicEffectStatusRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the is active.
    /// </summary>
    public bool IsActive
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the effect id.
    /// </summary>
    public byte EffectId
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MagicEffectStatus"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MagicEffectStatusRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MagicEffectStatus"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MagicEffectStatusRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The weather on the current map has been changed or the player entered the map.
/// Causes reaction on client side: The game client updates the weather effects.
/// </summary>
public readonly ref struct WeatherStatusUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="WeatherStatusUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public WeatherStatusUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="WeatherStatusUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private WeatherStatusUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x0F;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets a random value between 0 and 2 (inclusive).
    /// </summary>
    public byte Weather
    {
        get => this._data[3..].GetByteValue(4, 4);
        set => this._data[3..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets a random value between 0 and 9 (inclusive).
    /// </summary>
    public byte Variation
    {
        get => this._data[3..].GetByteValue(4, 0);
        set => this._data[3..].SetByteValue(value, 4, 0);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="WeatherStatusUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator WeatherStatusUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="WeatherStatusUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(WeatherStatusUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: One or more character got into the observed scope of the player.
/// Causes reaction on client side: The client adds the character to the shown map.
/// </summary>
public readonly ref partial struct AddCharactersToScopeRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharactersToScopeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddCharactersToScopeRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharactersToScopeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddCharactersToScopeRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddCharactersToScope"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddCharactersToScopeRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddCharactersToScope"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddCharactersToScopeRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterDataRef"/> and it's size.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterDataRef"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="CharacterDataRef"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int charactersCount, int structLength) => charactersCount * structLength + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly ref struct CharacterDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(4, 18);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(22, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(22, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data[32];
        set => this._data[32] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data[33];
        set => this._data[33] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[34..].GetByteValue(4, 4);
        set => this._data[34..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data[34..].GetByteValue(4, 0);
        set => this._data[34..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets defines the number of effects which would be sent after this field.
    /// </summary>
    public byte EffectCount
    {
        get => this._data[35];
        set => this._data[35] = value;
    }

    /// <summary>
    /// Gets the <see cref="EffectIdRef"/> of the specified index.
    /// </summary>
        public EffectIdRef this[int index] => new (this._data[(36 + index * EffectIdRef.Length)..]);

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="EffectIdRef"/>.
    /// </summary>
    /// <param name="effectsCount">The count of <see cref="EffectIdRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int effectsCount) => effectsCount * EffectIdRef.Length + 36;
}


/// <summary>
/// Contains the id of a magic effect..
/// </summary>
public readonly ref struct EffectIdRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EffectIdRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EffectIdRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 1;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public byte Id
    {
        get => this._data[0];
        set => this._data[0] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: One or more character got into the observed scope of the player.
/// Causes reaction on client side: The client adds the character to the shown map.
/// </summary>
public readonly ref struct AddCharactersToScope075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharactersToScope075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddCharactersToScope075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharactersToScope075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddCharactersToScope075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="CharacterDataRef"/> of the specified index.
    /// </summary>
        public CharacterDataRef this[int index] => new (this._data[(5 + index * CharacterDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddCharactersToScope075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddCharactersToScope075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddCharactersToScope075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddCharactersToScope075Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterDataRef"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterDataRef.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly ref struct CharacterDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 27;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(4, 9);
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data[13..].GetBoolean(0);
        set => this._data[13..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data[13..].GetBoolean(1);
        set => this._data[13..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data[13..].GetBoolean(2);
        set => this._data[13..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data[13..].GetBoolean(3);
        set => this._data[13..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(14, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(14, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data[24];
        set => this._data[24] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data[25];
        set => this._data[25] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[26..].GetByteValue(4, 4);
        set => this._data[26..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data[26..].GetByteValue(4, 0);
        set => this._data[26..].SetByteValue((byte)value, 4, 0);
    }
}
}


/// <summary>
/// Is sent by the server when: One or more character got into the observed scope of the player.
/// Causes reaction on client side: The client adds the character to the shown map.
/// </summary>
public readonly ref struct AddCharactersToScope095Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharactersToScope095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddCharactersToScope095Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharactersToScope095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddCharactersToScope095Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="CharacterDataRef"/> of the specified index.
    /// </summary>
        public CharacterDataRef this[int index] => new (this._data[(5 + index * CharacterDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddCharactersToScope095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddCharactersToScope095Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddCharactersToScope095"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddCharactersToScope095Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterDataRef"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterDataRef.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly ref struct CharacterDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 31;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(4, 13);
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data[17..].GetBoolean(0);
        set => this._data[17..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data[17..].GetBoolean(1);
        set => this._data[17..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data[17..].GetBoolean(2);
        set => this._data[17..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data[17..].GetBoolean(3);
        set => this._data[17..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(18, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(18, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data[28];
        set => this._data[28] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data[29];
        set => this._data[29] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[30..].GetByteValue(4, 4);
        set => this._data[30..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data[30..].GetByteValue(4, 0);
        set => this._data[30..].SetByteValue((byte)value, 4, 0);
    }
}
}


/// <summary>
/// Is sent by the server when: One or more NPCs got into the observed scope of the player.
/// Causes reaction on client side: The client adds the NPCs to the shown map.
/// </summary>
public readonly ref struct AddNpcsToScopeRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddNpcsToScopeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddNpcsToScopeRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddNpcsToScopeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddNpcsToScopeRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the npc count.
    /// </summary>
    public byte NpcCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="NpcDataRef"/> of the specified index.
    /// </summary>
        public NpcDataRef this[int index] => new (this._data[(5 + index * NpcDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddNpcsToScope"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddNpcsToScopeRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddNpcsToScope"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddNpcsToScopeRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="NpcDataRef"/>.
    /// </summary>
    /// <param name="nPCsCount">The count of <see cref="NpcDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int nPCsCount) => nPCsCount * NpcDataRef.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly ref struct NpcDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the type number.
    /// </summary>
    public ushort TypeNumber
    {
        get => ReadUInt16BigEndian(this._data[2..]);
        set => WriteUInt16BigEndian(this._data[2..], value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[8..].GetByteValue(4, 4);
        set => this._data[8..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets defines the number of effects which would be sent after this field. This is currently not supported.
    /// </summary>
    public byte EffectCount
    {
        get => this._data[9];
        set => this._data[9] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: One or more NPCs got into the observed scope of the player.
/// Causes reaction on client side: The client adds the NPCs to the shown map.
/// </summary>
public readonly ref struct AddNpcsToScope075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddNpcsToScope075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddNpcsToScope075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddNpcsToScope075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddNpcsToScope075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the npc count.
    /// </summary>
    public byte NpcCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="NpcDataRef"/> of the specified index.
    /// </summary>
        public NpcDataRef this[int index] => new (this._data[(5 + index * NpcDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddNpcsToScope075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddNpcsToScope075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddNpcsToScope075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddNpcsToScope075Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="NpcDataRef"/>.
    /// </summary>
    /// <param name="nPCsCount">The count of <see cref="NpcDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int nPCsCount) => nPCsCount * NpcDataRef.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly ref struct NpcDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the type number.
    /// </summary>
    public byte TypeNumber
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data[3..].GetBoolean(0);
        set => this._data[3..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data[3..].GetBoolean(1);
        set => this._data[3..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data[3..].GetBoolean(2);
        set => this._data[3..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data[3..].GetBoolean(3);
        set => this._data[3..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[8..].GetByteValue(4, 4);
        set => this._data[8..].SetByteValue(value, 4, 4);
    }
}
}


/// <summary>
/// Is sent by the server when: One or more NPCs got into the observed scope of the player.
/// Causes reaction on client side: The client adds the NPCs to the shown map.
/// </summary>
public readonly ref struct AddNpcsToScope095Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddNpcsToScope095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddNpcsToScope095Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddNpcsToScope095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddNpcsToScope095Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the npc count.
    /// </summary>
    public byte NpcCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="NpcDataRef"/> of the specified index.
    /// </summary>
        public NpcDataRef this[int index] => new (this._data[(5 + index * NpcDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddNpcsToScope095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddNpcsToScope095Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddNpcsToScope095"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddNpcsToScope095Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="NpcDataRef"/>.
    /// </summary>
    /// <param name="nPCsCount">The count of <see cref="NpcDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int nPCsCount) => nPCsCount * NpcDataRef.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly ref struct NpcDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the type number.
    /// </summary>
    public byte TypeNumber
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data[4..].GetBoolean(0);
        set => this._data[4..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data[4..].GetBoolean(1);
        set => this._data[4..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data[4..].GetBoolean(2);
        set => this._data[4..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data[4..].GetBoolean(3);
        set => this._data[4..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data[9];
        set => this._data[9] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[10..].GetByteValue(4, 4);
        set => this._data[10..].SetByteValue(value, 4, 4);
    }
}
}


/// <summary>
/// Is sent by the server when: One or more summoned monsters got into the observed scope of the player.
/// Causes reaction on client side: The client adds the monsters to the shown map.
/// </summary>
public readonly ref partial struct AddSummonedMonstersToScopeRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddSummonedMonstersToScopeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddSummonedMonstersToScopeRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddSummonedMonstersToScopeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddSummonedMonstersToScopeRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1F;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the monster count.
    /// </summary>
    public byte MonsterCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddSummonedMonstersToScope"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddSummonedMonstersToScopeRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddSummonedMonstersToScope"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddSummonedMonstersToScopeRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="SummonedMonsterDataRef"/> and it's size.
    /// </summary>
    /// <param name="summonedMonstersCount">The count of <see cref="SummonedMonsterDataRef"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="SummonedMonsterDataRef"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int summonedMonstersCount, int structLength) => summonedMonstersCount * structLength + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly ref struct SummonedMonsterDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SummonedMonsterDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SummonedMonsterDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the type number.
    /// </summary>
    public ushort TypeNumber
    {
        get => ReadUInt16BigEndian(this._data[2..]);
        set => WriteUInt16BigEndian(this._data[2..], value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[8..].GetByteValue(4, 4);
        set => this._data[8..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the owner character name.
    /// </summary>
    public string OwnerCharacterName
    {
        get => this._data.ExtractString(9, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(9, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets defines the number of effects which would be sent after this field. This is currently not supported.
    /// </summary>
    public byte EffectCount
    {
        get => this._data[19];
        set => this._data[19] = value;
    }

    /// <summary>
    /// Gets the <see cref="EffectIdRef"/> of the specified index.
    /// </summary>
        public EffectIdRef this[int index] => new (this._data[(20 + index * EffectIdRef.Length)..]);

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="EffectIdRef"/>.
    /// </summary>
    /// <param name="effectsCount">The count of <see cref="EffectIdRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int effectsCount) => effectsCount * EffectIdRef.Length + 20;
}


/// <summary>
/// Contains the id of a magic effect..
/// </summary>
public readonly ref struct EffectIdRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EffectIdRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EffectIdRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 1;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public byte Id
    {
        get => this._data[0];
        set => this._data[0] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: One or more summoned monsters got into the observed scope of the player.
/// Causes reaction on client side: The client adds the monsters to the shown map.
/// </summary>
public readonly ref struct AddSummonedMonstersToScope075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddSummonedMonstersToScope075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddSummonedMonstersToScope075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1F;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the monster count.
    /// </summary>
    public byte MonsterCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="SummonedMonsterDataRef"/> of the specified index.
    /// </summary>
        public SummonedMonsterDataRef this[int index] => new (this._data[(5 + index * SummonedMonsterDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddSummonedMonstersToScope075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddSummonedMonstersToScope075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddSummonedMonstersToScope075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddSummonedMonstersToScope075Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="SummonedMonsterDataRef"/>.
    /// </summary>
    /// <param name="summonedMonstersCount">The count of <see cref="SummonedMonsterDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int summonedMonstersCount) => summonedMonstersCount * SummonedMonsterDataRef.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly ref struct SummonedMonsterDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SummonedMonsterDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SummonedMonsterDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 19;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the type number.
    /// </summary>
    public byte TypeNumber
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data[3..].GetBoolean(0);
        set => this._data[3..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data[3..].GetBoolean(1);
        set => this._data[3..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data[3..].GetBoolean(2);
        set => this._data[3..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data[3..].GetBoolean(3);
        set => this._data[3..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[8..].GetByteValue(4, 4);
        set => this._data[8..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the owner character name.
    /// </summary>
    public string OwnerCharacterName
    {
        get => this._data.ExtractString(9, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(9, 10).WriteString(value, System.Text.Encoding.UTF8);
    }
}
}


/// <summary>
/// Is sent by the server when: One or more summoned monsters got into the observed scope of the player.
/// Causes reaction on client side: The client adds the monsters to the shown map.
/// </summary>
public readonly ref struct AddSummonedMonstersToScope095Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddSummonedMonstersToScope095Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddSummonedMonstersToScope095Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1F;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the monster count.
    /// </summary>
    public byte MonsterCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="SummonedMonsterDataRef"/> of the specified index.
    /// </summary>
        public SummonedMonsterDataRef this[int index] => new (this._data[(5 + index * SummonedMonsterDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddSummonedMonstersToScope095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddSummonedMonstersToScope095Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddSummonedMonstersToScope095"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddSummonedMonstersToScope095Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="SummonedMonsterDataRef"/>.
    /// </summary>
    /// <param name="summonedMonstersCount">The count of <see cref="SummonedMonsterDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int summonedMonstersCount) => summonedMonstersCount * SummonedMonsterDataRef.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly ref struct SummonedMonsterDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SummonedMonsterDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SummonedMonsterDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 20;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the type number.
    /// </summary>
    public byte TypeNumber
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data[4..].GetBoolean(0);
        set => this._data[4..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data[4..].GetBoolean(1);
        set => this._data[4..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data[4..].GetBoolean(2);
        set => this._data[4..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data[4..].GetBoolean(3);
        set => this._data[4..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[9..].GetByteValue(4, 4);
        set => this._data[9..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the owner character name.
    /// </summary>
    public string OwnerCharacterName
    {
        get => this._data.ExtractString(10, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(10, 10).WriteString(value, System.Text.Encoding.UTF8);
    }
}
}


/// <summary>
/// Is sent by the server when: One or more objects (player, npc, etc.) on the map got out of scope, e.g. when the own player moved away from it/them or the object itself moved.
/// Causes reaction on client side: The game client removes the objects from the game map.
/// </summary>
public readonly ref struct MapObjectOutOfScopeRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MapObjectOutOfScopeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MapObjectOutOfScopeRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MapObjectOutOfScopeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MapObjectOutOfScopeRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the object count.
    /// </summary>
    public byte ObjectCount
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets the <see cref="ObjectIdRef"/> of the specified index.
    /// </summary>
        public ObjectIdRef this[int index] => new (this._data[(4 + index * ObjectIdRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MapObjectOutOfScope"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MapObjectOutOfScopeRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MapObjectOutOfScope"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MapObjectOutOfScopeRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="ObjectIdRef"/>.
    /// </summary>
    /// <param name="objectsCount">The count of <see cref="ObjectIdRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int objectsCount) => objectsCount * ObjectIdRef.Length + 4;


/// <summary>
/// Contains the id of a object..
/// </summary>
public readonly ref struct ObjectIdRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectIdRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectIdRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 2;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }
}
}


/// <summary>
/// Is sent by the server when: An observed object was killed.
/// Causes reaction on client side: The object is shown as dead.
/// </summary>
public readonly ref struct ObjectGotKilledRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectGotKilledRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectGotKilledRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectGotKilledRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectGotKilledRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x17;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the killed id.
    /// </summary>
    public ushort KilledId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the killer id.
    /// </summary>
    public ushort KillerId
    {
        get => ReadUInt16BigEndian(this._data[7..]);
        set => WriteUInt16BigEndian(this._data[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectGotKilled"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectGotKilledRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectGotKilled"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ObjectGotKilledRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs an animation.
/// Causes reaction on client side: The animation is shown for the specified object.
/// </summary>
public readonly ref struct ObjectAnimationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectAnimationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectAnimationRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectAnimationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectAnimationRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x18;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the direction.
    /// </summary>
    public byte Direction
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the animation.
    /// </summary>
    public byte Animation
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[7..]);
        set => WriteUInt16BigEndian(this._data[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectAnimation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectAnimationRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectAnimation"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ObjectAnimationRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs a skill which has effect on an area.
/// Causes reaction on client side: The animation is shown on the user interface.
/// </summary>
public readonly ref struct AreaSkillAnimationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillAnimationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AreaSkillAnimationRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillAnimationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AreaSkillAnimationRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1E;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the point x.
    /// </summary>
    public byte PointX
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the point y.
    /// </summary>
    public byte PointY
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[9];
        set => this._data[9] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkillAnimation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AreaSkillAnimationRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AreaSkillAnimation"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AreaSkillAnimationRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs a skill which is directly targeted to another object.
/// Causes reaction on client side: The animation is shown on the user interface.
/// </summary>
public readonly ref struct SkillAnimationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAnimationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillAnimationRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAnimationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillAnimationRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x19;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[7..]);
        set => WriteUInt16BigEndian(this._data[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAnimation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillAnimationRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillAnimation"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SkillAnimationRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs a skill which has effect on an area.
/// Causes reaction on client side: The animation is shown on the user interface.
/// </summary>
public readonly ref struct AreaSkillAnimation075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillAnimation075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AreaSkillAnimation075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillAnimation075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AreaSkillAnimation075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1E;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public byte SkillId
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the point x.
    /// </summary>
    public byte PointX
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the point y.
    /// </summary>
    public byte PointY
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkillAnimation075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AreaSkillAnimation075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AreaSkillAnimation075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AreaSkillAnimation075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs a skill which has effect on an area.
/// Causes reaction on client side: The animation is shown on the user interface.
/// </summary>
public readonly ref struct AreaSkillAnimation095Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillAnimation095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AreaSkillAnimation095Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillAnimation095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AreaSkillAnimation095Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1E;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public byte SkillId
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the point x.
    /// </summary>
    public byte PointX
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the point y.
    /// </summary>
    public byte PointY
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkillAnimation095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AreaSkillAnimation095Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AreaSkillAnimation095"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AreaSkillAnimation095Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs a skill which is directly targeted to another object.
/// Causes reaction on client side: The animation is shown on the user interface.
/// </summary>
public readonly ref struct SkillAnimation075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAnimation075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillAnimation075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAnimation075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillAnimation075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x19;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public byte SkillId
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the effect applied.
    /// </summary>
    public bool EffectApplied
    {
        get => this._data[6..].GetBoolean(7);
        set => this._data[6..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAnimation075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillAnimation075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillAnimation075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SkillAnimation075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs a skill which is directly targeted to another object.
/// Causes reaction on client side: The animation is shown on the user interface.
/// </summary>
public readonly ref struct SkillAnimation095Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAnimation095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillAnimation095Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAnimation095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillAnimation095Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x19;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public byte SkillId
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the effect applied.
    /// </summary>
    public bool EffectApplied
    {
        get => this._data[6..].GetBoolean(7);
        set => this._data[6..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAnimation095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillAnimation095Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillAnimation095"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SkillAnimation095Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player cancelled a specific magic effect of a skill (Infinity Arrow, Wizardry Enhance), or an effect was removed due a timeout (Ice, Poison) or antidote.
/// Causes reaction on client side: The effect is removed from the target object.
/// </summary>
public readonly ref struct MagicEffectCancelledRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectCancelledRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MagicEffectCancelledRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectCancelledRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MagicEffectCancelledRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MagicEffectCancelled"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MagicEffectCancelledRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MagicEffectCancelled"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MagicEffectCancelledRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player cancelled a specific magic effect of a skill (Infinity Arrow, Wizardry Enhance), or an effect was removed due a timeout (Ice, Poison) or antidote.
/// Causes reaction on client side: The effect is removed from the target object.
/// </summary>
public readonly ref struct MagicEffectCancelled075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectCancelled075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MagicEffectCancelled075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectCancelled075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MagicEffectCancelled075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public byte SkillId
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MagicEffectCancelled075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MagicEffectCancelled075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MagicEffectCancelled075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MagicEffectCancelled075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player (rage fighter) performs the dark side skill on a target and sent a RageAttackRangeRequest.
/// Causes reaction on client side: The targets are attacked with visual effects.
/// </summary>
public readonly ref struct RageAttackRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RageAttackRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RageAttackRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RageAttackRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RageAttackRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x4A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the source id.
    /// </summary>
    public ushort SourceId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[7..]);
        set => WriteUInt16BigEndian(this._data[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RageAttack"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RageAttackRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RageAttack"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RageAttackRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player (rage fighter) performs the dark side skill on a target and sent a RageAttackRangeRequest.
/// Causes reaction on client side: The targets are attacked with visual effects.
/// </summary>
public readonly ref struct RageAttackRangeResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RageAttackRangeResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RageAttackRangeResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RageAttackRangeResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RageAttackRangeResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x4B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets the <see cref="RageTargetRef"/> of the specified index.
    /// </summary>
        public RageTargetRef this[int index] => new (this._data[(6 + index * RageTargetRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RageAttackRangeResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RageAttackRangeResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RageAttackRangeResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RageAttackRangeResponseRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="RageTargetRef"/>.
    /// </summary>
    /// <param name="targetsCount">The count of <see cref="RageTargetRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int targetsCount) => targetsCount * RageTargetRef.Length + 6;


/// <summary>
/// Contains the target identifier..
/// </summary>
public readonly ref struct RageTargetRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RageTargetRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RageTargetRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 2;

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16LittleEndian(this._data);
        set => WriteUInt16LittleEndian(this._data, value);
    }
}
}


/// <summary>
/// Is sent by the server when: The appearance of a player changed, all surrounding players are informed about it.
/// Causes reaction on client side: The appearance of the player is updated.
/// </summary>
public readonly ref struct AppearanceChangedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AppearanceChangedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AppearanceChangedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AppearanceChangedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AppearanceChangedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x25;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the changed player id.
    /// </summary>
    public ushort ChangedPlayerId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(5);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AppearanceChanged"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AppearanceChangedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AppearanceChanged"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AppearanceChangedRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
}


/// <summary>
/// Is sent by the server when: The server wants to show a message above any kind of character, even NPCs.
/// Causes reaction on client side: The message is shown above the character.
/// </summary>
public readonly ref struct ObjectMessageRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectMessageRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectMessageRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectMessageRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectMessageRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x01;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the message.
    /// </summary>
    public string Message
    {
        get => this._data.ExtractString(5, this._data.Length - 5, System.Text.Encoding.UTF8);
        set => this._data.Slice(5).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectMessage"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectMessageRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectMessage"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ObjectMessageRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 5;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 5;
}


/// <summary>
/// Is sent by the server when: Another player requests party from the receiver of this message.
/// Causes reaction on client side: The party request is shown.
/// </summary>
public readonly ref struct PartyRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PartyRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the requester id.
    /// </summary>
    public ushort RequesterId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PartyRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PartyRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PartyRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player joined a party or requested the current party list by opening the party dialog.
/// Causes reaction on client side: The party list is updated.
/// </summary>
public readonly ref struct PartyListRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyListRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PartyListRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x42;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the count.
    /// </summary>
    public byte Count
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="PartyMemberRef"/> of the specified index.
    /// </summary>
        public PartyMemberRef this[int index] => new (this._data[(5 + index * PartyMemberRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PartyListRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PartyList"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PartyListRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PartyMemberRef"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="PartyMemberRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * PartyMemberRef.Length + 5;


/// <summary>
/// Data about a party member..
/// </summary>
public readonly ref struct PartyMemberRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyMemberRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyMemberRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the index.
    /// </summary>
    public byte Index
    {
        get => this._data[10];
        set => this._data[10] = value;
    }

    /// <summary>
    /// Gets or sets the map id.
    /// </summary>
    public byte MapId
    {
        get => this._data[11];
        set => this._data[11] = value;
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[12];
        set => this._data[12] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[13];
        set => this._data[13] = value;
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public uint CurrentHealth
    {
        get => ReadUInt32LittleEndian(this._data[16..]);
        set => WriteUInt32LittleEndian(this._data[16..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public uint MaximumHealth
    {
        get => ReadUInt32LittleEndian(this._data[20..]);
        set => WriteUInt32LittleEndian(this._data[20..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: A player joined a party or requested the current party list by opening the party dialog.
/// Causes reaction on client side: The party list is updated.
/// </summary>
public readonly ref struct PartyList075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyList075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyList075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyList075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PartyList075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x42;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the count.
    /// </summary>
    public byte Count
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="PartyMemberRef"/> of the specified index.
    /// </summary>
        public PartyMemberRef this[int index] => new (this._data[(5 + index * PartyMemberRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyList075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PartyList075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PartyList075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PartyList075Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PartyMemberRef"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="PartyMemberRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * PartyMemberRef.Length + 5;


/// <summary>
/// Data about a party member..
/// </summary>
public readonly ref struct PartyMemberRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyMemberRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyMemberRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the index.
    /// </summary>
    public byte Index
    {
        get => this._data[10];
        set => this._data[10] = value;
    }

    /// <summary>
    /// Gets or sets the map id.
    /// </summary>
    public byte MapId
    {
        get => this._data[11];
        set => this._data[11] = value;
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[12];
        set => this._data[12] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[13];
        set => this._data[13] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: A party member got removed from a party in which the player is in.
/// Causes reaction on client side: The party member with the specified index is removed from the party list on the user interface.
/// </summary>
public readonly ref struct RemovePartyMemberRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RemovePartyMemberRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RemovePartyMemberRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RemovePartyMemberRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RemovePartyMemberRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x43;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the index.
    /// </summary>
    public byte Index
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RemovePartyMember"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RemovePartyMemberRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RemovePartyMember"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RemovePartyMemberRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Periodically, when the health state of the party changed.
/// Causes reaction on client side: The party health list is updated.
/// </summary>
public readonly ref struct PartyHealthUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyHealthUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyHealthUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyHealthUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PartyHealthUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x44;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the count.
    /// </summary>
    public byte Count
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets the <see cref="PartyMemberHealthRef"/> of the specified index.
    /// </summary>
        public PartyMemberHealthRef this[int index] => new (this._data[(4 + index * PartyMemberHealthRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyHealthUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PartyHealthUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PartyHealthUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PartyHealthUpdateRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PartyMemberHealthRef"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="PartyMemberHealthRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * PartyMemberHealthRef.Length + 4;


/// <summary>
/// Health of a party member.
/// </summary>
public readonly ref struct PartyMemberHealthRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyMemberHealthRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyMemberHealthRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 1;

    /// <summary>
    /// Gets or sets the index.
    /// </summary>
    public byte Index
    {
        get => this._data.GetByteValue(4, 4);
        set => this._data.SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets a value from 0 to 10 about the health of a player. 10 means the current health is 100% of the maximum health.
    /// </summary>
    public byte Value
    {
        get => this._data.GetByteValue(4, 0);
        set => this._data.SetByteValue(value, 4, 0);
    }
}
}


/// <summary>
/// Is sent by the server when: After the player requested to open his shop and this request was successful.
/// Causes reaction on client side: The own player shop is shown as open.
/// </summary>
public readonly ref struct PlayerShopOpenSuccessfulRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopOpenSuccessfulRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopOpenSuccessfulRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopOpenSuccessfulRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopOpenSuccessfulRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Success = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x2;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopOpenSuccessful"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopOpenSuccessfulRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopOpenSuccessful"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayerShopOpenSuccessfulRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the trading partner checked or unchecked the trade accept button.
/// Causes reaction on client side: The game client updates the trade button state accordingly.
/// </summary>
public readonly ref struct TradeButtonStateChangedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeButtonStateChangedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeButtonStateChangedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeButtonStateChangedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeButtonStateChangedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the state.
    /// </summary>
    public TradeButtonStateChanged.TradeButtonState State
    {
        get => (TradeButtonStateChanged.TradeButtonState)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeButtonStateChanged"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeButtonStateChangedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeButtonStateChanged"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TradeButtonStateChangedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The trade money has been set by a previous request of the player.
/// Causes reaction on client side: The money which was set into the trade by the player is updated on the UI.
/// </summary>
public readonly ref struct TradeMoneySetResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeMoneySetResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeMoneySetResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeMoneySetResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeMoneySetResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3A;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeMoneySetResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeMoneySetResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeMoneySetResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TradeMoneySetResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: This message is sent when the trading partner put a certain amount of money (also 0) into the trade.
/// Causes reaction on client side: It overrides all previous sent money values.
/// </summary>
public readonly ref struct TradeMoneyUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeMoneyUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeMoneyUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeMoneyUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeMoneyUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the money amount.
    /// </summary>
    public uint MoneyAmount
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeMoneyUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeMoneyUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeMoneyUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TradeMoneyUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player which receives this message, sent a trade request to another player. This message is sent when the other player responded to this request.
/// Causes reaction on client side: If the trade was accepted, a trade dialog is opened. Otherwise, a message is shown.
/// </summary>
public readonly ref struct TradeRequestAnswerRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeRequestAnswerRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeRequestAnswerRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeRequestAnswerRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeRequestAnswerRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x37;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 20;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the accepted.
    /// </summary>
    public bool Accepted
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the trade partner level.
    /// </summary>
    public ushort TradePartnerLevel
    {
        get => ReadUInt16BigEndian(this._data[14..]);
        set => WriteUInt16BigEndian(this._data[14..], value);
    }

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public uint GuildId
    {
        get => ReadUInt32LittleEndian(this._data[16..]);
        set => WriteUInt32LittleEndian(this._data[16..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeRequestAnswer"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeRequestAnswerRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeRequestAnswer"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TradeRequestAnswerRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A trade was requested by another player.
/// Causes reaction on client side: A trade request dialog is shown.
/// </summary>
public readonly ref struct TradeRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x36;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TradeRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A trade was finished.
/// Causes reaction on client side: The trade dialog is closed. Depending on the result, a message is shown.
/// </summary>
public readonly ref struct TradeFinishedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeFinishedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeFinishedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeFinishedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeFinishedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public TradeFinished.TradeResult Result
    {
        get => (TradeFinished.TradeResult)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeFinished"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeFinishedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeFinished"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TradeFinishedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The trading partner added an item to the trade.
/// Causes reaction on client side: The item is added in the trade dialog.
/// </summary>
public readonly ref struct TradeItemAddedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeItemAddedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeItemAddedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeItemAddedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeItemAddedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x39;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the to slot.
    /// </summary>
    public byte ToSlot
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(4);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeItemAdded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeItemAddedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeItemAdded"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TradeItemAddedRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
}


/// <summary>
/// Is sent by the server when: The trading partner removed an item from the trade.
/// Causes reaction on client side: The item is removed from the trade dialog.
/// </summary>
public readonly ref struct TradeItemRemovedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeItemRemovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeItemRemovedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeItemRemovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeItemRemovedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x38;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the slot.
    /// </summary>
    public byte Slot
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeItemRemoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeItemRemovedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeItemRemoved"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(TradeItemRemovedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the login request has been processed by the server.
/// Causes reaction on client side: Shows the result. When it was successful, the client proceeds by sending a character list request.
/// </summary>
public readonly ref struct LoginResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LoginResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LoginResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LoginResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LoginResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public LoginResponse.LoginResult Success
    {
        get => (LoginResponse.LoginResult)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LoginResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LoginResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LoginResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LoginResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the logout request has been processed by the server.
/// Causes reaction on client side: Depending on the result, the game client closes the game or changes to another selection screen.
/// </summary>
public readonly ref struct LogoutResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LogoutResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LogoutResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LogoutResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LogoutResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public LogOutType Type
    {
        get => (LogOutType)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LogoutResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LogoutResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LogoutResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LogoutResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player sends a chat message.
/// Causes reaction on client side: The message is shown in the chat box and above the character of the sender.
/// </summary>
public readonly ref struct ChatMessageRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatMessageRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChatMessageRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatMessageRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChatMessageRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x00;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public ChatMessage.ChatMessageType Type
    {
        get => (ChatMessage.ChatMessageType)this._data[2];
        set => this._data[2] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the sender.
    /// </summary>
    public string Sender
    {
        get => this._data.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the message.
    /// </summary>
    public string Message
    {
        get => this._data.ExtractString(13, this._data.Length - 13, System.Text.Encoding.UTF8);
        set => this._data.Slice(13).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ChatMessage"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChatMessageRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChatMessage"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ChatMessageRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 13;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 13;
}


/// <summary>
/// Is sent by the server when: An object got hit in two cases: 1. When the own player is hit; 2. When the own player attacked some other object which got hit.
/// Causes reaction on client side: The damage is shown at the object which received the hit.
/// </summary>
public readonly ref struct ObjectHitRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectHitRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectHitRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectHitRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectHitRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the header code.
    /// </summary>
    public byte HeaderCode
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the health damage.
    /// </summary>
    public ushort HealthDamage
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the kind.
    /// </summary>
    public ObjectHit.DamageKind Kind
    {
        get => (ObjectHit.DamageKind)this._data[7..].GetByteValue(4, 0);
        set => this._data[7..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the is double damage.
    /// </summary>
    public bool IsDoubleDamage
    {
        get => this._data[7..].GetBoolean(6);
        set => this._data[7..].SetBoolean(value, 6);
    }

    /// <summary>
    /// Gets or sets the is triple damage.
    /// </summary>
    public bool IsTripleDamage
    {
        get => this._data[7..].GetBoolean(7);
        set => this._data[7..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Gets or sets the shield damage.
    /// </summary>
    public ushort ShieldDamage
    {
        get => ReadUInt16BigEndian(this._data[8..]);
        set => WriteUInt16BigEndian(this._data[8..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectHit"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectHitRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectHit"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ObjectHitRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object in the observed scope (including the own player) moved instantly.
/// Causes reaction on client side: The position of the object is updated on client side.
/// </summary>
public readonly ref struct ObjectMovedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectMovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectMovedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectMovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectMovedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x15;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the header code.
    /// </summary>
    public byte HeaderCode
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectMoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectMovedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectMoved"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ObjectMovedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object in the observed scope (including the own player) walked to another position.
/// Causes reaction on client side: The object is animated to walk to the new position.
/// </summary>
public readonly ref struct ObjectWalkedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectWalkedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectWalkedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectWalkedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectWalkedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the header code.
    /// </summary>
    public byte HeaderCode
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the target rotation.
    /// </summary>
    public byte TargetRotation
    {
        get => this._data[7..].GetByteValue(4, 4);
        set => this._data[7..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the step count.
    /// </summary>
    public byte StepCount
    {
        get => this._data[7..].GetByteValue(4, 0);
        set => this._data[7..].SetByteValue(value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the step data.
    /// </summary>
    public Span<byte> StepData
    {
        get => this._data.Slice(8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectWalked"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectWalkedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectWalked"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ObjectWalkedRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="StepData"/>.
    /// </summary>
    /// <param name="stepDataLength">The length in bytes of <see cref="StepData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int stepDataLength) => stepDataLength + 8;
}


/// <summary>
/// Is sent by the server when: An object in the observed scope (including the own player) walked to another position.
/// Causes reaction on client side: The object is animated to walk to the new position.
/// </summary>
public readonly ref struct ObjectWalked075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectWalked075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectWalked075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectWalked075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectWalked075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x10;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the target rotation.
    /// </summary>
    public byte TargetRotation
    {
        get => this._data[7..].GetByteValue(4, 4);
        set => this._data[7..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectWalked075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectWalked075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectWalked075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ObjectWalked075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player gained experience.
/// Causes reaction on client side: The experience is added to the experience counter and bar.
/// </summary>
public readonly ref struct ExperienceGainedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ExperienceGainedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ExperienceGainedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ExperienceGainedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ExperienceGainedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x16;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the killed object id.
    /// </summary>
    public ushort KilledObjectId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the added experience.
    /// </summary>
    public ushort AddedExperience
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the damage of last hit.
    /// </summary>
    public ushort DamageOfLastHit
    {
        get => ReadUInt16BigEndian(this._data[7..]);
        set => WriteUInt16BigEndian(this._data[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ExperienceGained"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ExperienceGainedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ExperienceGained"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ExperienceGainedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The map was changed on the server side.
/// Causes reaction on client side: The game client changes to the specified map and coordinates.
/// </summary>
public readonly ref struct MapChangedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MapChangedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MapChangedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MapChangedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MapChangedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.IsMapChange = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1C;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0F;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 15;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets if false, it shows the teleport animation (white bubbles), and the client doesn't remove all of the objects in its scope.
    /// </summary>
    public bool IsMapChange
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public ushort MapNumber
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[9];
        set => this._data[9] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MapChanged"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MapChangedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MapChanged"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MapChangedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The map was changed on the server side.
/// Causes reaction on client side: The game client changes to the specified map and coordinates.
/// </summary>
public readonly ref struct MapChanged075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MapChanged075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MapChanged075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MapChanged075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MapChanged075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.IsMapChange = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets if false, it shows the teleport animation (white bubbles), and the client doesn't remove all of the objects in its scope.
    /// </summary>
    public bool IsMapChange
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public byte MapNumber
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MapChanged075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MapChanged075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MapChanged075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MapChanged075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When entering the game world with a character.
/// Causes reaction on client side: The client restores this configuration in its user interface.
/// </summary>
public readonly ref struct ApplyKeyConfigurationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ApplyKeyConfigurationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ApplyKeyConfigurationRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ApplyKeyConfigurationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ApplyKeyConfigurationRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x30;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the binary data of the key configuration
    /// </summary>
    public Span<byte> Configuration
    {
        get => this._data.Slice(4);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ApplyKeyConfiguration"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ApplyKeyConfigurationRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ApplyKeyConfiguration"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ApplyKeyConfigurationRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="Configuration"/>.
    /// </summary>
    /// <param name="configurationLength">The length in bytes of <see cref="Configuration"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int configurationLength) => configurationLength + 4;
}


/// <summary>
/// Is sent by the server when: The items dropped on the ground.
/// Causes reaction on client side: The client adds the items to the ground.
/// </summary>
public readonly ref struct ItemsDroppedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemsDroppedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemsDroppedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemsDroppedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemsDroppedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x20;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="DroppedItemRef"/> of the specified index.
    /// </summary>
        public DroppedItemRef this[int index, int droppedItemLength] => new (this._data[(5 + index * droppedItemLength)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemsDropped"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemsDroppedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemsDropped"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemsDroppedRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="DroppedItemRef"/> and it's size.
    /// </summary>
    /// <param name="itemsCount">The count of <see cref="DroppedItemRef"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="DroppedItemRef"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 5;


/// <summary>
/// Contains the data about a dropped item..
/// </summary>
public readonly ref struct DroppedItemRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DroppedItemRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DroppedItemRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets if this flag is set, the item is added to the map with an animation and sound. Otherwise it's just added like it was already on the ground before.
    /// </summary>
    public bool IsFreshDrop
    {
        get => this._data.GetBoolean(7);
        set => this._data.SetBoolean(value, 7);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(4);
    }

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
}
}


/// <summary>
/// Is sent by the server when: Money dropped on the ground.
/// Causes reaction on client side: The client adds the money to the ground.
/// </summary>
public readonly ref partial struct MoneyDroppedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MoneyDroppedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MoneyDroppedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MoneyDroppedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MoneyDroppedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)Math.Min(data.Length, Length);
            this.ItemCount = 1;
            this.MoneyNumber = 15;
            this.MoneyGroup = 14;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x20;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 21;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets if this flag is set, the money is added to the map with an animation and sound. Otherwise it's just added like it was already on the ground before.
    /// </summary>
    public bool IsFreshDrop
    {
        get => this._data[5..].GetBoolean(7);
        set => this._data[5..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the money number.
    /// </summary>
    public byte MoneyNumber
    {
        get => this._data[9];
        set => this._data[9] = value;
    }

    /// <summary>
    /// Gets or sets the money group.
    /// </summary>
    public byte MoneyGroup
    {
        get => this._data[14..].GetByteValue(8, 4);
        set => this._data[14..].SetByteValue(value, 8, 4);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MoneyDropped"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MoneyDroppedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MoneyDropped"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MoneyDroppedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Money dropped on the ground.
/// Causes reaction on client side: The client adds the money to the ground.
/// </summary>
public readonly ref partial struct MoneyDropped075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MoneyDropped075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MoneyDropped075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MoneyDropped075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MoneyDropped075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)Math.Min(data.Length, Length);
            this.ItemCount = 1;
            this.MoneyNumber = 15;
            this.MoneyGroup = 14;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x20;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets if this flag is set, the money is added to the map with an animation and sound. Otherwise it's just added like it was already on the ground before.
    /// </summary>
    public bool IsFreshDrop
    {
        get => this._data[5..].GetBoolean(7);
        set => this._data[5..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the money number.
    /// </summary>
    public byte MoneyNumber
    {
        get => this._data[9..].GetByteValue(4, 0);
        set => this._data[9..].SetByteValue(value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the money group.
    /// </summary>
    public byte MoneyGroup
    {
        get => this._data[9..].GetByteValue(4, 4);
        set => this._data[9..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MoneyDropped075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MoneyDropped075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MoneyDropped075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MoneyDropped075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A dropped item was removed from the ground of the map, e.g. when it timed out or was picked up.
/// Causes reaction on client side: The client removes the item from the ground of the map.
/// </summary>
public readonly ref struct ItemDropRemovedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemDropRemovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemDropRemovedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemDropRemovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemDropRemovedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x21;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="DroppedItemIdRef"/> of the specified index.
    /// </summary>
        public DroppedItemIdRef this[int index] => new (this._data[(5 + index * DroppedItemIdRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemDropRemoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemDropRemovedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemDropRemoved"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemDropRemovedRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="DroppedItemIdRef"/>.
    /// </summary>
    /// <param name="itemDataCount">The count of <see cref="DroppedItemIdRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int itemDataCount) => itemDataCount * DroppedItemIdRef.Length + 5;


/// <summary>
/// Contains the id of a dropped item..
/// </summary>
public readonly ref struct DroppedItemIdRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DroppedItemIdRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DroppedItemIdRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 2;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }
}
}


/// <summary>
/// Is sent by the server when: A new item was added to the inventory.
/// Causes reaction on client side: The client adds the item to the inventory user interface.
/// </summary>
public readonly ref struct ItemAddedToInventoryRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemAddedToInventoryRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemAddedToInventoryRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemAddedToInventoryRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemAddedToInventoryRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x22;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(4);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemAddedToInventory"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemAddedToInventoryRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemAddedToInventory"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemAddedToInventoryRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
}


/// <summary>
/// Is sent by the server when: The player requested to drop an item of his inventory. This message is the response about the success of the request.
/// Causes reaction on client side: If successful, the client removes the item from the inventory user interface.
/// </summary>
public readonly ref struct ItemDropResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemDropResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemDropResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemDropResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemDropResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x23;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemDropResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemDropResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemDropResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemDropResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to pick up an item from to ground to add it to his inventory, but it failed.
/// Causes reaction on client side: Depending on the reason, the game client shows a message.
/// </summary>
public readonly ref struct ItemPickUpRequestFailedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemPickUpRequestFailedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemPickUpRequestFailedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemPickUpRequestFailedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemPickUpRequestFailedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x22;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the fail reason.
    /// </summary>
    public ItemPickUpRequestFailed.ItemPickUpFailReason FailReason
    {
        get => (ItemPickUpRequestFailed.ItemPickUpFailReason)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemPickUpRequestFailed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemPickUpRequestFailedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemPickUpRequestFailed"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemPickUpRequestFailedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The players money amount of the inventory has been changed and needs an update.
/// Causes reaction on client side: The money is updated in the inventory user interface.
/// </summary>
public readonly ref struct InventoryMoneyUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="InventoryMoneyUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public InventoryMoneyUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="InventoryMoneyUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private InventoryMoneyUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x22;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFE;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32BigEndian(this._data[4..]);
        set => WriteUInt32BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="InventoryMoneyUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator InventoryMoneyUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="InventoryMoneyUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(InventoryMoneyUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An item in the inventory or vault of the player has been moved.
/// Causes reaction on client side: The client updates the position of item in the user interface.
/// </summary>
public readonly ref struct ItemMovedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemMovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemMovedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemMovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemMovedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x24;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the target storage type.
    /// </summary>
    public ItemStorageKind TargetStorageType
    {
        get => (ItemStorageKind)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the target slot.
    /// </summary>
    public byte TargetSlot
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(5);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemMoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemMovedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemMoved"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemMovedRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
}


/// <summary>
/// Is sent by the server when: An item in the inventory or vault of the player could not be moved as requested by the player.
/// Causes reaction on client side: The client restores the position of item in the user interface.
/// </summary>
public readonly ref struct ItemMoveRequestFailedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemMoveRequestFailedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemMoveRequestFailedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemMoveRequestFailedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemMoveRequestFailedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x24;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFF;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(5);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemMoveRequestFailed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemMoveRequestFailedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemMoveRequestFailed"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemMoveRequestFailedRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
}


/// <summary>
/// Is sent by the server when: Periodically, or if the current health or shield changed on the server side, e.g. by hits.
/// Causes reaction on client side: The health and shield bar is updated on the game client user interface.
/// </summary>
public readonly ref struct CurrentHealthAndShieldRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CurrentHealthAndShieldRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CurrentHealthAndShieldRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CurrentHealthAndShieldRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CurrentHealthAndShieldRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x26;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFF;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the health.
    /// </summary>
    public ushort Health
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the shield.
    /// </summary>
    public ushort Shield
    {
        get => ReadUInt16BigEndian(this._data[7..]);
        set => WriteUInt16BigEndian(this._data[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CurrentHealthAndShield"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CurrentHealthAndShieldRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CurrentHealthAndShield"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CurrentHealthAndShieldRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the maximum health changed, e.g. by adding stat points or changed items.
/// Causes reaction on client side: The health and shield bar is updated on the game client user interface.
/// </summary>
public readonly ref struct MaximumHealthAndShieldRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MaximumHealthAndShieldRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MaximumHealthAndShieldRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MaximumHealthAndShieldRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MaximumHealthAndShieldRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x26;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFE;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the health.
    /// </summary>
    public ushort Health
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the shield.
    /// </summary>
    public ushort Shield
    {
        get => ReadUInt16BigEndian(this._data[7..]);
        set => WriteUInt16BigEndian(this._data[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MaximumHealthAndShield"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MaximumHealthAndShieldRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MaximumHealthAndShield"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MaximumHealthAndShieldRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the consumption of an item failed.
/// Causes reaction on client side: The game client gets a feedback about a failed consumption, and allows for do further consumption requests.
/// </summary>
public readonly ref struct ItemConsumptionFailedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemConsumptionFailedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemConsumptionFailedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemConsumptionFailedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemConsumptionFailedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x26;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFD;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the health.
    /// </summary>
    public ushort Health
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the shield.
    /// </summary>
    public ushort Shield
    {
        get => ReadUInt16BigEndian(this._data[7..]);
        set => WriteUInt16BigEndian(this._data[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemConsumptionFailed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemConsumptionFailedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemConsumptionFailed"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemConsumptionFailedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The currently available mana or ability has changed, e.g. by using a skill.
/// Causes reaction on client side: The mana and ability bar is updated on the game client user interface.
/// </summary>
public readonly ref struct CurrentManaAndAbilityRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CurrentManaAndAbilityRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CurrentManaAndAbilityRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CurrentManaAndAbilityRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CurrentManaAndAbilityRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x27;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFF;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the mana.
    /// </summary>
    public ushort Mana
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the ability.
    /// </summary>
    public ushort Ability
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CurrentManaAndAbility"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CurrentManaAndAbilityRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CurrentManaAndAbility"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CurrentManaAndAbilityRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The maximum available mana or ability has changed, e.g. by adding stat points.
/// Causes reaction on client side: The mana and ability bar is updated on the game client user interface.
/// </summary>
public readonly ref struct MaximumManaAndAbilityRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MaximumManaAndAbilityRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MaximumManaAndAbilityRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MaximumManaAndAbilityRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MaximumManaAndAbilityRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x27;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFE;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the mana.
    /// </summary>
    public ushort Mana
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the ability.
    /// </summary>
    public ushort Ability
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MaximumManaAndAbility"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MaximumManaAndAbilityRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MaximumManaAndAbility"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MaximumManaAndAbilityRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The item has been removed from the inventory of the player.
/// Causes reaction on client side: The client removes the item in the inventory user interface.
/// </summary>
public readonly ref struct ItemRemovedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemRemovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemRemovedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemRemovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemRemovedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.TrueFlag = 1;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x28;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the affected slot of the item in the inventory.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the true flag.
    /// </summary>
    public byte TrueFlag
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemRemoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemRemovedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemRemoved"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemRemovedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The client requested to consume a special item, e.g. a bottle of Ale.
/// Causes reaction on client side: The player is shown in a red color and has increased attack speed.
/// </summary>
public readonly ref struct ConsumeItemWithEffectRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ConsumeItemWithEffectRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ConsumeItemWithEffectRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ConsumeItemWithEffectRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ConsumeItemWithEffectRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x29;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the item type.
    /// </summary>
    public ConsumeItemWithEffect.ConsumedItemType ItemType
    {
        get => (ConsumeItemWithEffect.ConsumedItemType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the effect time in seconds.
    /// </summary>
    public ushort EffectTimeInSeconds
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ConsumeItemWithEffect"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ConsumeItemWithEffectRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ConsumeItemWithEffect"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ConsumeItemWithEffectRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The durability of an item in the inventory of the player has been changed.
/// Causes reaction on client side: The client updates the item in the inventory user interface.
/// </summary>
public readonly ref struct ItemDurabilityChangedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemDurabilityChangedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemDurabilityChangedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemDurabilityChangedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemDurabilityChangedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x2A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the durability.
    /// </summary>
    public byte Durability
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets true, if the change resulted from an item consumption; otherwise, false
    /// </summary>
    public bool ByConsumption
    {
        get => this._data[5..].GetBoolean();
        set => this._data[5..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemDurabilityChanged"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemDurabilityChangedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemDurabilityChanged"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemDurabilityChangedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to consume a fruit.
/// Causes reaction on client side: The client updates the user interface, by changing the added stat points and used fruit points.
/// </summary>
public readonly ref struct FruitConsumptionResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FruitConsumptionResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FruitConsumptionResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FruitConsumptionResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FruitConsumptionResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x2C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public FruitConsumptionResponse.FruitConsumptionResult Result
    {
        get => (FruitConsumptionResponse.FruitConsumptionResult)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the stat points.
    /// </summary>
    public ushort StatPoints
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the stat type.
    /// </summary>
    public FruitConsumptionResponse.FruitStatType StatType
    {
        get => (FruitConsumptionResponse.FruitStatType)this._data[6];
        set => this._data[6] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="FruitConsumptionResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FruitConsumptionResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FruitConsumptionResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(FruitConsumptionResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to consume an item which gives a magic effect.
/// Causes reaction on client side: The client updates the user interface, it shows the remaining time at the effect icon.
/// </summary>
public readonly ref struct EffectItemConsumptionRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EffectItemConsumptionRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EffectItemConsumptionRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="EffectItemConsumptionRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private EffectItemConsumptionRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x2D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 17;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the origin.
    /// </summary>
    public EffectItemConsumption.EffectOrigin Origin
    {
        get => (EffectItemConsumption.EffectOrigin)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public EffectItemConsumption.EffectType Type
    {
        get => (EffectItemConsumption.EffectType)this._data[6];
        set => this._data[6] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the action.
    /// </summary>
    public EffectItemConsumption.EffectAction Action
    {
        get => (EffectItemConsumption.EffectAction)this._data[8];
        set => this._data[8] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the remaining seconds.
    /// </summary>
    public uint RemainingSeconds
    {
        get => ReadUInt32LittleEndian(this._data[12..]);
        set => WriteUInt32LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the magic effect number.
    /// </summary>
    public byte MagicEffectNumber
    {
        get => this._data[16];
        set => this._data[16] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="EffectItemConsumption"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator EffectItemConsumptionRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="EffectItemConsumption"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(EffectItemConsumptionRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the client talked to an NPC which should cause a dialog to open on the client side.
/// Causes reaction on client side: The client opens the specified dialog.
/// </summary>
public readonly ref struct NpcWindowResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcWindowResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcWindowResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcWindowResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private NpcWindowResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x30;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 11;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the window.
    /// </summary>
    public NpcWindowResponse.NpcWindow Window
    {
        get => (NpcWindowResponse.NpcWindow)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="NpcWindowResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator NpcWindowResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="NpcWindowResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(NpcWindowResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player opens a merchant npc or the vault. It's sent after the dialog was opened by another message.
/// Causes reaction on client side: The client shows the items in the opened dialog.
/// </summary>
public readonly ref struct StoreItemListRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="StoreItemListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public StoreItemListRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="StoreItemListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private StoreItemListRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x31;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public StoreItemList.ItemWindow Type
    {
        get => (StoreItemList.ItemWindow)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets the <see cref="StoredItemRef"/> of the specified index.
    /// </summary>
        public StoredItemRef this[int index, int storedItemLength] => new (this._data[(6 + index * storedItemLength)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="StoreItemList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator StoreItemListRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="StoreItemList"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(StoreItemListRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="StoredItemRef"/> and it's size.
    /// </summary>
    /// <param name="itemsCount">The count of <see cref="StoredItemRef"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="StoredItemRef"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 6;
}


/// <summary>
/// Is sent by the server when: The request of buying an item from a NPC failed.
/// Causes reaction on client side: The client is responsive again. Without this message, it may stuck.
/// </summary>
public readonly ref struct NpcItemBuyFailedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcItemBuyFailedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcItemBuyFailedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcItemBuyFailedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private NpcItemBuyFailedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x32;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFF;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="NpcItemBuyFailed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator NpcItemBuyFailedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="NpcItemBuyFailed"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(NpcItemBuyFailedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The request of buying an item from a player or npc was successful.
/// Causes reaction on client side: The bought item is added to the inventory.
/// </summary>
public readonly ref struct ItemBoughtRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemBoughtRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemBoughtRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemBoughtRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemBoughtRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x32;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(4);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemBought"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemBoughtRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemBought"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemBoughtRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
}


/// <summary>
/// Is sent by the server when: The result of a previous item sell request.
/// Causes reaction on client side: The amount of specified money is set at the players inventory.
/// </summary>
public readonly ref struct NpcItemSellResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcItemSellResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcItemSellResultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcItemSellResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private NpcItemSellResultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x33;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="NpcItemSellResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator NpcItemSellResultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="NpcItemSellResult"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(NpcItemSellResultRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to set a price for an item of the players shop.
/// Causes reaction on client side: The item gets a price on the user interface.
/// </summary>
public readonly ref struct PlayerShopSetItemPriceResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopSetItemPriceResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopSetItemPriceResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopSetItemPriceResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopSetItemPriceResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public PlayerShopSetItemPriceResponse.ItemPriceSetResult Result
    {
        get => (PlayerShopSetItemPriceResponse.ItemPriceSetResult)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopSetItemPriceResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopSetItemPriceResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopSetItemPriceResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayerShopSetItemPriceResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a player in scope requested to close his shop or after all items has been sold.
/// Causes reaction on client side: The player shop not shown as open anymore.
/// </summary>
public readonly ref struct PlayerShopClosedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopClosedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopClosedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopClosedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopClosedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Success = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x3;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopClosed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopClosedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopClosed"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayerShopClosedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An item of the players shop was sold to another player.
/// Causes reaction on client side: The item is removed from the players inventory and a blue system message appears.
/// </summary>
public readonly ref struct PlayerShopItemSoldToPlayerRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemSoldToPlayerRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopItemSoldToPlayerRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemSoldToPlayerRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopItemSoldToPlayerRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x08;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 15;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the buyer name.
    /// </summary>
    public string BuyerName
    {
        get => this._data.ExtractString(5, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(5, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopItemSoldToPlayer"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopItemSoldToPlayerRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopItemSoldToPlayer"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayerShopItemSoldToPlayerRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to close his shop or after all items has been sold.
/// Causes reaction on client side: The player shop dialog is closed for the shop of the specified player.
/// </summary>
public readonly ref struct ClosePlayerShopDialogRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ClosePlayerShopDialogRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ClosePlayerShopDialogRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ClosePlayerShopDialogRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ClosePlayerShopDialogRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x12;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ClosePlayerShopDialog"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ClosePlayerShopDialogRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ClosePlayerShopDialog"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ClosePlayerShopDialogRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to open a shop of another player.
/// Causes reaction on client side: The player shop dialog is shown with the provided item data.
/// </summary>
public readonly ref struct PlayerShopItemListRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopItemListRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopItemListRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
            header.SubCode = SubCode;
            this.Success = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the action.
    /// </summary>
    public PlayerShopItemList.ActionKind Action
    {
        get => (PlayerShopItemList.ActionKind)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[5..].GetBoolean();
        set => this._data[5..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.ExtractString(8, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(8, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the shop name.
    /// </summary>
    public string ShopName
    {
        get => this._data.ExtractString(18, 36, System.Text.Encoding.UTF8);
        set => this._data.Slice(18, 36).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data[54];
        set => this._data[54] = value;
    }

    /// <summary>
    /// Gets the <see cref="PlayerShopItemRef"/> of the specified index.
    /// </summary>
        public PlayerShopItemRef this[int index] => new (this._data[(55 + index * PlayerShopItemRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopItemList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopItemListRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopItemList"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayerShopItemListRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PlayerShopItemRef"/>.
    /// </summary>
    /// <param name="itemsCount">The count of <see cref="PlayerShopItemRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int itemsCount) => itemsCount * PlayerShopItemRef.Length + 55;
}


/// <summary>
/// Is sent by the server when: After the player gets into scope of a player with an opened shop.
/// Causes reaction on client side: The player shop title is shown at the specified players.
/// </summary>
public readonly ref struct PlayerShopsRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopsRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopsRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopsRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopsRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the shop count.
    /// </summary>
    public byte ShopCount
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets the <see cref="PlayerShopRef"/> of the specified index.
    /// </summary>
        public PlayerShopRef this[int index] => new (this._data[(6 + index * PlayerShopRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShops"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopsRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShops"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayerShopsRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PlayerShopRef"/>.
    /// </summary>
    /// <param name="shopsCount">The count of <see cref="PlayerShopRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int shopsCount) => shopsCount * PlayerShopRef.Length + 6;


/// <summary>
/// Data of the shop of a player..
/// </summary>
public readonly ref struct PlayerShopRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 38;

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the store name.
    /// </summary>
    public string StoreName
    {
        get => this._data.ExtractString(2, 36, System.Text.Encoding.UTF8);
        set => this._data.Slice(2, 36).WriteString(value, System.Text.Encoding.UTF8);
    }
}
}


/// <summary>
/// Is sent by the server when: The player wears a monster transformation ring.
/// Causes reaction on client side: The character appears as monster, defined by the Skin property.
/// </summary>
public readonly ref struct AddTransformedCharactersToScope075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddTransformedCharactersToScope075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddTransformedCharactersToScope075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddTransformedCharactersToScope075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddTransformedCharactersToScope075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x45;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="CharacterDataRef"/> of the specified index.
    /// </summary>
        public CharacterDataRef this[int index] => new (this._data[(5 + index * CharacterDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddTransformedCharactersToScope075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddTransformedCharactersToScope075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddTransformedCharactersToScope075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddTransformedCharactersToScope075Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterDataRef"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterDataRef.Length + 5;


/// <summary>
/// Contains the data of an transformed character..
/// </summary>
public readonly ref struct CharacterDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 19;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the skin.
    /// </summary>
    public byte Skin
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data[5..].GetBoolean(0);
        set => this._data[5..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data[5..].GetBoolean(1);
        set => this._data[5..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data[5..].GetBoolean(2);
        set => this._data[5..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data[5..].GetBoolean(3);
        set => this._data[5..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data[16];
        set => this._data[16] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data[17];
        set => this._data[17] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[18..].GetByteValue(4, 4);
        set => this._data[18..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data[18..].GetByteValue(4, 0);
        set => this._data[18..].SetByteValue((byte)value, 4, 0);
    }
}
}


/// <summary>
/// Is sent by the server when: The player wears a monster transformation ring.
/// Causes reaction on client side: The character appears as monster, defined by the Skin property.
/// </summary>
public readonly ref partial struct AddTransformedCharactersToScopeRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddTransformedCharactersToScopeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddTransformedCharactersToScopeRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddTransformedCharactersToScopeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddTransformedCharactersToScopeRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x45;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddTransformedCharactersToScope"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddTransformedCharactersToScopeRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddTransformedCharactersToScope"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddTransformedCharactersToScopeRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterDataRef"/> and it's size.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterDataRef"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="CharacterDataRef"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int charactersCount, int structLength) => charactersCount * structLength + 5;


/// <summary>
/// Contains the data of an transformed character..
/// </summary>
public readonly ref struct CharacterDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the skin.
    /// </summary>
    public ushort Skin
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data[16];
        set => this._data[16] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data[17];
        set => this._data[17] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[18..].GetByteValue(4, 4);
        set => this._data[18..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data[18..].GetByteValue(4, 0);
        set => this._data[18..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(19, 18);
    }

    /// <summary>
    /// Gets or sets defines the number of effects which would be sent after this field.
    /// </summary>
    public byte EffectCount
    {
        get => this._data[37];
        set => this._data[37] = value;
    }

    /// <summary>
    /// Gets the <see cref="EffectIdRef"/> of the specified index.
    /// </summary>
        public EffectIdRef this[int index] => new (this._data[(38 + index * EffectIdRef.Length)..]);

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="EffectIdRef"/>.
    /// </summary>
    /// <param name="effectsCount">The count of <see cref="EffectIdRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int effectsCount) => effectsCount * EffectIdRef.Length + 38;
}


/// <summary>
/// Contains the id of a magic effect..
/// </summary>
public readonly ref struct EffectIdRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EffectIdRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EffectIdRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 1;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public byte Id
    {
        get => this._data[0];
        set => this._data[0] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: The server wants to alter the terrain attributes of a map at runtime.
/// Causes reaction on client side: The client updates the terrain attributes on its side.
/// </summary>
public readonly ref struct ChangeTerrainAttributesRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChangeTerrainAttributesRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChangeTerrainAttributesRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChangeTerrainAttributesRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChangeTerrainAttributesRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            this.Type = false;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x46;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public bool Type
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the attribute.
    /// </summary>
    public ChangeTerrainAttributes.TerrainAttributeType Attribute
    {
        get => (ChangeTerrainAttributes.TerrainAttributeType)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets when this is true, the attribute is removed on the client side. If it's false, then the attribute is added.
    /// </summary>
    public bool RemoveAttribute
    {
        get => this._data[5..].GetBoolean();
        set => this._data[5..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the area count.
    /// </summary>
    public byte AreaCount
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets the <see cref="TerrainAreaRef"/> of the specified index.
    /// </summary>
        public TerrainAreaRef this[int index] => new (this._data[(7 + index * TerrainAreaRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ChangeTerrainAttributes"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChangeTerrainAttributesRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChangeTerrainAttributes"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ChangeTerrainAttributesRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="TerrainAreaRef"/>.
    /// </summary>
    /// <param name="areasCount">The count of <see cref="TerrainAreaRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int areasCount) => areasCount * TerrainAreaRef.Length + 7;


/// <summary>
/// Defines the area which should be changed..
/// </summary>
public readonly ref struct TerrainAreaRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TerrainAreaRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TerrainAreaRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets or sets the start x.
    /// </summary>
    public byte StartX
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the start y.
    /// </summary>
    public byte StartY
    {
        get => this._data[1];
        set => this._data[1] = value;
    }

    /// <summary>
    /// Gets or sets the end x.
    /// </summary>
    public byte EndX
    {
        get => this._data[2];
        set => this._data[2] = value;
    }

    /// <summary>
    /// Gets or sets the end y.
    /// </summary>
    public byte EndY
    {
        get => this._data[3];
        set => this._data[3] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: After a player achieved or lost something.
/// Causes reaction on client side: An effect is shown for the affected player.
/// </summary>
public readonly ref struct ShowEffectRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowEffectRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ShowEffectRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowEffectRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ShowEffectRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x48;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the effect.
    /// </summary>
    public ShowEffect.EffectType Effect
    {
        get => (ShowEffect.EffectType)this._data[5];
        set => this._data[5] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ShowEffect"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ShowEffectRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ShowEffect"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ShowEffectRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the game client requested it, usually after a successful login.
/// Causes reaction on client side: The game client shows the available characters of the account.
/// </summary>
public readonly ref struct CharacterListRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterListRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterListRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the unlock flags.
    /// </summary>
    public CharacterCreationUnlockFlags UnlockFlags
    {
        get => (CharacterCreationUnlockFlags)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the move cnt.
    /// </summary>
    public byte MoveCnt
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the is vault extended.
    /// </summary>
    public bool IsVaultExtended
    {
        get => this._data[7..].GetBoolean();
        set => this._data[7..].SetBoolean(value);
    }

    /// <summary>
    /// Gets the <see cref="CharacterDataRef"/> of the specified index.
    /// </summary>
        public CharacterDataRef this[int index] => new (this._data[(8 + index * CharacterDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterListRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterList"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterListRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterDataRef"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterDataRef.Length + 8;


/// <summary>
/// Data of one character in the list..
/// </summary>
public readonly ref struct CharacterDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 34;

    /// <summary>
    /// Gets or sets the slot index.
    /// </summary>
    public byte SlotIndex
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(1, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(1, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public ushort Level
    {
        get => ReadUInt16LittleEndian(this._data[12..]);
        set => WriteUInt16LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data[14..].GetByteValue(4, 0);
        set => this._data[14..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the is item block active.
    /// </summary>
    public bool IsItemBlockActive
    {
        get => this._data[14..].GetBoolean(4);
        set => this._data[14..].SetBoolean(value, 4);
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(15, 18);
    }

    /// <summary>
    /// Gets or sets the guild position.
    /// </summary>
    public GuildMemberRole GuildPosition
    {
        get => (GuildMemberRole)this._data[33];
        set => this._data[33] = (byte)value;
    }
}
}


/// <summary>
/// Is sent by the server when: It's send right after the CharacterList, in the character selection screen, if the account has any unlocked character classes.
/// Causes reaction on client side: The client unlocks the specified character classes, so they can be created.
/// </summary>
public readonly ref struct CharacterClassCreationUnlockRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterClassCreationUnlockRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterClassCreationUnlockRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterClassCreationUnlockRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterClassCreationUnlockRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xDE;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the unlock flags.
    /// </summary>
    public CharacterCreationUnlockFlags UnlockFlags
    {
        get => (CharacterCreationUnlockFlags)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterClassCreationUnlock"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterClassCreationUnlockRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterClassCreationUnlock"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterClassCreationUnlockRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the game client requested it, usually after a successful login.
/// Causes reaction on client side: The game client shows the available characters of the account.
/// </summary>
public readonly ref struct CharacterList075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterList075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterList075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterList075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterList075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="CharacterDataRef"/> of the specified index.
    /// </summary>
        public CharacterDataRef this[int index] => new (this._data[(5 + index * CharacterDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterList075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterList075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterList075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterList075Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterDataRef"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterDataRef.Length + 5;


/// <summary>
/// Data of one character in the list..
/// </summary>
public readonly ref struct CharacterDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets or sets the slot index.
    /// </summary>
    public byte SlotIndex
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(1, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(1, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public ushort Level
    {
        get => ReadUInt16BigEndian(this._data[11..]);
        set => WriteUInt16BigEndian(this._data[11..], value);
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data[13..].GetByteValue(4, 0);
        set => this._data[13..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the is item block active.
    /// </summary>
    public bool IsItemBlockActive
    {
        get => this._data[13..].GetBoolean(4);
        set => this._data[13..].SetBoolean(value, 4);
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(14, 9);
    }
}
}


/// <summary>
/// Is sent by the server when: After the game client requested it, usually after a successful login.
/// Causes reaction on client side: The game client shows the available characters of the account.
/// </summary>
public readonly ref struct CharacterList095Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterList095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterList095Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterList095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterList095Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="CharacterDataRef"/> of the specified index.
    /// </summary>
        public CharacterDataRef this[int index] => new (this._data[(5 + index * CharacterDataRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterList095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterList095Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterList095"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterList095Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterDataRef"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterDataRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterDataRef.Length + 5;


/// <summary>
/// Data of one character in the list..
/// </summary>
public readonly ref struct CharacterDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterDataRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 26;

    /// <summary>
    /// Gets or sets the slot index.
    /// </summary>
    public byte SlotIndex
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(1, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(1, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public ushort Level
    {
        get => ReadUInt16LittleEndian(this._data[12..]);
        set => WriteUInt16LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data[14..].GetByteValue(4, 0);
        set => this._data[14..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the is item block active.
    /// </summary>
    public bool IsItemBlockActive
    {
        get => this._data[14..].GetBoolean(4);
        set => this._data[14..].SetBoolean(value, 4);
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(15, 11);
    }
}
}


/// <summary>
/// Is sent by the server when: After the server successfully processed a character creation request.
/// Causes reaction on client side: The new character is shown in the character list
/// </summary>
public readonly ref struct CharacterCreationSuccessfulRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterCreationSuccessfulRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterCreationSuccessfulRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterCreationSuccessfulRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterCreationSuccessfulRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Success = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 42;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the character name.
    /// </summary>
    public string CharacterName
    {
        get => this._data.ExtractString(5, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(5, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the character slot.
    /// </summary>
    public byte CharacterSlot
    {
        get => this._data[15];
        set => this._data[15] = value;
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public ushort Level
    {
        get => ReadUInt16LittleEndian(this._data[16..]);
        set => WriteUInt16LittleEndian(this._data[16..], value);
    }

    /// <summary>
    /// Gets or sets the class.
    /// </summary>
    public CharacterClassNumber Class
    {
        get => (CharacterClassNumber)this._data[18..].GetByteValue(8, 3);
        set => this._data[18..].SetByteValue((byte)value, 8, 3);
    }

    /// <summary>
    /// Gets or sets the character status.
    /// </summary>
    public byte CharacterStatus
    {
        get => this._data[19];
        set => this._data[19] = value;
    }

    /// <summary>
    /// Gets or sets the preview data.
    /// </summary>
    public Span<byte> PreviewData
    {
        get => this._data.Slice(20);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterCreationSuccessful"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterCreationSuccessfulRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterCreationSuccessful"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterCreationSuccessfulRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="PreviewData"/>.
    /// </summary>
    /// <param name="previewDataLength">The length in bytes of <see cref="PreviewData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int previewDataLength) => previewDataLength + 20;
}


/// <summary>
/// Is sent by the server when: After the server processed a character creation request without success.
/// Causes reaction on client side: A message is shown that it failed. 
/// </summary>
public readonly ref struct CharacterCreationFailedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterCreationFailedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterCreationFailedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterCreationFailedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterCreationFailedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterCreationFailed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterCreationFailedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterCreationFailed"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterCreationFailedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The character respawned after death.
/// Causes reaction on client side: The character respawns with the specified attributes at the specified map.
/// </summary>
public readonly ref struct RespawnAfterDeath075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RespawnAfterDeath075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RespawnAfterDeath075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RespawnAfterDeath075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RespawnAfterDeath075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x04;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 20;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public byte MapNumber
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the direction.
    /// </summary>
    public byte Direction
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public ushort CurrentHealth
    {
        get => ReadUInt16LittleEndian(this._data[8..]);
        set => WriteUInt16LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the current mana.
    /// </summary>
    public ushort CurrentMana
    {
        get => ReadUInt16LittleEndian(this._data[10..]);
        set => WriteUInt16LittleEndian(this._data[10..], value);
    }

    /// <summary>
    /// Gets or sets the experience.
    /// </summary>
    public uint Experience
    {
        get => ReadUInt32LittleEndian(this._data[12..]);
        set => WriteUInt32LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data[16..]);
        set => WriteUInt32LittleEndian(this._data[16..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RespawnAfterDeath075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RespawnAfterDeath075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RespawnAfterDeath075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RespawnAfterDeath075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The character respawned after death.
/// Causes reaction on client side: The character respawns with the specified attributes at the specified map.
/// </summary>
public readonly ref struct RespawnAfterDeath095Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RespawnAfterDeath095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RespawnAfterDeath095Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RespawnAfterDeath095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RespawnAfterDeath095Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x04;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 22;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public byte MapNumber
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the direction.
    /// </summary>
    public byte Direction
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public ushort CurrentHealth
    {
        get => ReadUInt16LittleEndian(this._data[8..]);
        set => WriteUInt16LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the current mana.
    /// </summary>
    public ushort CurrentMana
    {
        get => ReadUInt16LittleEndian(this._data[10..]);
        set => WriteUInt16LittleEndian(this._data[10..], value);
    }

    /// <summary>
    /// Gets or sets the current ability.
    /// </summary>
    public ushort CurrentAbility
    {
        get => ReadUInt16LittleEndian(this._data[12..]);
        set => WriteUInt16LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the experience.
    /// </summary>
    public uint Experience
    {
        get => ReadUInt32LittleEndian(this._data[14..]);
        set => WriteUInt32LittleEndian(this._data[14..], value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data[18..]);
        set => WriteUInt32LittleEndian(this._data[18..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RespawnAfterDeath095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RespawnAfterDeath095Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RespawnAfterDeath095"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RespawnAfterDeath095Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The character got damaged by being poisoned on old client versions.
/// Causes reaction on client side: Removes the damage from the health without showing a damage number.
/// </summary>
public readonly ref struct PoisonDamageRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PoisonDamageRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PoisonDamageRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PoisonDamageRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PoisonDamageRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the health damage.
    /// </summary>
    public ushort HealthDamage
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the current shield.
    /// </summary>
    public ushort CurrentShield
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PoisonDamage"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PoisonDamageRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PoisonDamage"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PoisonDamageRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a the hero state of an observed character changed.
/// Causes reaction on client side: The color of the name of the character is changed accordingly and a message is shown.
/// </summary>
public readonly ref struct HeroStateChangedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="HeroStateChangedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public HeroStateChangedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="HeroStateChangedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private HeroStateChangedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x08;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the new state.
    /// </summary>
    public CharacterHeroState NewState
    {
        get => (CharacterHeroState)this._data[6];
        set => this._data[6] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="HeroStateChanged"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator HeroStateChangedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="HeroStateChanged"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(HeroStateChangedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
/// Causes reaction on client side: The skill is added to the skill list on client side.
/// </summary>
public readonly ref struct SkillAddedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAddedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillAddedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAddedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillAddedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Flag = 0xFE;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag.
    /// </summary>
    public byte Flag
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16LittleEndian(this._data[7..]);
        set => WriteUInt16LittleEndian(this._data[7..], value);
    }

    /// <summary>
    /// Gets or sets the skill level.
    /// </summary>
    public byte SkillLevel
    {
        get => this._data[9];
        set => this._data[9] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAdded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillAddedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillAdded"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SkillAddedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
/// Causes reaction on client side: The skill is added to the skill list on client side.
/// </summary>
public readonly ref struct SkillRemovedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillRemovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillRemovedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillRemovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillRemovedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Flag = 0xFF;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag.
    /// </summary>
    public byte Flag
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16LittleEndian(this._data[7..]);
        set => WriteUInt16LittleEndian(this._data[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillRemoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillRemovedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillRemoved"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SkillRemovedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Usually, when the player entered the game with a character. When skills get added or removed, this message is sent as well, but with a misleading count.
/// Causes reaction on client side: The skill list gets initialized.
/// </summary>
public readonly ref struct SkillListUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillListUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillListUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillListUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillListUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets mixed usage: Skill list count (when list). 0xFE when adding a skill, 0xFF when removing a Skill.
    /// </summary>
    public byte Count
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="SkillEntryRef"/> of the specified index.
    /// </summary>
        public SkillEntryRef this[int index] => new (this._data[(6 + index * SkillEntryRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillListUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillListUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillListUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SkillListUpdateRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="SkillEntryRef"/>.
    /// </summary>
    /// <param name="skillsCount">The count of <see cref="SkillEntryRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int skillsCount) => skillsCount * SkillEntryRef.Length + 6;


/// <summary>
/// Structure for a skill entry of the skill list..
/// </summary>
public readonly ref struct SkillEntryRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillEntryRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillEntryRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16LittleEndian(this._data[1..]);
        set => WriteUInt16LittleEndian(this._data[1..], value);
    }

    /// <summary>
    /// Gets or sets the skill level.
    /// </summary>
    public byte SkillLevel
    {
        get => this._data[3];
        set => this._data[3] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
/// Causes reaction on client side: The skill is added to the skill list on client side.
/// </summary>
public readonly ref struct SkillAdded075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAdded075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillAdded075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAdded075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillAdded075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Flag = 1;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag.
    /// </summary>
    public byte Flag
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the skill number and level.
    /// </summary>
    public ushort SkillNumberAndLevel
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAdded075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillAdded075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillAdded075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SkillAdded075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
/// Causes reaction on client side: The skill is added to the skill list on client side.
/// </summary>
public readonly ref struct SkillRemoved075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillRemoved075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillRemoved075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillRemoved075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillRemoved075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Flag = 0;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag.
    /// </summary>
    public byte Flag
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the skill number and level.
    /// </summary>
    public ushort SkillNumberAndLevel
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillRemoved075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillRemoved075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillRemoved075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SkillRemoved075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
/// Causes reaction on client side: The skill is added to the skill list on client side.
/// </summary>
public readonly ref struct SkillAdded095Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAdded095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillAdded095Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAdded095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillAdded095Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Flag = 0xFE;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag.
    /// </summary>
    public byte Flag
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the skill number and level.
    /// </summary>
    public ushort SkillNumberAndLevel
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAdded095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillAdded095Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillAdded095"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SkillAdded095Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
/// Causes reaction on client side: The skill is added to the skill list on client side.
/// </summary>
public readonly ref struct SkillRemoved095Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillRemoved095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillRemoved095Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillRemoved095Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillRemoved095Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Flag = 0xFF;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag.
    /// </summary>
    public byte Flag
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the skill number and level.
    /// </summary>
    public ushort SkillNumberAndLevel
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillRemoved095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillRemoved095Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillRemoved095"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SkillRemoved095Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Usually, when the player entered the game with a character. When skills get added or removed, this message is sent as well, but with a misleading count.
/// Causes reaction on client side: The skill list gets initialized.
/// </summary>
public readonly ref struct SkillListUpdate075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillListUpdate075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillListUpdate075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillListUpdate075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillListUpdate075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets mixed usage: Skill list count (when list). 0xFE when adding a skill, 0xFF when removing a Skill.
    /// </summary>
    public byte Count
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="SkillEntryRef"/> of the specified index.
    /// </summary>
        public SkillEntryRef this[int index] => new (this._data[(5 + index * SkillEntryRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillListUpdate075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillListUpdate075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillListUpdate075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SkillListUpdate075Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="SkillEntryRef"/>.
    /// </summary>
    /// <param name="skillsCount">The count of <see cref="SkillEntryRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int skillsCount) => skillsCount * SkillEntryRef.Length + 5;


/// <summary>
/// Structure for a skill entry of the skill list..
/// </summary>
public readonly ref struct SkillEntryRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillEntryRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillEntryRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the skill number and level.
    /// </summary>
    public ushort SkillNumberAndLevel
    {
        get => ReadUInt16BigEndian(this._data[1..]);
        set => WriteUInt16BigEndian(this._data[1..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: After the client focused the character successfully on the server side.
/// Causes reaction on client side: The client highlights the focused character.
/// </summary>
public readonly ref struct CharacterFocusedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterFocusedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterFocusedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterFocusedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterFocusedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x15;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 15;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the character name.
    /// </summary>
    public string CharacterName
    {
        get => this._data.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterFocused"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterFocusedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterFocused"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterFocusedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the server processed a character stat increase request packet.
/// Causes reaction on client side: If it was successful, adds a point to the requested stat type.
/// </summary>
public readonly ref struct CharacterStatIncreaseResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterStatIncreaseResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterStatIncreaseResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x06;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[4..].GetBoolean(4);
        set => this._data[4..].SetBoolean(value, 4);
    }

    /// <summary>
    /// Gets or sets the attribute.
    /// </summary>
    public CharacterStatAttribute Attribute
    {
        get => (CharacterStatAttribute)this._data[4..].GetByteValue(4, 0);
        set => this._data[4..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the updated dependent maximum stat.
    /// </summary>
    public ushort UpdatedDependentMaximumStat
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the updated maximum shield.
    /// </summary>
    public ushort UpdatedMaximumShield
    {
        get => ReadUInt16LittleEndian(this._data[8..]);
        set => WriteUInt16LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the updated maximum ability.
    /// </summary>
    public ushort UpdatedMaximumAbility
    {
        get => ReadUInt16LittleEndian(this._data[10..]);
        set => WriteUInt16LittleEndian(this._data[10..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterStatIncreaseResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterStatIncreaseResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterStatIncreaseResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterStatIncreaseResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the server processed a character delete response of the client.
/// Causes reaction on client side: If successful, the character is deleted from the character selection screen. Otherwise, a message is shown.
/// </summary>
public readonly ref struct CharacterDeleteResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterDeleteResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterDeleteResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterDeleteResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterDeleteResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public CharacterDeleteResponse.CharacterDeleteResult Result
    {
        get => (CharacterDeleteResponse.CharacterDeleteResult)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterDeleteResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterDeleteResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterDeleteResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterDeleteResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a character leveled up.
/// Causes reaction on client side: Updates the level (and other related stats) in the game client and shows an effect.
/// </summary>
public readonly ref struct CharacterLevelUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterLevelUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterLevelUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterLevelUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterLevelUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public ushort Level
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the level up points.
    /// </summary>
    public ushort LevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public ushort MaximumHealth
    {
        get => ReadUInt16LittleEndian(this._data[8..]);
        set => WriteUInt16LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public ushort MaximumMana
    {
        get => ReadUInt16LittleEndian(this._data[10..]);
        set => WriteUInt16LittleEndian(this._data[10..], value);
    }

    /// <summary>
    /// Gets or sets the maximum shield.
    /// </summary>
    public ushort MaximumShield
    {
        get => ReadUInt16LittleEndian(this._data[12..]);
        set => WriteUInt16LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public ushort MaximumAbility
    {
        get => ReadUInt16LittleEndian(this._data[14..]);
        set => WriteUInt16LittleEndian(this._data[14..], value);
    }

    /// <summary>
    /// Gets or sets the fruit points.
    /// </summary>
    public ushort FruitPoints
    {
        get => ReadUInt16LittleEndian(this._data[16..]);
        set => WriteUInt16LittleEndian(this._data[16..], value);
    }

    /// <summary>
    /// Gets or sets the maximum fruit points.
    /// </summary>
    public ushort MaximumFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data[18..]);
        set => WriteUInt16LittleEndian(this._data[18..], value);
    }

    /// <summary>
    /// Gets or sets the negative fruit points.
    /// </summary>
    public ushort NegativeFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data[20..]);
        set => WriteUInt16LittleEndian(this._data[20..], value);
    }

    /// <summary>
    /// Gets or sets the maximum negative fruit points.
    /// </summary>
    public ushort MaximumNegativeFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data[22..]);
        set => WriteUInt16LittleEndian(this._data[22..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterLevelUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterLevelUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterLevelUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterLevelUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the character was selected by the player and entered the game.
/// Causes reaction on client side: The characters enters the game world.
/// </summary>
public readonly ref struct CharacterInformationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterInformationRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterInformationRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 72;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the map id.
    /// </summary>
    public ushort MapId
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the current experience.
    /// </summary>
    public ulong CurrentExperience
    {
        get => ReadUInt64BigEndian(this._data[8..]);
        set => WriteUInt64BigEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the experience for next level.
    /// </summary>
    public ulong ExperienceForNextLevel
    {
        get => ReadUInt64BigEndian(this._data[16..]);
        set => WriteUInt64BigEndian(this._data[16..], value);
    }

    /// <summary>
    /// Gets or sets the level up points.
    /// </summary>
    public ushort LevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data[24..]);
        set => WriteUInt16LittleEndian(this._data[24..], value);
    }

    /// <summary>
    /// Gets or sets the strength.
    /// </summary>
    public ushort Strength
    {
        get => ReadUInt16LittleEndian(this._data[26..]);
        set => WriteUInt16LittleEndian(this._data[26..], value);
    }

    /// <summary>
    /// Gets or sets the agility.
    /// </summary>
    public ushort Agility
    {
        get => ReadUInt16LittleEndian(this._data[28..]);
        set => WriteUInt16LittleEndian(this._data[28..], value);
    }

    /// <summary>
    /// Gets or sets the vitality.
    /// </summary>
    public ushort Vitality
    {
        get => ReadUInt16LittleEndian(this._data[30..]);
        set => WriteUInt16LittleEndian(this._data[30..], value);
    }

    /// <summary>
    /// Gets or sets the energy.
    /// </summary>
    public ushort Energy
    {
        get => ReadUInt16LittleEndian(this._data[32..]);
        set => WriteUInt16LittleEndian(this._data[32..], value);
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public ushort CurrentHealth
    {
        get => ReadUInt16LittleEndian(this._data[34..]);
        set => WriteUInt16LittleEndian(this._data[34..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public ushort MaximumHealth
    {
        get => ReadUInt16LittleEndian(this._data[36..]);
        set => WriteUInt16LittleEndian(this._data[36..], value);
    }

    /// <summary>
    /// Gets or sets the current mana.
    /// </summary>
    public ushort CurrentMana
    {
        get => ReadUInt16LittleEndian(this._data[38..]);
        set => WriteUInt16LittleEndian(this._data[38..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public ushort MaximumMana
    {
        get => ReadUInt16LittleEndian(this._data[40..]);
        set => WriteUInt16LittleEndian(this._data[40..], value);
    }

    /// <summary>
    /// Gets or sets the current shield.
    /// </summary>
    public ushort CurrentShield
    {
        get => ReadUInt16LittleEndian(this._data[42..]);
        set => WriteUInt16LittleEndian(this._data[42..], value);
    }

    /// <summary>
    /// Gets or sets the maximum shield.
    /// </summary>
    public ushort MaximumShield
    {
        get => ReadUInt16LittleEndian(this._data[44..]);
        set => WriteUInt16LittleEndian(this._data[44..], value);
    }

    /// <summary>
    /// Gets or sets the current ability.
    /// </summary>
    public ushort CurrentAbility
    {
        get => ReadUInt16LittleEndian(this._data[46..]);
        set => WriteUInt16LittleEndian(this._data[46..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public ushort MaximumAbility
    {
        get => ReadUInt16LittleEndian(this._data[48..]);
        set => WriteUInt16LittleEndian(this._data[48..], value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data[52..]);
        set => WriteUInt32LittleEndian(this._data[52..], value);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data[56];
        set => this._data[56] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data[57];
        set => this._data[57] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the used fruit points.
    /// </summary>
    public ushort UsedFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data[58..]);
        set => WriteUInt16LittleEndian(this._data[58..], value);
    }

    /// <summary>
    /// Gets or sets the max fruit points.
    /// </summary>
    public ushort MaxFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data[60..]);
        set => WriteUInt16LittleEndian(this._data[60..], value);
    }

    /// <summary>
    /// Gets or sets the leadership.
    /// </summary>
    public ushort Leadership
    {
        get => ReadUInt16LittleEndian(this._data[62..]);
        set => WriteUInt16LittleEndian(this._data[62..], value);
    }

    /// <summary>
    /// Gets or sets the used negative fruit points.
    /// </summary>
    public ushort UsedNegativeFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data[64..]);
        set => WriteUInt16LittleEndian(this._data[64..], value);
    }

    /// <summary>
    /// Gets or sets the max negative fruit points.
    /// </summary>
    public ushort MaxNegativeFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data[66..]);
        set => WriteUInt16LittleEndian(this._data[66..], value);
    }

    /// <summary>
    /// Gets or sets the inventory extensions.
    /// </summary>
    public byte InventoryExtensions
    {
        get => this._data[68];
        set => this._data[68] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInformation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterInformationRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterInformation"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterInformationRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the character was selected by the player and entered the game.
/// Causes reaction on client side: The characters enters the game world.
/// </summary>
public readonly ref struct CharacterInformation075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformation075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterInformation075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformation075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterInformation075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 42;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the map id.
    /// </summary>
    public byte MapId
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the current experience.
    /// </summary>
    public uint CurrentExperience
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the experience for next level.
    /// </summary>
    public uint ExperienceForNextLevel
    {
        get => ReadUInt32LittleEndian(this._data[12..]);
        set => WriteUInt32LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the level up points.
    /// </summary>
    public ushort LevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data[16..]);
        set => WriteUInt16LittleEndian(this._data[16..], value);
    }

    /// <summary>
    /// Gets or sets the strength.
    /// </summary>
    public ushort Strength
    {
        get => ReadUInt16LittleEndian(this._data[18..]);
        set => WriteUInt16LittleEndian(this._data[18..], value);
    }

    /// <summary>
    /// Gets or sets the agility.
    /// </summary>
    public ushort Agility
    {
        get => ReadUInt16LittleEndian(this._data[20..]);
        set => WriteUInt16LittleEndian(this._data[20..], value);
    }

    /// <summary>
    /// Gets or sets the vitality.
    /// </summary>
    public ushort Vitality
    {
        get => ReadUInt16LittleEndian(this._data[22..]);
        set => WriteUInt16LittleEndian(this._data[22..], value);
    }

    /// <summary>
    /// Gets or sets the energy.
    /// </summary>
    public ushort Energy
    {
        get => ReadUInt16LittleEndian(this._data[24..]);
        set => WriteUInt16LittleEndian(this._data[24..], value);
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public ushort CurrentHealth
    {
        get => ReadUInt16LittleEndian(this._data[26..]);
        set => WriteUInt16LittleEndian(this._data[26..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public ushort MaximumHealth
    {
        get => ReadUInt16LittleEndian(this._data[28..]);
        set => WriteUInt16LittleEndian(this._data[28..], value);
    }

    /// <summary>
    /// Gets or sets the current mana.
    /// </summary>
    public ushort CurrentMana
    {
        get => ReadUInt16LittleEndian(this._data[30..]);
        set => WriteUInt16LittleEndian(this._data[30..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public ushort MaximumMana
    {
        get => ReadUInt16LittleEndian(this._data[32..]);
        set => WriteUInt16LittleEndian(this._data[32..], value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data[36..]);
        set => WriteUInt32LittleEndian(this._data[36..], value);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data[40];
        set => this._data[40] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data[41];
        set => this._data[41] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInformation075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterInformation075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterInformation075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterInformation075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the character was selected by the player and entered the game.
/// Causes reaction on client side: The characters enters the game world.
/// </summary>
public readonly ref struct CharacterInformation097Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformation097Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterInformation097Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformation097Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterInformation097Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 52;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the map id.
    /// </summary>
    public byte MapId
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the direction.
    /// </summary>
    public byte Direction
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the current experience.
    /// </summary>
    public uint CurrentExperience
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the experience for next level.
    /// </summary>
    public uint ExperienceForNextLevel
    {
        get => ReadUInt32LittleEndian(this._data[12..]);
        set => WriteUInt32LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the level up points.
    /// </summary>
    public ushort LevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data[16..]);
        set => WriteUInt16LittleEndian(this._data[16..], value);
    }

    /// <summary>
    /// Gets or sets the strength.
    /// </summary>
    public ushort Strength
    {
        get => ReadUInt16LittleEndian(this._data[18..]);
        set => WriteUInt16LittleEndian(this._data[18..], value);
    }

    /// <summary>
    /// Gets or sets the agility.
    /// </summary>
    public ushort Agility
    {
        get => ReadUInt16LittleEndian(this._data[20..]);
        set => WriteUInt16LittleEndian(this._data[20..], value);
    }

    /// <summary>
    /// Gets or sets the vitality.
    /// </summary>
    public ushort Vitality
    {
        get => ReadUInt16LittleEndian(this._data[22..]);
        set => WriteUInt16LittleEndian(this._data[22..], value);
    }

    /// <summary>
    /// Gets or sets the energy.
    /// </summary>
    public ushort Energy
    {
        get => ReadUInt16LittleEndian(this._data[24..]);
        set => WriteUInt16LittleEndian(this._data[24..], value);
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public ushort CurrentHealth
    {
        get => ReadUInt16LittleEndian(this._data[26..]);
        set => WriteUInt16LittleEndian(this._data[26..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public ushort MaximumHealth
    {
        get => ReadUInt16LittleEndian(this._data[28..]);
        set => WriteUInt16LittleEndian(this._data[28..], value);
    }

    /// <summary>
    /// Gets or sets the current mana.
    /// </summary>
    public ushort CurrentMana
    {
        get => ReadUInt16LittleEndian(this._data[30..]);
        set => WriteUInt16LittleEndian(this._data[30..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public ushort MaximumMana
    {
        get => ReadUInt16LittleEndian(this._data[32..]);
        set => WriteUInt16LittleEndian(this._data[32..], value);
    }

    /// <summary>
    /// Gets or sets the current ability.
    /// </summary>
    public ushort CurrentAbility
    {
        get => ReadUInt16LittleEndian(this._data[34..]);
        set => WriteUInt16LittleEndian(this._data[34..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public ushort MaximumAbility
    {
        get => ReadUInt16LittleEndian(this._data[36..]);
        set => WriteUInt16LittleEndian(this._data[36..], value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data[40..]);
        set => WriteUInt32LittleEndian(this._data[40..], value);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data[44];
        set => this._data[44] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data[45];
        set => this._data[45] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the used fruit points.
    /// </summary>
    public ushort UsedFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data[46..]);
        set => WriteUInt16LittleEndian(this._data[46..], value);
    }

    /// <summary>
    /// Gets or sets the max fruit points.
    /// </summary>
    public ushort MaxFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data[48..]);
        set => WriteUInt16LittleEndian(this._data[48..], value);
    }

    /// <summary>
    /// Gets or sets the leadership.
    /// </summary>
    public ushort Leadership
    {
        get => ReadUInt16LittleEndian(this._data[50..]);
        set => WriteUInt16LittleEndian(this._data[50..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInformation097"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterInformation097Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterInformation097"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterInformation097Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player entered the game or finished a trade.
/// Causes reaction on client side: The user interface of the inventory is initialized with all of its items.
/// </summary>
public readonly ref struct CharacterInventoryRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInventoryRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterInventoryRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInventoryRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterInventoryRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC4;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C4HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets the <see cref="StoredItemRef"/> of the specified index.
    /// </summary>
        public StoredItemRef this[int index, int storedItemLength] => new (this._data[(6 + index * storedItemLength)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInventory"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterInventoryRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterInventory"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CharacterInventoryRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="StoredItemRef"/> and it's size.
    /// </summary>
    /// <param name="itemsCount">The count of <see cref="StoredItemRef"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="StoredItemRef"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 6;
}


/// <summary>
/// Is sent by the server when: An item in the inventory got upgraded by the player, e.g. by applying a jewel.
/// Causes reaction on client side: The item is updated on the user interface.
/// </summary>
public readonly ref struct InventoryItemUpgradedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="InventoryItemUpgradedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public InventoryItemUpgradedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="InventoryItemUpgradedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private InventoryItemUpgradedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(5);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="InventoryItemUpgraded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator InventoryItemUpgradedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="InventoryItemUpgraded"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(InventoryItemUpgradedRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
}


/// <summary>
/// Is sent by the server when: When health of a summoned monster (Elf Skill) changed.
/// Causes reaction on client side: The health is updated on the user interface.
/// </summary>
public readonly ref struct SummonHealthUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SummonHealthUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SummonHealthUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SummonHealthUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SummonHealthUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x20;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the health percent.
    /// </summary>
    public byte HealthPercent
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SummonHealthUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SummonHealthUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SummonHealthUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SummonHealthUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Every second during a guild soccer match.
/// Causes reaction on client side: The time is updated on the user interface.
/// </summary>
public readonly ref struct GuildSoccerTimeUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildSoccerTimeUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildSoccerTimeUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildSoccerTimeUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildSoccerTimeUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x22;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the seconds.
    /// </summary>
    public ushort Seconds
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildSoccerTimeUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildSoccerTimeUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildSoccerTimeUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildSoccerTimeUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Whenever the score of the soccer game changed, and at the beginning of the match.
/// Causes reaction on client side: The score is updated on the user interface.
/// </summary>
public readonly ref struct GuildSoccerScoreUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildSoccerScoreUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildSoccerScoreUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildSoccerScoreUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildSoccerScoreUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x23;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 22;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the red team name.
    /// </summary>
    public string RedTeamName
    {
        get => this._data.ExtractString(4, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 8).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the red team goals.
    /// </summary>
    public byte RedTeamGoals
    {
        get => this._data[12];
        set => this._data[12] = value;
    }

    /// <summary>
    /// Gets or sets the blue team name.
    /// </summary>
    public string BlueTeamName
    {
        get => this._data.ExtractString(13, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(13, 8).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the blue team goals.
    /// </summary>
    public byte BlueTeamGoals
    {
        get => this._data[21];
        set => this._data[21] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildSoccerScoreUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildSoccerScoreUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildSoccerScoreUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildSoccerScoreUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: E.g. when event items are dropped to the floor, or a specific dialog should be shown.
/// Causes reaction on client side: The client shows an effect, e.g. a firework.
/// </summary>
public readonly ref struct ServerCommandRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ServerCommandRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ServerCommandRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ServerCommandRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ServerCommandRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the command type.
    /// </summary>
    public byte CommandType
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the parameter 1.
    /// </summary>
    public byte Parameter1
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the parameter 2.
    /// </summary>
    public byte Parameter2
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerCommand"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ServerCommandRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ServerCommand"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ServerCommandRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: E.g. when event items are dropped to the floor.
/// Causes reaction on client side: The client shows an fireworks effect at the specified coordinates.
/// </summary>
public readonly ref struct ShowFireworksRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowFireworksRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ShowFireworksRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowFireworksRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ShowFireworksRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.EffectType = 0;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the effect type.
    /// </summary>
    public byte EffectType
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ShowFireworks"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ShowFireworksRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ShowFireworks"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ShowFireworksRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: E.g. when event items are dropped to the floor.
/// Causes reaction on client side: The client shows an christmas fireworks effect at the specified coordinates.
/// </summary>
public readonly ref struct ShowChristmasFireworksRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowChristmasFireworksRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ShowChristmasFireworksRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowChristmasFireworksRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ShowChristmasFireworksRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.EffectType = 59;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the effect type.
    /// </summary>
    public byte EffectType
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ShowChristmasFireworks"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ShowChristmasFireworksRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ShowChristmasFireworks"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ShowChristmasFireworksRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: E.g. when event items are dropped to the floor.
/// Causes reaction on client side: The client plays a fanfare sound at the specified coordinates.
/// </summary>
public readonly ref struct PlayFanfareSoundRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayFanfareSoundRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayFanfareSoundRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayFanfareSoundRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayFanfareSoundRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.EffectType = 2;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the effect type.
    /// </summary>
    public byte EffectType
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayFanfareSound"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayFanfareSoundRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayFanfareSound"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PlayFanfareSoundRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: E.g. when event items are dropped to the floor.
/// Causes reaction on client side: The client shows a swirl effect at the specified object.
/// </summary>
public readonly ref struct ShowSwirlRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowSwirlRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ShowSwirlRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowSwirlRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ShowSwirlRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.EffectType = 58;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the effect type.
    /// </summary>
    public byte EffectType
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the target object id.
    /// </summary>
    public ushort TargetObjectId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ShowSwirl"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ShowSwirlRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ShowSwirl"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ShowSwirlRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After entering the game with a master class character.
/// Causes reaction on client side: The master related data is available.
/// </summary>
public readonly ref struct MasterStatsUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterStatsUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MasterStatsUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterStatsUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MasterStatsUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x50;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 32;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the master level.
    /// </summary>
    public ushort MasterLevel
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the master experience.
    /// </summary>
    public ulong MasterExperience
    {
        get => ReadUInt64BigEndian(this._data[6..]);
        set => WriteUInt64BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the master experience of next level.
    /// </summary>
    public ulong MasterExperienceOfNextLevel
    {
        get => ReadUInt64BigEndian(this._data[14..]);
        set => WriteUInt64BigEndian(this._data[14..], value);
    }

    /// <summary>
    /// Gets or sets the master level up points.
    /// </summary>
    public ushort MasterLevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data[22..]);
        set => WriteUInt16LittleEndian(this._data[22..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public ushort MaximumHealth
    {
        get => ReadUInt16LittleEndian(this._data[24..]);
        set => WriteUInt16LittleEndian(this._data[24..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public ushort MaximumMana
    {
        get => ReadUInt16LittleEndian(this._data[26..]);
        set => WriteUInt16LittleEndian(this._data[26..], value);
    }

    /// <summary>
    /// Gets or sets the maximum shield.
    /// </summary>
    public ushort MaximumShield
    {
        get => ReadUInt16LittleEndian(this._data[28..]);
        set => WriteUInt16LittleEndian(this._data[28..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public ushort MaximumAbility
    {
        get => ReadUInt16LittleEndian(this._data[30..]);
        set => WriteUInt16LittleEndian(this._data[30..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterStatsUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MasterStatsUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MasterStatsUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MasterStatsUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a master character leveled up.
/// Causes reaction on client side: Updates the master level (and other related stats) in the game client and shows an effect.
/// </summary>
public readonly ref struct MasterCharacterLevelUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterCharacterLevelUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MasterCharacterLevelUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterCharacterLevelUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MasterCharacterLevelUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x51;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 20;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the master level.
    /// </summary>
    public ushort MasterLevel
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the gained master points.
    /// </summary>
    public ushort GainedMasterPoints
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the current master points.
    /// </summary>
    public ushort CurrentMasterPoints
    {
        get => ReadUInt16LittleEndian(this._data[8..]);
        set => WriteUInt16LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the maximum master points.
    /// </summary>
    public ushort MaximumMasterPoints
    {
        get => ReadUInt16LittleEndian(this._data[10..]);
        set => WriteUInt16LittleEndian(this._data[10..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public ushort MaximumHealth
    {
        get => ReadUInt16LittleEndian(this._data[12..]);
        set => WriteUInt16LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public ushort MaximumMana
    {
        get => ReadUInt16LittleEndian(this._data[14..]);
        set => WriteUInt16LittleEndian(this._data[14..], value);
    }

    /// <summary>
    /// Gets or sets the maximum shield.
    /// </summary>
    public ushort MaximumShield
    {
        get => ReadUInt16LittleEndian(this._data[16..]);
        set => WriteUInt16LittleEndian(this._data[16..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public ushort MaximumAbility
    {
        get => ReadUInt16LittleEndian(this._data[18..]);
        set => WriteUInt16LittleEndian(this._data[18..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterCharacterLevelUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MasterCharacterLevelUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MasterCharacterLevelUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MasterCharacterLevelUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a master skill level has been changed (usually increased).
/// Causes reaction on client side: The level is updated in the master skill tree.
/// </summary>
public readonly ref struct MasterSkillLevelUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterSkillLevelUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MasterSkillLevelUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterSkillLevelUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MasterSkillLevelUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x52;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 28;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the master level up points.
    /// </summary>
    public ushort MasterLevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the index of the master skill on the clients master skill tree for the given character class.
    /// </summary>
    public byte MasterSkillIndex
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the master skill number.
    /// </summary>
    public ushort MasterSkillNumber
    {
        get => ReadUInt16LittleEndian(this._data[12..]);
        set => WriteUInt16LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public byte Level
    {
        get => this._data[16];
        set => this._data[16] = value;
    }

    /// <summary>
    /// Gets or sets the display value.
    /// </summary>
    public float DisplayValue
    {
        get => ReadSingleLittleEndian(this._data[20..]);
        set => WriteSingleLittleEndian(this._data[20..], value);
    }

    /// <summary>
    /// Gets or sets the display value of next level.
    /// </summary>
    public float DisplayValueOfNextLevel
    {
        get => ReadSingleLittleEndian(this._data[24..]);
        set => WriteSingleLittleEndian(this._data[24..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterSkillLevelUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MasterSkillLevelUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MasterSkillLevelUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MasterSkillLevelUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Usually after entering the game with a master character.
/// Causes reaction on client side: The data is available in the master skill tree.
/// </summary>
public readonly ref struct MasterSkillListRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterSkillListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MasterSkillListRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterSkillListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MasterSkillListRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x53;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the master skill count.
    /// </summary>
    public uint MasterSkillCount
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets the <see cref="MasterSkillEntryRef"/> of the specified index.
    /// </summary>
        public MasterSkillEntryRef this[int index] => new (this._data[(12 + index * MasterSkillEntryRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterSkillList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MasterSkillListRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MasterSkillList"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MasterSkillListRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="MasterSkillEntryRef"/>.
    /// </summary>
    /// <param name="skillsCount">The count of <see cref="MasterSkillEntryRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int skillsCount) => skillsCount * MasterSkillEntryRef.Length + 12;


/// <summary>
/// An entry in the master skill list..
/// </summary>
public readonly ref struct MasterSkillEntryRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterSkillEntryRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MasterSkillEntryRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets or sets the index of the master skill on the clients master skill tree for the given character class.
    /// </summary>
    public byte MasterSkillIndex
    {
        get => this._data[0];
        set => this._data[0] = value;
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public byte Level
    {
        get => this._data[1];
        set => this._data[1] = value;
    }

    /// <summary>
    /// Gets or sets the display value.
    /// </summary>
    public float DisplayValue
    {
        get => ReadSingleLittleEndian(this._data[4..]);
        set => WriteSingleLittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the display value of next level.
    /// </summary>
    public float DisplayValueOfNextLevel
    {
        get => ReadSingleLittleEndian(this._data[8..]);
        set => WriteSingleLittleEndian(this._data[8..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: 
/// Causes reaction on client side: 
/// </summary>
public readonly ref struct ServerMessageRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ServerMessageRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ServerMessageRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ServerMessageRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ServerMessageRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x0D;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public ServerMessage.MessageType Type
    {
        get => (ServerMessage.MessageType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the message.
    /// </summary>
    public string Message
    {
        get => this._data.ExtractString(4, this._data.Length - 4, System.Text.Encoding.UTF8);
        set => this._data.Slice(4).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerMessage"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ServerMessageRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ServerMessage"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ServerMessageRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 4;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 4;
}


/// <summary>
/// Is sent by the server when: A player requested to join a guild. This message is sent then to the guild master.
/// Causes reaction on client side: The guild master gets a message box with the request popping up.
/// </summary>
public readonly ref struct GuildJoinRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildJoinRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildJoinRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildJoinRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildJoinRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x50;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the requester id.
    /// </summary>
    public ushort RequesterId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildJoinRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildJoinRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildJoinRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildJoinRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a guild master responded to a request of a player to join his guild. This message is sent back to the requesting player.
/// Causes reaction on client side: The requester gets a corresponding message showing.
/// </summary>
public readonly ref struct GuildJoinResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildJoinResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildJoinResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildJoinResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildJoinResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x51;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public GuildJoinResponse.GuildJoinRequestResult Result
    {
        get => (GuildJoinResponse.GuildJoinRequestResult)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildJoinResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildJoinResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildJoinResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildJoinResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a game client requested the list of players of his guild, which is usually the case when the player opens the guild dialog at the game client.
/// Causes reaction on client side: The list of player is available at the client.
/// </summary>
public readonly ref struct GuildListRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildListRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildListRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x52;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the is in guild.
    /// </summary>
    public bool IsInGuild
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the guild member count.
    /// </summary>
    public byte GuildMemberCount
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the total score.
    /// </summary>
    public uint TotalScore
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the current score.
    /// </summary>
    public byte CurrentScore
    {
        get => this._data[12];
        set => this._data[12] = value;
    }

    /// <summary>
    /// Gets or sets the rival guild name.
    /// </summary>
    public string RivalGuildName
    {
        get => this._data.ExtractString(13, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(13, 8).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets the <see cref="GuildMemberRef"/> of the specified index.
    /// </summary>
        public GuildMemberRef this[int index] => new (this._data[(24 + index * GuildMemberRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildListRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildList"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildListRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="GuildMemberRef"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="GuildMemberRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * GuildMemberRef.Length + 24;


/// <summary>
/// Contains the data of one guild member..
/// </summary>
public readonly ref struct GuildMemberRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMemberRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildMemberRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the server id.
    /// </summary>
    public byte ServerId
    {
        get => this._data[10];
        set => this._data[10] = value;
    }

    /// <summary>
    /// Gets or sets the server id 2.
    /// </summary>
    public byte ServerId2
    {
        get => this._data[11];
        set => this._data[11] = value;
    }

    /// <summary>
    /// Gets or sets the role.
    /// </summary>
    public GuildMemberRole Role
    {
        get => (GuildMemberRole)this._data[12];
        set => this._data[12] = (byte)value;
    }
}
}


/// <summary>
/// Is sent by the server when: After a game client requested the list of players of his guild, which is usually the case when the player opens the guild dialog at the game client.
/// Causes reaction on client side: The list of player is available at the client.
/// </summary>
public readonly ref struct GuildList075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildList075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildList075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildList075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildList075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x52;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the is in guild.
    /// </summary>
    public bool IsInGuild
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the guild member count.
    /// </summary>
    public byte GuildMemberCount
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the total score.
    /// </summary>
    public uint TotalScore
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the current score.
    /// </summary>
    public byte CurrentScore
    {
        get => this._data[12];
        set => this._data[12] = value;
    }

    /// <summary>
    /// Gets the <see cref="GuildMemberRef"/> of the specified index.
    /// </summary>
        public GuildMemberRef this[int index] => new (this._data[(13 + index * GuildMemberRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildList075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildList075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildList075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildList075Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="GuildMemberRef"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="GuildMemberRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * GuildMemberRef.Length + 13;


/// <summary>
/// Contains the data of one guild member..
/// </summary>
public readonly ref struct GuildMemberRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMemberRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildMemberRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the server id.
    /// </summary>
    public byte ServerId
    {
        get => this._data[10];
        set => this._data[10] = value;
    }

    /// <summary>
    /// Gets or sets the server id 2.
    /// </summary>
    public byte ServerId2
    {
        get => this._data[11];
        set => this._data[11] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: After a guild master sent a request to kick a player from its guild and the server processed this request.
/// Causes reaction on client side: The client shows a message depending on the result.
/// </summary>
public readonly ref struct GuildKickResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildKickResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildKickResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildKickResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildKickResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x53;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public GuildKickResponse.GuildKickSuccess Result
    {
        get => (GuildKickResponse.GuildKickSuccess)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildKickResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildKickResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildKickResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildKickResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a player started talking to the guild master NPC and the player is allowed to create a guild.
/// Causes reaction on client side: The client shows the guild master dialog.
/// </summary>
public readonly ref struct ShowGuildMasterDialogRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowGuildMasterDialogRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ShowGuildMasterDialogRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowGuildMasterDialogRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ShowGuildMasterDialogRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x54;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ShowGuildMasterDialog"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ShowGuildMasterDialogRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ShowGuildMasterDialog"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ShowGuildMasterDialogRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a player started talking to the guild master NPC and the player proceeds to create a guild.
/// Causes reaction on client side: The client shows the guild creation dialog.
/// </summary>
public readonly ref struct ShowGuildCreationDialogRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowGuildCreationDialogRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ShowGuildCreationDialogRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowGuildCreationDialogRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ShowGuildCreationDialogRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x55;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ShowGuildCreationDialog"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ShowGuildCreationDialogRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ShowGuildCreationDialog"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ShowGuildCreationDialogRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a player requested to create a guild at the guild master NPC.
/// Causes reaction on client side: Depending on the result, a message is shown.
/// </summary>
public readonly ref struct GuildCreationResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildCreationResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildCreationResultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildCreationResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildCreationResultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x56;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the error.
    /// </summary>
    public GuildCreationResult.GuildCreationErrorType Error
    {
        get => (GuildCreationResult.GuildCreationErrorType)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildCreationResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildCreationResultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildCreationResult"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildCreationResultRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player left a guild. This message is sent to the player and all surrounding players.
/// Causes reaction on client side: The player is not longer shown as a guild member.
/// </summary>
public readonly ref struct GuildMemberLeftGuildRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMemberLeftGuildRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildMemberLeftGuildRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMemberLeftGuildRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildMemberLeftGuildRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x5D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the is guild master.
    /// </summary>
    public bool IsGuildMaster
    {
        get => this._data[3..].GetBoolean(7);
        set => this._data[3..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildMemberLeftGuild"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildMemberLeftGuildRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildMemberLeftGuild"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildMemberLeftGuildRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A guild master requested a guild war against another guild.
/// Causes reaction on client side: The guild master of the other guild gets this request.
/// </summary>
public readonly ref struct GuildWarRequestResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarRequestResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildWarRequestResultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarRequestResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildWarRequestResultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x60;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public GuildWarRequestResult.RequestResult Result
    {
        get => (GuildWarRequestResult.RequestResult)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildWarRequestResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildWarRequestResultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildWarRequestResult"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildWarRequestResultRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A guild master requested a guild war against another guild.
/// Causes reaction on client side: The guild master of the other guild gets this request.
/// </summary>
public readonly ref struct GuildWarRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildWarRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildWarRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x61;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.ExtractString(3, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 8).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public GuildWarType Type
    {
        get => (GuildWarType)this._data[11];
        set => this._data[11] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildWarRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildWarRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildWarRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildWarRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A guild master requested a guild war against another guild.
/// Causes reaction on client side: The guild master of the other guild gets this request.
/// </summary>
public readonly ref struct GuildWarDeclaredRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarDeclaredRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildWarDeclaredRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarDeclaredRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildWarDeclaredRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x62;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.ExtractString(3, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 8).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public GuildWarType Type
    {
        get => (GuildWarType)this._data[11];
        set => this._data[11] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the team code.
    /// </summary>
    public byte TeamCode
    {
        get => this._data[12];
        set => this._data[12] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildWarDeclared"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildWarDeclaredRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildWarDeclared"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildWarDeclaredRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The guild war ended.
/// Causes reaction on client side: The guild war is shown as ended on the client side.
/// </summary>
public readonly ref struct GuildWarEndedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarEndedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildWarEndedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarEndedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildWarEndedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x63;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public GuildWarEnded.GuildWarResult Result
    {
        get => (GuildWarEnded.GuildWarResult)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.ExtractString(4, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 8).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildWarEnded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildWarEndedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildWarEnded"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildWarEndedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The guild war score changed.
/// Causes reaction on client side: The guild score is updated on the client side.
/// </summary>
public readonly ref struct GuildWarScoreUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarScoreUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildWarScoreUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarScoreUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildWarScoreUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.Type = 0;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x64;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the score of own guild.
    /// </summary>
    public byte ScoreOfOwnGuild
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the score of enemy guild.
    /// </summary>
    public byte ScoreOfEnemyGuild
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildWarScoreUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildWarScoreUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildWarScoreUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildWarScoreUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The server wants to visibly assign a player to a guild, e.g. when two players met each other and one of them is a guild member.
/// Causes reaction on client side: The players which belong to the guild are shown as guild players. If the game client doesn't met a player of this guild yet, it will send another request to get the guild information.
/// </summary>
public readonly ref struct AssignCharacterToGuildRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AssignCharacterToGuildRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AssignCharacterToGuildRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AssignCharacterToGuildRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AssignCharacterToGuildRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x65;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player count.
    /// </summary>
    public byte PlayerCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="GuildMemberRelationRef"/> of the specified index.
    /// </summary>
        public GuildMemberRelationRef this[int index] => new (this._data[(5 + index * GuildMemberRelationRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AssignCharacterToGuild"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AssignCharacterToGuildRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AssignCharacterToGuild"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AssignCharacterToGuildRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="GuildMemberRelationRef"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="GuildMemberRelationRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * GuildMemberRelationRef.Length + 5;


/// <summary>
/// Relation between a guild and a member..
/// </summary>
public readonly ref struct GuildMemberRelationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMemberRelationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildMemberRelationRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public uint GuildId
    {
        get => ReadUInt32LittleEndian(this._data);
        set => WriteUInt32LittleEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the role.
    /// </summary>
    public GuildMemberRole Role
    {
        get => (GuildMemberRole)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the is player appearing new.
    /// </summary>
    public bool IsPlayerAppearingNew
    {
        get => this._data[7..].GetBoolean(7);
        set => this._data[7..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[7..]);
        set => WriteUInt16BigEndian(this._data[7..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: The server wants to visibly assign a player to a guild, e.g. when two players met each other and one of them is a guild member.
/// Causes reaction on client side: The players which belong to the guild are shown as guild players. If the game client doesn't met a player of this guild yet, it will send another request to get the guild information.
/// </summary>
public readonly ref struct AssignCharacterToGuild075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AssignCharacterToGuild075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AssignCharacterToGuild075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AssignCharacterToGuild075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AssignCharacterToGuild075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x5B;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player count.
    /// </summary>
    public byte PlayerCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="GuildMemberRelationRef"/> of the specified index.
    /// </summary>
        public GuildMemberRelationRef this[int index] => new (this._data[(5 + index * GuildMemberRelationRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AssignCharacterToGuild075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AssignCharacterToGuild075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AssignCharacterToGuild075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AssignCharacterToGuild075Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="GuildMemberRelationRef"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="GuildMemberRelationRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * GuildMemberRelationRef.Length + 5;


/// <summary>
/// Relation between a guild and a member..
/// </summary>
public readonly ref struct GuildMemberRelationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMemberRelationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildMemberRelationRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public ushort GuildId
    {
        get => ReadUInt16BigEndian(this._data[2..]);
        set => WriteUInt16BigEndian(this._data[2..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: A game client requested the (public) info of a guild, e.g. when it met a player of previously unknown guild.
/// Causes reaction on client side: The players which belong to the guild are shown as guild players.
/// </summary>
public readonly ref struct GuildInformationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildInformationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildInformationRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildInformationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildInformationRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x66;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 60;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public uint GuildId
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the guild type.
    /// </summary>
    public byte GuildType
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the alliance guild name.
    /// </summary>
    public string AllianceGuildName
    {
        get => this._data.ExtractString(9, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(9, 8).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.ExtractString(17, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(17, 8).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the logo.
    /// </summary>
    public Span<byte> Logo
    {
        get => this._data.Slice(25, 32);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildInformation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildInformationRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildInformation"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildInformationRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player went into the scope of one or more guild members.
/// Causes reaction on client side: The players which belong to the guild are shown as guild players.
/// </summary>
public readonly ref struct GuildInformations075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildInformations075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildInformations075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildInformations075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildInformations075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x5A;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild count.
    /// </summary>
    public byte GuildCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="GuildInfoRef"/> of the specified index.
    /// </summary>
        public GuildInfoRef this[int index] => new (this._data[(5 + index * GuildInfoRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildInformations075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildInformations075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildInformations075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(GuildInformations075Ref packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="GuildInfoRef"/>.
    /// </summary>
    /// <param name="guildsCount">The count of <see cref="GuildInfoRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int guildsCount) => guildsCount * GuildInfoRef.Length + 5;


/// <summary>
/// Information about one guild..
/// </summary>
public readonly ref struct GuildInfoRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildInfoRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildInfoRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 42;

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public ushort GuildId
    {
        get => ReadUInt16BigEndian(this._data);
        set => WriteUInt16BigEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.ExtractString(2, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(2, 8).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the logo.
    /// </summary>
    public Span<byte> Logo
    {
        get => this._data.Slice(10, 32);
    }
}
}


/// <summary>
/// Is sent by the server when: After a guild has been created. However, in OpenMU, we just send the GuildInformations075 message, because it works just the same.
/// Causes reaction on client side: The players which belong to the guild are shown as guild players.
/// </summary>
public readonly ref struct SingleGuildInformation075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SingleGuildInformation075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SingleGuildInformation075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SingleGuildInformation075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SingleGuildInformation075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x5C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 45;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public ushort GuildId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.ExtractString(5, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(5, 8).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the logo.
    /// </summary>
    public Span<byte> Logo
    {
        get => this._data.Slice(13, 32);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SingleGuildInformation075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SingleGuildInformation075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SingleGuildInformation075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SingleGuildInformation075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to move money between the vault and inventory.
/// Causes reaction on client side: The game client updates the money values of vault and inventory.
/// </summary>
public readonly ref struct VaultMoneyUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultMoneyUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public VaultMoneyUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultMoneyUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private VaultMoneyUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x81;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the vault money.
    /// </summary>
    public uint VaultMoney
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the inventory money.
    /// </summary>
    public uint InventoryMoney
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="VaultMoneyUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator VaultMoneyUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="VaultMoneyUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(VaultMoneyUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to close the vault, this confirmation is sent back to the client.
/// Causes reaction on client side: The game client closes the vault dialog.
/// </summary>
public readonly ref struct VaultClosedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultClosedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public VaultClosedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultClosedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private VaultClosedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x82;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="VaultClosed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator VaultClosedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="VaultClosed"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(VaultClosedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to open the vault.
/// Causes reaction on client side: The game client updates the UI to show the current vault protection state.
/// </summary>
public readonly ref struct VaultProtectionInformationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultProtectionInformationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public VaultProtectionInformationRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultProtectionInformationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private VaultProtectionInformationRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x83;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the protection state.
    /// </summary>
    public VaultProtectionInformation.VaultProtectionState ProtectionState
    {
        get => (VaultProtectionInformation.VaultProtectionState)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="VaultProtectionInformation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator VaultProtectionInformationRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="VaultProtectionInformation"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(VaultProtectionInformationRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to execute an item crafting, e.g. at the chaos machine.
/// Causes reaction on client side: The game client updates the UI to show the resulting item.
/// </summary>
public readonly ref struct ItemCraftingResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemCraftingResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemCraftingResultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemCraftingResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemCraftingResultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x86;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public ItemCraftingResult.CraftingResult Result
    {
        get => (ItemCraftingResult.CraftingResult)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(4);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemCraftingResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemCraftingResultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemCraftingResult"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ItemCraftingResultRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
}


/// <summary>
/// Is sent by the server when: After the player requested to close the crafting dialog, this confirmation is sent back to the client.
/// Causes reaction on client side: The game client closes the crafting dialog.
/// </summary>
public readonly ref struct CraftingDialogClosed075Ref
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CraftingDialogClosed075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CraftingDialogClosed075Ref(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CraftingDialogClosed075Ref"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CraftingDialogClosed075Ref(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x87;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="CraftingDialogClosed075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CraftingDialogClosed075Ref(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CraftingDialogClosed075"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(CraftingDialogClosed075Ref packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player entered the game with his character.
/// Causes reaction on client side: The game client updates the quest state for the quest dialog accordingly.
/// </summary>
public readonly ref partial struct LegacyQuestStateListRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestStateListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LegacyQuestStateListRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestStateListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LegacyQuestStateListRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            this.QuestCount = 6;
            this.ScrollOfEmperorState = LegacyQuestState.Inactive;
            this.ThreeTreasuresOfMuState = LegacyQuestState.Inactive;
            this.GainHeroStatusState = LegacyQuestState.Inactive;
            this.SecretOfDarkStoneState = LegacyQuestState.Inactive;
            this.CertificateOfStrengthState = LegacyQuestState.Inactive;
            this.InfiltrationOfBarrackState = LegacyQuestState.Inactive;
            this.InfiltrationOfRefugeState = LegacyQuestState.Inactive;
            this.UnusedQuestState = LegacyQuestState.Undefined;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA0;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest count.
    /// </summary>
    public byte QuestCount
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the scroll of emperor state.
    /// </summary>
    public LegacyQuestState ScrollOfEmperorState
    {
        get => (LegacyQuestState)this._data[4..].GetByteValue(2, 0);
        set => this._data[4..].SetByteValue((byte)value, 2, 0);
    }

    /// <summary>
    /// Gets or sets the three treasures of mu state.
    /// </summary>
    public LegacyQuestState ThreeTreasuresOfMuState
    {
        get => (LegacyQuestState)this._data[4..].GetByteValue(2, 2);
        set => this._data[4..].SetByteValue((byte)value, 2, 2);
    }

    /// <summary>
    /// Gets or sets the gain hero status state.
    /// </summary>
    public LegacyQuestState GainHeroStatusState
    {
        get => (LegacyQuestState)this._data[4..].GetByteValue(2, 4);
        set => this._data[4..].SetByteValue((byte)value, 2, 4);
    }

    /// <summary>
    /// Gets or sets the secret of dark stone state.
    /// </summary>
    public LegacyQuestState SecretOfDarkStoneState
    {
        get => (LegacyQuestState)this._data[4..].GetByteValue(2, 6);
        set => this._data[4..].SetByteValue((byte)value, 2, 6);
    }

    /// <summary>
    /// Gets or sets the certificate of strength state.
    /// </summary>
    public LegacyQuestState CertificateOfStrengthState
    {
        get => (LegacyQuestState)this._data[5..].GetByteValue(2, 0);
        set => this._data[5..].SetByteValue((byte)value, 2, 0);
    }

    /// <summary>
    /// Gets or sets the infiltration of barrack state.
    /// </summary>
    public LegacyQuestState InfiltrationOfBarrackState
    {
        get => (LegacyQuestState)this._data[5..].GetByteValue(2, 2);
        set => this._data[5..].SetByteValue((byte)value, 2, 2);
    }

    /// <summary>
    /// Gets or sets the infiltration of refuge state.
    /// </summary>
    public LegacyQuestState InfiltrationOfRefugeState
    {
        get => (LegacyQuestState)this._data[5..].GetByteValue(2, 4);
        set => this._data[5..].SetByteValue((byte)value, 2, 4);
    }

    /// <summary>
    /// Gets or sets the unused quest state.
    /// </summary>
    public LegacyQuestState UnusedQuestState
    {
        get => (LegacyQuestState)this._data[5..].GetByteValue(2, 6);
        set => this._data[5..].SetByteValue((byte)value, 2, 6);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LegacyQuestStateList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LegacyQuestStateListRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LegacyQuestStateList"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LegacyQuestStateListRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the player clicks on the quest npc.
/// Causes reaction on client side: The game client shows the next steps in the quest dialog.
/// </summary>
public readonly ref struct LegacyQuestStateDialogRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestStateDialogRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LegacyQuestStateDialogRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestStateDialogRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LegacyQuestStateDialogRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA1;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest index.
    /// </summary>
    public byte QuestIndex
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets this is the complete byte with the state of four quests within the same byte.
    /// </summary>
    public byte State
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LegacyQuestStateDialog"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LegacyQuestStateDialogRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LegacyQuestStateDialog"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LegacyQuestStateDialogRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: As response to the set state request (C1A2).
/// Causes reaction on client side: The game client shows the new quest state.
/// </summary>
public readonly ref struct LegacySetQuestStateResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacySetQuestStateResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LegacySetQuestStateResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacySetQuestStateResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LegacySetQuestStateResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA2;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest index.
    /// </summary>
    public byte QuestIndex
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets this value is 0 if successful. Otherwise, 0xFF or even other magic values.
    /// </summary>
    public byte Result
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets this is the complete byte with the state of four quests within the same byte.
    /// </summary>
    public byte NewState
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LegacySetQuestStateResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LegacySetQuestStateResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LegacySetQuestStateResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LegacySetQuestStateResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: As response to the completed quest of a player in scope.
/// Causes reaction on client side: The game client shows the reward accordingly.
/// </summary>
public readonly ref struct LegacyQuestRewardRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestRewardRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LegacyQuestRewardRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestRewardRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LegacyQuestRewardRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA3;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data[3..]);
        set => WriteUInt16BigEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the reward.
    /// </summary>
    public LegacyQuestReward.QuestRewardType Reward
    {
        get => (LegacyQuestReward.QuestRewardType)this._data[5];
        set => this._data[5] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the count.
    /// </summary>
    public byte Count
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LegacyQuestReward"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LegacyQuestRewardRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LegacyQuestReward"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LegacyQuestRewardRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: As response when a player opens the quest npc with a running quest which requires monster kills.
/// Causes reaction on client side: The game client shows the current state.
/// </summary>
public readonly ref struct LegacyQuestMonsterKillInfoRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestMonsterKillInfoRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LegacyQuestMonsterKillInfoRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestMonsterKillInfoRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LegacyQuestMonsterKillInfoRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Result = 1;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA4;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 48;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public byte Result
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the quest index.
    /// </summary>
    public byte QuestIndex
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets the <see cref="MonsterKillInfoRef"/> of the specified index.
    /// </summary>
        public MonsterKillInfoRef this[int index] => new (this._data[(8 + index * MonsterKillInfoRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LegacyQuestMonsterKillInfo"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LegacyQuestMonsterKillInfoRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LegacyQuestMonsterKillInfo"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LegacyQuestMonsterKillInfoRef packet) => packet._data; 


/// <summary>
/// A pair of Monster number and the current kill count..
/// </summary>
public readonly ref struct MonsterKillInfoRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MonsterKillInfoRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MonsterKillInfoRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets or sets the monster number.
    /// </summary>
    public uint MonsterNumber
    {
        get => ReadUInt32LittleEndian(this._data);
        set => WriteUInt32LittleEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the kill count.
    /// </summary>
    public uint KillCount
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: After the client sent a PetAttackCommand (as confirmation), or when the previous command finished and the pet is reset to Normal-mode.
/// Causes reaction on client side: The client updates the pet mode in its user interface.
/// </summary>
public readonly ref struct PetModeRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PetModeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PetModeRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PetModeRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PetModeRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.Pet = ClientToServer.PetType.DarkRaven;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA7;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the pet.
    /// </summary>
    public ClientToServer.PetType Pet
    {
        get => (ClientToServer.PetType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the pet command mode.
    /// </summary>
    public ClientToServer.PetCommandMode PetCommandMode
    {
        get => (ClientToServer.PetCommandMode)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PetMode"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PetModeRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PetMode"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PetModeRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the client sent a PetAttackCommand, the pet attacks automatically. For each attack, the player and all observing players get this message.
/// Causes reaction on client side: The client shows the pet attacking the target.
/// </summary>
public readonly ref struct PetAttackRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PetAttackRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PetAttackRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PetAttackRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PetAttackRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.Pet = ClientToServer.PetType.DarkRaven;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA8;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the pet.
    /// </summary>
    public ClientToServer.PetType Pet
    {
        get => (ClientToServer.PetType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the skill type.
    /// </summary>
    public PetAttack.PetSkillType SkillType
    {
        get => (PetAttack.PetSkillType)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the owner id.
    /// </summary>
    public ushort OwnerId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data[7..]);
        set => WriteUInt16BigEndian(this._data[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PetAttack"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PetAttackRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PetAttack"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PetAttackRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the client sent a PetInfoRequest for a pet (dark raven, horse).
/// Causes reaction on client side: The client shows the information about the pet.
/// </summary>
public readonly ref struct PetInfoResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PetInfoResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PetInfoResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PetInfoResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PetInfoResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA9;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the pet.
    /// </summary>
    public ClientToServer.PetType Pet
    {
        get => (ClientToServer.PetType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the storage.
    /// </summary>
    public ClientToServer.StorageType Storage
    {
        get => (ClientToServer.StorageType)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public byte Level
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the experience.
    /// </summary>
    public uint Experience
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the health.
    /// </summary>
    public byte Health
    {
        get => this._data[12];
        set => this._data[12] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="PetInfoResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PetInfoResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PetInfoResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(PetInfoResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the client sent a DuelStartRequest, and it either failed or the requested player sent a response.
/// Causes reaction on client side: The client shows the started or aborted duel.
/// </summary>
public readonly ref struct DuelStartResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStartResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelStartResultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStartResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelStartResultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 17;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public DuelStartResult.DuelStartResultType Result
    {
        get => (DuelStartResult.DuelStartResultType)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the opponent id.
    /// </summary>
    public ushort OpponentId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the opponent name.
    /// </summary>
    public string OpponentName
    {
        get => this._data.ExtractString(7, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(7, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelStartResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelStartResultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelStartResult"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelStartResultRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After another client sent a DuelStartRequest, to ask the requested player for a response.
/// Causes reaction on client side: The client shows the duel request.
/// </summary>
public readonly ref struct DuelStartRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStartRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelStartRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStartRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelStartRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the requester id.
    /// </summary>
    public ushort RequesterId
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the requester name.
    /// </summary>
    public string RequesterName
    {
        get => this._data.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelStartRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelStartRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelStartRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelStartRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a duel ended.
/// Causes reaction on client side: The client updates its state.
/// </summary>
public readonly ref struct DuelEndRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelEndRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelEndRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelEndRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelEndRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Result = 0;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 17;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public byte Result
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the opponent id.
    /// </summary>
    public ushort OpponentId
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the opponent name.
    /// </summary>
    public string OpponentName
    {
        get => this._data.ExtractString(7, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(7, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelEnd"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelEndRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelEnd"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelEndRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the score of the duel has been changed.
/// Causes reaction on client side: The client updates the displayed duel score.
/// </summary>
public readonly ref struct DuelScoreRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelScoreRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelScoreRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelScoreRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelScoreRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x04;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player 1 id.
    /// </summary>
    public ushort Player1Id
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the player 2 id.
    /// </summary>
    public ushort Player2Id
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the player 1 score.
    /// </summary>
    public byte Player1Score
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the player 2 score.
    /// </summary>
    public byte Player2Score
    {
        get => this._data[9];
        set => this._data[9] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelScore"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelScoreRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelScore"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelScoreRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the health/shield of the duel players has been changed.
/// Causes reaction on client side: The client updates the displayed health and shield bars.
/// </summary>
public readonly ref struct DuelHealthUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelHealthUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelHealthUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelHealthUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelHealthUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player 1 id.
    /// </summary>
    public ushort Player1Id
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the player 2 id.
    /// </summary>
    public ushort Player2Id
    {
        get => ReadUInt16BigEndian(this._data[6..]);
        set => WriteUInt16BigEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the player 1 health percentage.
    /// </summary>
    public byte Player1HealthPercentage
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the player 2 health percentage.
    /// </summary>
    public byte Player2HealthPercentage
    {
        get => this._data[9];
        set => this._data[9] = value;
    }

    /// <summary>
    /// Gets or sets the player 1 shield percentage.
    /// </summary>
    public byte Player1ShieldPercentage
    {
        get => this._data[10];
        set => this._data[10] = value;
    }

    /// <summary>
    /// Gets or sets the player 2 shield percentage.
    /// </summary>
    public byte Player2ShieldPercentage
    {
        get => this._data[11];
        set => this._data[11] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelHealthUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelHealthUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelHealthUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelHealthUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the client requested the list of the current duel rooms.
/// Causes reaction on client side: The client shows the list of duel rooms.
/// </summary>
public readonly ref struct DuelStatusRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStatusRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelStatusRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStatusRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelStatusRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x06;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 92;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets the <see cref="DuelRoomStatusRef"/> of the specified index.
    /// </summary>
        public DuelRoomStatusRef this[int index] => new (this._data[(4 + index * DuelRoomStatusRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelStatus"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelStatusRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelStatus"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelStatusRef packet) => packet._data; 


/// <summary>
/// Structure for a duel room entry..
/// </summary>
public readonly ref struct DuelRoomStatusRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelRoomStatusRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelRoomStatusRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 22;

    /// <summary>
    /// Gets or sets the player 1 name.
    /// </summary>
    public string Player1Name
    {
        get => this._data.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the player 2 name.
    /// </summary>
    public string Player2Name
    {
        get => this._data.ExtractString(10, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(10, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the duel running.
    /// </summary>
    public bool DuelRunning
    {
        get => this._data[20..].GetBoolean();
        set => this._data[20..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the duel open.
    /// </summary>
    public bool DuelOpen
    {
        get => this._data[21..].GetBoolean();
        set => this._data[21..].SetBoolean(value);
    }
}
}


/// <summary>
/// Is sent by the server when: When the duel starts.
/// Causes reaction on client side: The client initializes the duel state.
/// </summary>
public readonly ref struct DuelInitRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelInitRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelInitRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelInitRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelInitRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 30;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public byte Result
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the room index.
    /// </summary>
    public byte RoomIndex
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the player 1 name.
    /// </summary>
    public string Player1Name
    {
        get => this._data.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the player 2 name.
    /// </summary>
    public string Player2Name
    {
        get => this._data.ExtractString(16, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(16, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the player 1 id.
    /// </summary>
    public ushort Player1Id
    {
        get => ReadUInt16BigEndian(this._data[26..]);
        set => WriteUInt16BigEndian(this._data[26..], value);
    }

    /// <summary>
    /// Gets or sets the player 2 id.
    /// </summary>
    public ushort Player2Id
    {
        get => ReadUInt16BigEndian(this._data[28..]);
        set => WriteUInt16BigEndian(this._data[28..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelInit"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelInitRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelInit"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelInitRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the duel starts, after the DuelInit message.
/// Causes reaction on client side: The client updates the displayed health and shield bars.
/// </summary>
public readonly ref struct DuelHealthBarInitRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelHealthBarInitRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelHealthBarInitRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelHealthBarInitRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelHealthBarInitRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelHealthBarInit"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelHealthBarInitRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelHealthBarInit"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelHealthBarInitRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When a spectator joins a duel.
/// Causes reaction on client side: The client updates the list of spectators.
/// </summary>
public readonly ref struct DuelSpectatorAddedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorAddedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelSpectatorAddedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorAddedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelSpectatorAddedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x08;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelSpectatorAdded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelSpectatorAddedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelSpectatorAdded"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelSpectatorAddedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When a spectator joins a duel.
/// Causes reaction on client side: The client updates the list of spectators.
/// </summary>
public readonly ref struct DuelSpectatorRemovedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorRemovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelSpectatorRemovedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorRemovedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelSpectatorRemovedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelSpectatorRemoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelSpectatorRemovedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelSpectatorRemoved"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelSpectatorRemovedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When a spectator joins or leaves a duel.
/// Causes reaction on client side: The client updates the list of spectators.
/// </summary>
public readonly ref struct DuelSpectatorListRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelSpectatorListRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelSpectatorListRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 105;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the count.
    /// </summary>
    public byte Count
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="DuelSpectatorRef"/> of the specified index.
    /// </summary>
        public DuelSpectatorRef this[int index] => new (this._data[(5 + index * DuelSpectatorRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelSpectatorList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelSpectatorListRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelSpectatorList"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelSpectatorListRef packet) => packet._data; 


/// <summary>
/// Structure for a duel room entry..
/// </summary>
public readonly ref struct DuelSpectatorRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelSpectatorRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
    }
}
}


/// <summary>
/// Is sent by the server when: When the duel finished.
/// Causes reaction on client side: The client shows the winner and loser names.
/// </summary>
public readonly ref struct DuelFinishedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelFinishedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelFinishedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelFinishedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelFinishedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the winner.
    /// </summary>
    public string Winner
    {
        get => this._data.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the loser.
    /// </summary>
    public string Loser
    {
        get => this._data.ExtractString(14, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(14, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DuelFinished"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelFinishedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelFinished"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DuelFinishedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a player started a skill which needs to load up, like Nova.
/// Causes reaction on client side: The client may show the loading intensity.
/// </summary>
public readonly ref struct SkillStageUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillStageUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillStageUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillStageUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillStageUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.SkillNumber = 0x28;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBA;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16LittleEndian(this._data[3..]);
        set => WriteUInt16LittleEndian(this._data[3..], value);
    }

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public byte SkillNumber
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the stage.
    /// </summary>
    public byte Stage
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillStageUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillStageUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillStageUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(SkillStageUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to enter the illusion temple event.
/// Causes reaction on client side: The client shows the result.
/// </summary>
public readonly ref struct IllusionTempleEnterResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleEnterResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleEnterResultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleEnterResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleEnterResultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public byte Result
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IllusionTempleEnterResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleEnterResultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleEnterResult"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IllusionTempleEnterResultRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player is in the illusion temple event and the server sends a cyclic update.
/// Causes reaction on client side: The client shows the state in the user interface.
/// </summary>
public readonly ref struct IllusionTempleStateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleStateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleStateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the remaining seconds.
    /// </summary>
    public ushort RemainingSeconds
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the player index.
    /// </summary>
    public ushort PlayerIndex
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the team 1 points.
    /// </summary>
    public byte Team1Points
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the team 2 points.
    /// </summary>
    public byte Team2Points
    {
        get => this._data[9];
        set => this._data[9] = value;
    }

    /// <summary>
    /// Gets or sets the my team.
    /// </summary>
    public byte MyTeam
    {
        get => this._data[10];
        set => this._data[10] = value;
    }

    /// <summary>
    /// Gets or sets the party count.
    /// </summary>
    public byte PartyCount
    {
        get => this._data[11];
        set => this._data[11] = value;
    }

    /// <summary>
    /// Gets the <see cref="IllusionTemplePartyEntryRef"/> of the specified index.
    /// </summary>
        public IllusionTemplePartyEntryRef this[int index] => new (this._data[(12 + index * IllusionTemplePartyEntryRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IllusionTempleState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleStateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleState"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IllusionTempleStateRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="IllusionTemplePartyEntryRef"/>.
    /// </summary>
    /// <param name="partyMembersCount">The count of <see cref="IllusionTemplePartyEntryRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int partyMembersCount) => partyMembersCount * IllusionTemplePartyEntryRef.Length + 12;


/// <summary>
/// Contains the info about a party member in illusion temple..
/// </summary>
public readonly ref struct IllusionTemplePartyEntryRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTemplePartyEntryRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTemplePartyEntryRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16LittleEndian(this._data);
        set => WriteUInt16LittleEndian(this._data, value);
    }

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public ushort MapNumber
    {
        get => ReadUInt16LittleEndian(this._data[2..]);
        set => WriteUInt16LittleEndian(this._data[2..], value);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data[4];
        set => this._data[4] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: A player requested to use a specific skill in the illusion temple event.
/// Causes reaction on client side: The client shows the result.
/// </summary>
public readonly ref struct IllusionTempleSkillUsageResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillUsageResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleSkillUsageResultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillUsageResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleSkillUsageResultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 11;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public byte Result
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16BigEndian(this._data[5..]);
        set => WriteUInt16BigEndian(this._data[5..], value);
    }

    /// <summary>
    /// Gets or sets the source object id.
    /// </summary>
    public ushort SourceObjectId
    {
        get => ReadUInt16LittleEndian(this._data[7..]);
        set => WriteUInt16LittleEndian(this._data[7..], value);
    }

    /// <summary>
    /// Gets or sets the target object id.
    /// </summary>
    public ushort TargetObjectId
    {
        get => ReadUInt16LittleEndian(this._data[9..]);
        set => WriteUInt16LittleEndian(this._data[9..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IllusionTempleSkillUsageResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleSkillUsageResultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleSkillUsageResult"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IllusionTempleSkillUsageResultRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: ?
/// Causes reaction on client side: The client shows the counts.
/// </summary>
public readonly ref struct IllusionTempleUserCountRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleUserCountRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleUserCountRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleUserCountRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleUserCountRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the user count 1.
    /// </summary>
    public byte UserCount1
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the user count 2.
    /// </summary>
    public byte UserCount2
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the user count 3.
    /// </summary>
    public byte UserCount3
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets or sets the user count 4.
    /// </summary>
    public byte UserCount4
    {
        get => this._data[7];
        set => this._data[7] = value;
    }

    /// <summary>
    /// Gets or sets the user count 5.
    /// </summary>
    public byte UserCount5
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the user count 6.
    /// </summary>
    public byte UserCount6
    {
        get => this._data[9];
        set => this._data[9] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IllusionTempleUserCount"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleUserCountRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleUserCount"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IllusionTempleUserCountRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The illusion temple event ended.
/// Causes reaction on client side: The client shows the results.
/// </summary>
public readonly ref struct IllusionTempleResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleResultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleResultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x04;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the team 1 points.
    /// </summary>
    public byte Team1Points
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the team 2 points.
    /// </summary>
    public byte Team2Points
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the player count.
    /// </summary>
    public byte PlayerCount
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets the <see cref="PlayerResultRef"/> of the specified index.
    /// </summary>
        public PlayerResultRef this[int index] => new (this._data[(10 + index * PlayerResultRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IllusionTempleResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleResultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleResult"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IllusionTempleResultRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PlayerResultRef"/>.
    /// </summary>
    /// <param name="playersCount">The count of <see cref="PlayerResultRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int playersCount) => playersCount * PlayerResultRef.Length + 10;


/// <summary>
/// Contains the result of a player in the event..
/// </summary>
public readonly ref struct PlayerResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerResultRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 17;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(0, this._data.Length - 0, System.Text.Encoding.UTF8);
        set => this._data.Slice(0).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public byte MapNumber
    {
        get => this._data[10];
        set => this._data[10] = value;
    }

    /// <summary>
    /// Gets or sets the team.
    /// </summary>
    public byte Team
    {
        get => this._data[11];
        set => this._data[11] = value;
    }

    /// <summary>
    /// Gets or sets the class.
    /// </summary>
    public byte Class
    {
        get => this._data[12];
        set => this._data[12] = value;
    }

    /// <summary>
    /// Gets or sets the added experience.
    /// </summary>
    public uint AddedExperience
    {
        get => ReadUInt32LittleEndian(this._data[13..]);
        set => WriteUInt32LittleEndian(this._data[13..], value);
    }

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Name' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 0;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Name' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 0;
}
}


/// <summary>
/// Is sent by the server when: ?
/// Causes reaction on client side: The client shows the skill points.
/// </summary>
public readonly ref struct IllusionTempleSkillPointUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillPointUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleSkillPointUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillPointUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleSkillPointUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x06;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill points.
    /// </summary>
    public byte SkillPoints
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IllusionTempleSkillPointUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleSkillPointUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleSkillPointUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IllusionTempleSkillPointUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: ?
/// Causes reaction on client side: The client shows the skill points.
/// </summary>
public readonly ref struct IllusionTempleSkillEndedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillEndedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleSkillEndedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillEndedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleSkillEndedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the object index.
    /// </summary>
    public ushort ObjectIndex
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IllusionTempleSkillEnded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleSkillEndedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleSkillEnded"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IllusionTempleSkillEndedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: ?
/// Causes reaction on client side: ?.
/// </summary>
public readonly ref struct IllusionTempleHolyItemRelicsRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleHolyItemRelicsRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleHolyItemRelicsRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleHolyItemRelicsRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleHolyItemRelicsRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x08;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the user index.
    /// </summary>
    public ushort UserIndex
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(6, this._data.Length - 6, System.Text.Encoding.UTF8);
        set => this._data.Slice(6).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IllusionTempleHolyItemRelics"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleHolyItemRelicsRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleHolyItemRelics"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IllusionTempleHolyItemRelicsRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Name' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 6;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Name' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 6;
}


/// <summary>
/// Is sent by the server when: ?
/// Causes reaction on client side: The client shows the skill points.
/// </summary>
public readonly ref struct IllusionTempleSkillEndRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillEndRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleSkillEndRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillEndRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleSkillEndRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the temple number.
    /// </summary>
    public byte TempleNumber
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the state.
    /// </summary>
    public byte State
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="IllusionTempleSkillEnd"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleSkillEndRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleSkillEnd"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(IllusionTempleSkillEndRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player applied chain lightning to a target and the server calculated the hits.
/// Causes reaction on client side: The client shows the chain lightning effect.
/// </summary>
public readonly ref struct ChainLightningHitInfoRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChainLightningHitInfoRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChainLightningHitInfoRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChainLightningHitInfoRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChainLightningHitInfoRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0A;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16BigEndian(this._data[4..]);
        set => WriteUInt16BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the target count.
    /// </summary>
    public byte TargetCount
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets the <see cref="ChainTargetRef"/> of the specified index.
    /// </summary>
        public ChainTargetRef this[int index] => new (this._data[(10 + index * ChainTargetRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ChainLightningHitInfo"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChainLightningHitInfoRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChainLightningHitInfo"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ChainLightningHitInfoRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="ChainTargetRef"/>.
    /// </summary>
    /// <param name="targetsCount">The count of <see cref="ChainTargetRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int targetsCount) => targetsCount * ChainTargetRef.Length + 10;


/// <summary>
/// Contains the target identifier..
/// </summary>
public readonly ref struct ChainTargetRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChainTargetRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChainTargetRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 2;

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16LittleEndian(this._data);
        set => WriteUInt16LittleEndian(this._data, value);
    }
}
}


/// <summary>
/// Is sent by the server when: The server validated or changed the status of the MU Helper.
/// Causes reaction on client side: The client toggle the MU Helper status.
/// </summary>
public readonly ref struct MuHelperStatusUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MuHelperStatusUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MuHelperStatusUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MuHelperStatusUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MuHelperStatusUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x51;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag, if money should be consumed. If this is 'true', setting PauseStatus to 'false' doesn't cause starting the helper.
    /// </summary>
    public bool ConsumeMoney
    {
        get => this._data[4..].GetBoolean();
        set => this._data[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the pause status. A value of 'true' always works to stop the helper. However, it can only be started, with ConsumeMoney set to 'false'.
    /// </summary>
    public bool PauseStatus
    {
        get => this._data[12..].GetBoolean();
        set => this._data[12..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MuHelperStatusUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MuHelperStatusUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MuHelperStatusUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MuHelperStatusUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The server saved the users MU Helper data.
/// Causes reaction on client side: The user wants to save the MU Helper data.
/// </summary>
public readonly ref struct MuHelperConfigurationDataRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MuHelperConfigurationDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MuHelperConfigurationDataRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MuHelperConfigurationDataRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MuHelperConfigurationDataRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAE;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 261;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the helper data.
    /// </summary>
    public Span<byte> HelperData
    {
        get => this._data.Slice(4, 257);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MuHelperConfigurationData"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MuHelperConfigurationDataRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MuHelperConfigurationData"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MuHelperConfigurationDataRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After entering the game with a character.
/// Causes reaction on client side: 
/// </summary>
public readonly ref struct MessengerInitializationRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MessengerInitializationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MessengerInitializationRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MessengerInitializationRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MessengerInitializationRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC0;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the letter count.
    /// </summary>
    public byte LetterCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the maximum letter count.
    /// </summary>
    public byte MaximumLetterCount
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets the friend count.
    /// </summary>
    public byte FriendCount
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Gets the <see cref="FriendRef"/> of the specified index.
    /// </summary>
        public FriendRef this[int index] => new (this._data[(7 + index * FriendRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MessengerInitialization"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MessengerInitializationRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MessengerInitialization"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MessengerInitializationRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="FriendRef"/>.
    /// </summary>
    /// <param name="friendsCount">The count of <see cref="FriendRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int friendsCount) => friendsCount * FriendRef.Length + 7;


/// <summary>
/// The structure which contains the friend name and online state..
/// </summary>
public readonly ref struct FriendRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 11;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the server id on which the player currently is online. 0xFF means offline.
    /// </summary>
    public byte ServerId
    {
        get => this._data[10];
        set => this._data[10] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: After a friend has been added to the friend list.
/// Causes reaction on client side: The friend appears in the friend list.
/// </summary>
public readonly ref struct FriendAddedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendAddedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendAddedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendAddedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendAddedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.ServerId = 0xFF;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 15;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the friend name.
    /// </summary>
    public string FriendName
    {
        get => this._data.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the server id on which the player currently is online. 0xFF means offline.
    /// </summary>
    public byte ServerId
    {
        get => this._data[14];
        set => this._data[14] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendAdded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendAddedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendAdded"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(FriendAddedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a player has requested to add another player as friend. This other player gets this message.
/// Causes reaction on client side: The friend request appears on the user interface.
/// </summary>
public readonly ref struct FriendRequestRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendRequestRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendRequestRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendRequestRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC2;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the requester.
    /// </summary>
    public string Requester
    {
        get => this._data.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendRequestRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendRequest"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(FriendRequestRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a friend has been removed from the friend list.
/// Causes reaction on client side: The friend is removed from the friend list.
/// </summary>
public readonly ref struct FriendDeletedRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendDeletedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendDeletedRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendDeletedRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendDeletedRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the friend name.
    /// </summary>
    public string FriendName
    {
        get => this._data.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendDeleted"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendDeletedRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendDeleted"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(FriendDeletedRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a friend has been added to the friend list.
/// Causes reaction on client side: The friend appears in the friend list.
/// </summary>
public readonly ref struct FriendOnlineStateUpdateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendOnlineStateUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendOnlineStateUpdateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendOnlineStateUpdateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendOnlineStateUpdateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC4;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the friend name.
    /// </summary>
    public string FriendName
    {
        get => this._data.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the server id on which the player currently is online. 0xFF means offline.
    /// </summary>
    public byte ServerId
    {
        get => this._data[13];
        set => this._data[13] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendOnlineStateUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendOnlineStateUpdateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendOnlineStateUpdate"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(FriendOnlineStateUpdateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to send a letter to another player.
/// Causes reaction on client side: Depending on the result, the letter send dialog closes or an error message appears.
/// </summary>
public readonly ref struct LetterSendResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LetterSendResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LetterSendResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LetterSendResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LetterSendResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC5;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the letter id.
    /// </summary>
    public uint LetterId
    {
        get => ReadUInt32LittleEndian(this._data[4..]);
        set => WriteUInt32LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public LetterSendResponse.LetterSendRequestResult Result
    {
        get => (LetterSendResponse.LetterSendRequestResult)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="LetterSendResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LetterSendResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LetterSendResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(LetterSendResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a letter has been received or after the player entered the game with a character.
/// Causes reaction on client side: The letter appears in the letter list.
/// </summary>
public readonly ref struct AddLetterRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddLetterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddLetterRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddLetterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddLetterRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC6;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 79;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the letter index.
    /// </summary>
    public ushort LetterIndex
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the sender name.
    /// </summary>
    public string SenderName
    {
        get => this._data.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the timestamp.
    /// </summary>
    public string Timestamp
    {
        get => this._data.ExtractString(16, 30, System.Text.Encoding.UTF8);
        set => this._data.Slice(16, 30).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the subject.
    /// </summary>
    public string Subject
    {
        get => this._data.ExtractString(46, 32, System.Text.Encoding.UTF8);
        set => this._data.Slice(46, 32).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the state.
    /// </summary>
    public AddLetter.LetterState State
    {
        get => (AddLetter.LetterState)this._data[78];
        set => this._data[78] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AddLetter"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddLetterRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddLetter"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AddLetterRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to read a letter.
/// Causes reaction on client side: The letter is opened in a new dialog.
/// </summary>
public readonly ref struct OpenLetterRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenLetterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public OpenLetterRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenLetterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private OpenLetterRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC4;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C4HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the letter index.
    /// </summary>
    public ushort LetterIndex
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the message size.
    /// </summary>
    public ushort MessageSize
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the sender appearance.
    /// </summary>
    public Span<byte> SenderAppearance
    {
        get => this._data.Slice(8, 18);
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data[26];
        set => this._data[26] = value;
    }

    /// <summary>
    /// Gets or sets the animation.
    /// </summary>
    public byte Animation
    {
        get => this._data[27];
        set => this._data[27] = value;
    }

    /// <summary>
    /// Gets or sets the message.
    /// </summary>
    public string Message
    {
        get => this._data.ExtractString(28, this._data.Length - 28, System.Text.Encoding.UTF8);
        set => this._data.Slice(28).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="OpenLetter"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator OpenLetterRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="OpenLetter"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(OpenLetterRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 28;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 28;
}


/// <summary>
/// Is sent by the server when: After a letter has been deleted by the request of the player.
/// Causes reaction on client side: The letter is removed from the letter list.
/// </summary>
public readonly ref struct RemoveLetterRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RemoveLetterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RemoveLetterRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RemoveLetterRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RemoveLetterRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.RequestSuccessful = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC8;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the request successful.
    /// </summary>
    public bool RequestSuccessful
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the letter index.
    /// </summary>
    public ushort LetterIndex
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="RemoveLetter"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RemoveLetterRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RemoveLetter"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(RemoveLetterRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player is invited to join a chat room on the chat server.
/// Causes reaction on client side: The game client connects to the chat server and joins the chat room with the specified authentication data.
/// </summary>
public readonly ref struct ChatRoomConnectionInfoRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatRoomConnectionInfoRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChatRoomConnectionInfoRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatRoomConnectionInfoRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChatRoomConnectionInfoRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.Type = 1;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xCA;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 36;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the chat server ip.
    /// </summary>
    public string ChatServerIp
    {
        get => this._data.ExtractString(3, 15, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 15).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the chat room id.
    /// </summary>
    public ushort ChatRoomId
    {
        get => ReadUInt16LittleEndian(this._data[18..]);
        set => WriteUInt16LittleEndian(this._data[18..], value);
    }

    /// <summary>
    /// Gets or sets the authentication token.
    /// </summary>
    public uint AuthenticationToken
    {
        get => ReadUInt32LittleEndian(this._data[20..]);
        set => WriteUInt32LittleEndian(this._data[20..], value);
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[24];
        set => this._data[24] = value;
    }

    /// <summary>
    /// Gets or sets the friend name.
    /// </summary>
    public string FriendName
    {
        get => this._data.ExtractString(25, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(25, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[35..].GetBoolean();
        set => this._data[35..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ChatRoomConnectionInfo"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChatRoomConnectionInfoRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChatRoomConnectionInfo"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ChatRoomConnectionInfoRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to add another player to his friend list and the server processed this request.
/// Causes reaction on client side: The game client knows if the invitation could be sent to the other player.
/// </summary>
public readonly ref struct FriendInvitationResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendInvitationResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendInvitationResultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendInvitationResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendInvitationResultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xCB;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the request id.
    /// </summary>
    public uint RequestId
    {
        get => ReadUInt32BigEndian(this._data[4..]);
        set => WriteUInt32BigEndian(this._data[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendInvitationResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendInvitationResultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendInvitationResult"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(FriendInvitationResultRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the game client requested the list of event quests after entering the game. It seems to be sent only if the character is not a member of a Gen.
/// Causes reaction on client side: Unknown.
/// </summary>
public readonly ref struct QuestEventResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestEventResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestEventResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestEventResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestEventResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets the <see cref="QuestIdentificationRef"/> of the specified index.
    /// </summary>
        public QuestIdentificationRef this[int index] => new (this._data[(4 + index * QuestIdentificationRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestEventResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestEventResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestEventResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestEventResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the game client requested the list of available quests through an NPC dialog.
/// Causes reaction on client side: The client shows the available quests for the currently interacting NPC.
/// </summary>
public readonly ref struct AvailableQuestsRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AvailableQuestsRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AvailableQuestsRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AvailableQuestsRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AvailableQuestsRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0A;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest npc number.
    /// </summary>
    public ushort QuestNpcNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest count.
    /// </summary>
    public ushort QuestCount
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets the <see cref="QuestIdentificationRef"/> of the specified index.
    /// </summary>
        public QuestIdentificationRef this[int index] => new (this._data[(8 + index * QuestIdentificationRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="AvailableQuests"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AvailableQuestsRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AvailableQuests"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(AvailableQuestsRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="QuestIdentificationRef"/>.
    /// </summary>
    /// <param name="questsCount">The count of <see cref="QuestIdentificationRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int questsCount) => questsCount * QuestIdentificationRef.Length + 8;
}


/// <summary>
/// Is sent by the server when: After the game client clicked on a quest in the quest list, proceeded with a quest or refused to start a quest.
/// Causes reaction on client side: The client shows the corresponding description about the current quest step.
/// </summary>
public readonly ref struct QuestStepInfoRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStepInfoRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestStepInfoRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStepInfoRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestStepInfoRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 11;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets a number specifying the description: A) when selecting a quest in the quest list, it's the "StartingNumber"; B) when a quest has been started it's the quest number; C) when the starting number has been sent previously and the player refused to start the quest, it sends a "RefuseNumber".
    /// </summary>
    public ushort QuestStepNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestStepInfo"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestStepInfoRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestStepInfo"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestStepInfoRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: First, after the game client requested to initialize a quest and the quest is already active. Second, after the game client requested the next quest step.
/// Causes reaction on client side: The client shows the quest progress accordingly.
/// </summary>
public readonly ref struct QuestProgressRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestProgressRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestProgressRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestProgressRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestProgressRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 251;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the condition count.
    /// </summary>
    public byte ConditionCount
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the reward count.
    /// </summary>
    public byte RewardCount
    {
        get => this._data[9];
        set => this._data[9] = value;
    }

    /// <summary>
    /// Gets the <see cref="QuestConditionRef"/> of the specified index.
    /// </summary>
    public QuestConditionRef GetQuestCondition(int index) => new (this._data[(11 + index * QuestConditionRef.Length)..]);

    /// <summary>
    /// Gets the <see cref="QuestRewardRef"/> of the specified index.
    /// </summary>
    public QuestRewardRef GetQuestReward(int index) => new (this._data[(141 + index * QuestRewardRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestProgress"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestProgressRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestProgress"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestProgressRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="QuestConditionRef"/>.
    /// </summary>
    /// <param name="conditionsCount">The count of <see cref="QuestConditionRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int conditionsCount) => conditionsCount * QuestConditionRef.Length + 11;
}


/// <summary>
/// Is sent by the server when: The server acknowledges the completion of a quest.
/// Causes reaction on client side: The client shows the success and possibly requests for the next available quests.
/// </summary>
public readonly ref struct QuestCompletionResponseRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCompletionResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestCompletionResponseRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCompletionResponseRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestCompletionResponseRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the is quest completed.
    /// </summary>
    public bool IsQuestCompleted
    {
        get => this._data[8..].GetBoolean();
        set => this._data[8..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestCompletionResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestCompletionResponseRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestCompletionResponse"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestCompletionResponseRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The server acknowledges the requested cancellation of a quest.
/// Causes reaction on client side: The client resets the state of the quest and can request a new list of available quests again. This list would then probably contain the cancelled quest again.
/// </summary>
public readonly ref struct QuestCancelledRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCancelledRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestCancelledRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCancelledRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestCancelledRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0F;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the current quest number. In this message, it's always 0, because the group is relevant for the client.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestCancelled"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestCancelledRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestCancelled"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestCancelledRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the game client requested the list of all quests which are currently in progress or accepted.
/// Causes reaction on client side: Unknown.
/// </summary>
public readonly ref struct QuestStateListRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStateListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestStateListRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStateListRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestStateListRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x1A;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest count.
    /// </summary>
    public byte QuestCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="QuestIdentificationRef"/> of the specified index.
    /// </summary>
        public QuestIdentificationRef this[int index] => new (this._data[(5 + index * QuestIdentificationRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestStateList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestStateListRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestStateList"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestStateListRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="QuestIdentificationRef"/>.
    /// </summary>
    /// <param name="questsCount">The count of <see cref="QuestIdentificationRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int questsCount) => questsCount * QuestIdentificationRef.Length + 5;
}


/// <summary>
/// Is sent by the server when: After the game client requested it, when the player opened the quest menu and clicked on a quest.
/// Causes reaction on client side: The client shows the quest progress accordingly.
/// </summary>
public readonly ref struct QuestStateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestStateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestStateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x1B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 251;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the condition count.
    /// </summary>
    public byte ConditionCount
    {
        get => this._data[8];
        set => this._data[8] = value;
    }

    /// <summary>
    /// Gets or sets the reward count.
    /// </summary>
    public byte RewardCount
    {
        get => this._data[9];
        set => this._data[9] = value;
    }

    /// <summary>
    /// Gets or sets the random reward count.
    /// </summary>
    public byte RandomRewardCount
    {
        get => this._data[10];
        set => this._data[10] = value;
    }

    /// <summary>
    /// Gets the <see cref="QuestConditionRef"/> of the specified index.
    /// </summary>
    public QuestConditionRef GetQuestCondition(int index) => new (this._data[(11 + index * QuestConditionRef.Length)..]);

    /// <summary>
    /// Gets the <see cref="QuestRewardRef"/> of the specified index.
    /// </summary>
    public QuestRewardRef GetQuestReward(int index) => new (this._data[(141 + index * QuestRewardRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestStateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestState"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(QuestStateRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="QuestConditionRef"/>.
    /// </summary>
    /// <param name="conditionsCount">The count of <see cref="QuestConditionRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int conditionsCount) => conditionsCount * QuestConditionRef.Length + 11;
}


/// <summary>
/// Is sent by the server when: The server acknowledges the requested opening of an npc dialog.
/// Causes reaction on client side: The client opens the dialog of the specified npc.
/// </summary>
public readonly ref struct OpenNpcDialogRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenNpcDialogRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public OpenNpcDialogRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenNpcDialogRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private OpenNpcDialogRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF9;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the npc number.
    /// </summary>
    public ushort NpcNumber
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the gens contribution points.
    /// </summary>
    public uint GensContributionPoints
    {
        get => ReadUInt32LittleEndian(this._data[8..]);
        set => WriteUInt32LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="OpenNpcDialog"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator OpenNpcDialogRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="OpenNpcDialog"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(OpenNpcDialogRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to enter the devil square mini game through the Charon NPC.
/// Causes reaction on client side: In case it failed, it shows the corresponding error message.
/// </summary>
public readonly ref struct DevilSquareEnterResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DevilSquareEnterResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DevilSquareEnterResultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DevilSquareEnterResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DevilSquareEnterResultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x90;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public DevilSquareEnterResult.EnterResult Result
    {
        get => (DevilSquareEnterResult.EnterResult)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="DevilSquareEnterResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DevilSquareEnterResultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DevilSquareEnterResult"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(DevilSquareEnterResultRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requests to get the current opening state of a mini game event, by clicking on an ticket item.
/// Causes reaction on client side: The opening state of the event (remaining entering time, etc.) is shown at the client.
/// </summary>
public readonly ref struct MiniGameOpeningStateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MiniGameOpeningStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MiniGameOpeningStateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MiniGameOpeningStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MiniGameOpeningStateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x91;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the game type.
    /// </summary>
    public MiniGameType GameType
    {
        get => (MiniGameType)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the remaining entering time minutes.
    /// </summary>
    public byte RemainingEnteringTimeMinutes
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the user count.
    /// </summary>
    public byte UserCount
    {
        get => this._data[5];
        set => this._data[5] = value;
    }

    /// <summary>
    /// Gets or sets just used for Chaos Castle. In this case, this field contains the lower byte of the remaining minutes. For other event types, this field is not used.
    /// </summary>
    public byte RemainingEnteringTimeMinutesLow
    {
        get => this._data[6];
        set => this._data[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MiniGameOpeningState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MiniGameOpeningStateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MiniGameOpeningState"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MiniGameOpeningStateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The state of a mini game event is about to change in 30 seconds.
/// Causes reaction on client side: The client side shows a message about the changing state.
/// </summary>
public readonly ref struct UpdateMiniGameStateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="UpdateMiniGameStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public UpdateMiniGameStateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="UpdateMiniGameStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private UpdateMiniGameStateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x92;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the state.
    /// </summary>
    public UpdateMiniGameState.MiniGameTypeState State
    {
        get => (UpdateMiniGameState.MiniGameTypeState)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="UpdateMiniGameState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator UpdateMiniGameStateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="UpdateMiniGameState"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(UpdateMiniGameStateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A mini game ended and the score table is sent to the player.
/// Causes reaction on client side: The score table is shown at the client.
/// </summary>
public readonly ref struct MiniGameScoreTableRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MiniGameScoreTableRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MiniGameScoreTableRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MiniGameScoreTableRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MiniGameScoreTableRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x93;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the player rank.
    /// </summary>
    public byte PlayerRank
    {
        get => this._data[3];
        set => this._data[3] = value;
    }

    /// <summary>
    /// Gets or sets the result count.
    /// </summary>
    public byte ResultCount
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="ResultItemRef"/> of the specified index.
    /// </summary>
        public ResultItemRef this[int index] => new (this._data[(5 + index * ResultItemRef.Length)..]);

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MiniGameScoreTable"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MiniGameScoreTableRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MiniGameScoreTable"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MiniGameScoreTableRef packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="ResultItemRef"/>.
    /// </summary>
    /// <param name="resultsCount">The count of <see cref="ResultItemRef"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int resultsCount) => resultsCount * ResultItemRef.Length + 5;


/// <summary>
/// The result of one player..
/// </summary>
public readonly ref struct ResultItemRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ResultItemRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ResultItemRef(Span<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the total score.
    /// </summary>
    public uint TotalScore
    {
        get => ReadUInt32LittleEndian(this._data[12..]);
        set => WriteUInt32LittleEndian(this._data[12..], value);
    }

    /// <summary>
    /// Gets or sets the bonus experience.
    /// </summary>
    public uint BonusExperience
    {
        get => ReadUInt32LittleEndian(this._data[16..]);
        set => WriteUInt32LittleEndian(this._data[16..], value);
    }

    /// <summary>
    /// Gets or sets the bonus money.
    /// </summary>
    public uint BonusMoney
    {
        get => ReadUInt32LittleEndian(this._data[20..]);
        set => WriteUInt32LittleEndian(this._data[20..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: The blood castle mini game ended and the score of the player is sent to the player.
/// Causes reaction on client side: The score is shown at the client.
/// </summary>
public readonly ref struct BloodCastleScoreRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleScoreRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public BloodCastleScoreRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleScoreRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private BloodCastleScoreRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.Type = 0xFF;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x93;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 29;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data[4];
        set => this._data[4] = value;
    }

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.ExtractString(5, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(5, 10).WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the total score.
    /// </summary>
    public uint TotalScore
    {
        get => ReadUInt32LittleEndian(this._data[17..]);
        set => WriteUInt32LittleEndian(this._data[17..], value);
    }

    /// <summary>
    /// Gets or sets the bonus experience.
    /// </summary>
    public uint BonusExperience
    {
        get => ReadUInt32LittleEndian(this._data[21..]);
        set => WriteUInt32LittleEndian(this._data[21..], value);
    }

    /// <summary>
    /// Gets or sets the bonus money.
    /// </summary>
    public uint BonusMoney
    {
        get => ReadUInt32LittleEndian(this._data[25..]);
        set => WriteUInt32LittleEndian(this._data[25..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="BloodCastleScore"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator BloodCastleScoreRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="BloodCastleScore"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(BloodCastleScoreRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to enter the blood castle mini game through the Archangel Messenger NPC.
/// Causes reaction on client side: In case it failed, it shows the corresponding error message.
/// </summary>
public readonly ref struct BloodCastleEnterResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleEnterResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public BloodCastleEnterResultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleEnterResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private BloodCastleEnterResultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x9A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public BloodCastleEnterResult.EnterResult Result
    {
        get => (BloodCastleEnterResult.EnterResult)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="BloodCastleEnterResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator BloodCastleEnterResultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="BloodCastleEnterResult"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(BloodCastleEnterResultRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The state of a blood castle event is about to change.
/// Causes reaction on client side: The client side shows a message about the changing state.
/// </summary>
public readonly ref struct BloodCastleStateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public BloodCastleStateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private BloodCastleStateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x9B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the state.
    /// </summary>
    public BloodCastleState.Status State
    {
        get => (BloodCastleState.Status)this._data[3];
        set => this._data[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the remain second.
    /// </summary>
    public ushort RemainSecond
    {
        get => ReadUInt16LittleEndian(this._data[4..]);
        set => WriteUInt16LittleEndian(this._data[4..], value);
    }

    /// <summary>
    /// Gets or sets the max monster.
    /// </summary>
    public ushort MaxMonster
    {
        get => ReadUInt16LittleEndian(this._data[6..]);
        set => WriteUInt16LittleEndian(this._data[6..], value);
    }

    /// <summary>
    /// Gets or sets the cur monster.
    /// </summary>
    public ushort CurMonster
    {
        get => ReadUInt16LittleEndian(this._data[8..]);
        set => WriteUInt16LittleEndian(this._data[8..], value);
    }

    /// <summary>
    /// Gets or sets the item owner id.
    /// </summary>
    public ushort ItemOwnerId
    {
        get => ReadUInt16LittleEndian(this._data[10..]);
        set => WriteUInt16LittleEndian(this._data[10..], value);
    }

    /// <summary>
    /// Gets or sets the item level.
    /// </summary>
    public byte ItemLevel
    {
        get => this._data[12];
        set => this._data[12] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="BloodCastleState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator BloodCastleStateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="BloodCastleState"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(BloodCastleStateRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to enter the chaos castle mini game by using the 'Armor of Guardsman' item.
/// Causes reaction on client side: In case it failed, it shows the corresponding error message.
/// </summary>
public readonly ref struct ChaosCastleEnterResultRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChaosCastleEnterResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChaosCastleEnterResultRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChaosCastleEnterResultRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChaosCastleEnterResultRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCodeRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public ChaosCastleEnterResult.EnterResult Result
    {
        get => (ChaosCastleEnterResult.EnterResult)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="ChaosCastleEnterResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChaosCastleEnterResultRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChaosCastleEnterResult"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(ChaosCastleEnterResultRef packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The state of event is about to change.
/// Causes reaction on client side: The event's effect is shown.
/// </summary>
public readonly ref struct MapEventStateRef
{
    private readonly Span<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MapEventStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MapEventStateRef(Span<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MapEventStateRef"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MapEventStateRef(Span<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x0B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderRef Header => new (this._data);

    /// <summary>
    /// Gets or sets the enable.
    /// </summary>
    public bool Enable
    {
        get => this._data[3..].GetBoolean();
        set => this._data[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the event.
    /// </summary>
    public MapEventState.Events Event
    {
        get => (MapEventState.Events)this._data[4];
        set => this._data[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Span of bytes to a <see cref="MapEventState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MapEventStateRef(Span<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MapEventState"/> to a Span of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Span<byte>(MapEventStateRef packet) => packet._data; 
}
