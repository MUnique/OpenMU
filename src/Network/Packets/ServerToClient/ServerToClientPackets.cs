// <copyright file="ServerToClientPackets.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Network.Packets.ServerToClient
{
    using System;
    using static System.Buffers.Binary.BinaryPrimitives;

    /// <summary>
    /// The structure for a stored item, e.g. in the inventory or vault..
    /// </summary>
    public readonly ref struct StoredItem
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="StoredItem"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public StoredItem(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets or sets the item slot.
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(1);
        }

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 1;
    }


    /// <summary>
    /// Data of an item in a player shop..
    /// </summary>
    public readonly ref struct PlayerShopItem
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItem"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopItem(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 20;

        /// <summary>
        /// Gets or sets the item slot.
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(1, 12);
        }

        /// <summary>
        /// Gets or sets the price.
        /// </summary>
        public uint Price
        {
            get => ReadUInt32LittleEndian(this.data.Slice(16));
            set => WriteUInt32LittleEndian(this.data.Slice(16), value);
        }
    }


    /// <summary>
    /// Is sent by the server when: After a game client has connected to the game.
    /// Causes reaction on client side: It shows the login dialog.
    /// </summary>
    public readonly ref struct GameServerEntered
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GameServerEntered"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GameServerEntered(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GameServerEntered"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GameServerEntered(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Success = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(4).GetBoolean();
            set => this.data.Slice(4).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(5));
            set => WriteUInt16BigEndian(this.data.Slice(5), value);
        }

        /// <summary>
        /// Gets or sets the version string.
        /// </summary>
        public string VersionString
        {
            get => this.data.ExtractString(7, 5, System.Text.Encoding.UTF8);
            set => this.data.Slice(7, 5).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the version.
        /// </summary>
        public Span<byte> Version
        {
            get => this.data.Slice(7, 5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GameServerEntered"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GameServerEntered(Span<byte> packet) => new GameServerEntered(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GameServerEntered"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GameServerEntered packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A magic effect was added or removed to the own or another player.
    /// Causes reaction on client side: The user interface updates itself. If it's the effect of the own player, it's shown as icon at the top of the interface.
    /// </summary>
    public readonly ref struct MagicEffectStatus
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MagicEffectStatus"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MagicEffectStatus(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MagicEffectStatus"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MagicEffectStatus(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x07;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the is active.
        /// </summary>
        public bool IsActive
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(4));
            set => WriteUInt16BigEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the effect id.
        /// </summary>
        public byte EffectId
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MagicEffectStatus"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MagicEffectStatus(Span<byte> packet) => new MagicEffectStatus(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MagicEffectStatus"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MagicEffectStatus packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: One or more character got into the observed scope of the player.
    /// Causes reaction on client side: The client adds the character to the shown map.
    /// </summary>
    public readonly ref partial struct AddCharactersToScope
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddCharactersToScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddCharactersToScope(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddCharactersToScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddCharactersToScope(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the character count.
        /// </summary>
        public byte CharacterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddCharactersToScope"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddCharactersToScope(Span<byte> packet) => new AddCharactersToScope(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddCharactersToScope"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddCharactersToScope packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/> and it's size.
        /// </summary>
        /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        /// <param name="structLength">The length of <see cref="CharacterData"/> from which the size will be calculated.</param>
          public static int GetRequiredSize(int charactersCount, int structLength) => charactersCount * structLength + 5;


    /// <summary>
    /// Contains the data of an NPC..
    /// </summary>
    public readonly ref struct CharacterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data.Slice(0));
            set => WriteUInt16BigEndian(this.data.Slice(0), value);
        }

        /// <summary>
        /// Gets or sets the current position x.
        /// </summary>
        public byte CurrentPositionX
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the current position y.
        /// </summary>
        public byte CurrentPositionY
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the appearance.
        /// </summary>
        public Span<byte> Appearance
        {
            get => this.data.Slice(4, 18);
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(22, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(22, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the target position x.
        /// </summary>
        public byte TargetPositionX
        {
            get => this.data[32];
            set => this.data[32] = value;
        }

        /// <summary>
        /// Gets or sets the target position y.
        /// </summary>
        public byte TargetPositionY
        {
            get => this.data[33];
            set => this.data[33] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data.Slice(34).GetByteValue(4, 4);
            set => this.data.Slice(34).SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets the hero state.
        /// </summary>
        public CharacterHeroState HeroState
        {
            get => (CharacterHeroState)this.data.Slice(34).GetByteValue(4, 0);
            set => this.data.Slice(34).SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets defines the number of effects which would be sent after this field. This is currently not supported.
        /// </summary>
        public byte EffectCount
        {
            get => this.data[35];
            set => this.data[35] = value;
        }

        /// <summary>
        /// Gets the <see cref="EffectId"/> of the specified index.
        /// </summary>
        public EffectId this[int index] => new EffectId(this.data.Slice(36 + (index * EffectId.Length)));

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="EffectId"/>.
        /// </summary>
        /// <param name="effectsCount">The count of <see cref="EffectId"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int effectsCount) => effectsCount * EffectId.Length + 36;
    }


    /// <summary>
    /// Contains the id of a magic effect..
    /// </summary>
    public readonly ref struct EffectId
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="EffectId"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public EffectId(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 1;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public byte Id
        {
            get => this.data[0];
            set => this.data[0] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: One or more character got into the observed scope of the player.
    /// Causes reaction on client side: The client adds the character to the shown map.
    /// </summary>
    public readonly ref struct AddCharactersToScope075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddCharactersToScope075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddCharactersToScope075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddCharactersToScope075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddCharactersToScope075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the character count.
        /// </summary>
        public byte CharacterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="CharacterData"/> of the specified index.
        /// </summary>
        public CharacterData this[int index] => new CharacterData(this.data.Slice(5 + (index * CharacterData.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddCharactersToScope075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddCharactersToScope075(Span<byte> packet) => new AddCharactersToScope075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddCharactersToScope075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddCharactersToScope075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
        /// </summary>
        /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 5;


    /// <summary>
    /// Contains the data of an NPC..
    /// </summary>
    public readonly ref struct CharacterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 27;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data.Slice(0));
            set => WriteUInt16BigEndian(this.data.Slice(0), value);
        }

        /// <summary>
        /// Gets or sets the current position x.
        /// </summary>
        public byte CurrentPositionX
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the current position y.
        /// </summary>
        public byte CurrentPositionY
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the appearance.
        /// </summary>
        public Span<byte> Appearance
        {
            get => this.data.Slice(4, 9);
        }

        /// <summary>
        /// Gets or sets the is poisoned.
        /// </summary>
        public bool IsPoisoned
        {
            get => this.data.Slice(13).GetBoolean(0);
            set => this.data.Slice(13).SetBoolean(value, 0);
        }

        /// <summary>
        /// Gets or sets the is iced.
        /// </summary>
        public bool IsIced
        {
            get => this.data.Slice(13).GetBoolean(1);
            set => this.data.Slice(13).SetBoolean(value, 1);
        }

        /// <summary>
        /// Gets or sets the is damage buffed.
        /// </summary>
        public bool IsDamageBuffed
        {
            get => this.data.Slice(13).GetBoolean(2);
            set => this.data.Slice(13).SetBoolean(value, 2);
        }

        /// <summary>
        /// Gets or sets the is defense buffed.
        /// </summary>
        public bool IsDefenseBuffed
        {
            get => this.data.Slice(13).GetBoolean(3);
            set => this.data.Slice(13).SetBoolean(value, 3);
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(14, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(14, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the target position x.
        /// </summary>
        public byte TargetPositionX
        {
            get => this.data[24];
            set => this.data[24] = value;
        }

        /// <summary>
        /// Gets or sets the target position y.
        /// </summary>
        public byte TargetPositionY
        {
            get => this.data[25];
            set => this.data[25] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data.Slice(26).GetByteValue(4, 4);
            set => this.data.Slice(26).SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets the hero state.
        /// </summary>
        public CharacterHeroState HeroState
        {
            get => (CharacterHeroState)this.data.Slice(26).GetByteValue(4, 0);
            set => this.data.Slice(26).SetByteValue((byte)value, 4, 0);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: One or more NPCs got into the observed scope of the player.
    /// Causes reaction on client side: The client adds the NPCs to the shown map.
    /// </summary>
    public readonly ref struct AddNpcsToScope
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddNpcsToScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddNpcsToScope(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddNpcsToScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddNpcsToScope(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x13;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the npc count.
        /// </summary>
        public byte NpcCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="NpcData"/> of the specified index.
        /// </summary>
        public NpcData this[int index] => new NpcData(this.data.Slice(5 + (index * NpcData.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddNpcsToScope"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddNpcsToScope(Span<byte> packet) => new AddNpcsToScope(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddNpcsToScope"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddNpcsToScope packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="NpcData"/>.
        /// </summary>
        /// <param name="nPCsCount">The count of <see cref="NpcData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int nPCsCount) => nPCsCount * NpcData.Length + 5;


    /// <summary>
    /// Contains the data of an NPC..
    /// </summary>
    public readonly ref struct NpcData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public NpcData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data.Slice(0));
            set => WriteUInt16BigEndian(this.data.Slice(0), value);
        }

        /// <summary>
        /// Gets or sets the type number.
        /// </summary>
        public ushort TypeNumber
        {
            get => ReadUInt16BigEndian(this.data.Slice(2));
            set => WriteUInt16BigEndian(this.data.Slice(2), value);
        }

        /// <summary>
        /// Gets or sets the current position x.
        /// </summary>
        public byte CurrentPositionX
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the current position y.
        /// </summary>
        public byte CurrentPositionY
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the target position x.
        /// </summary>
        public byte TargetPositionX
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the target position y.
        /// </summary>
        public byte TargetPositionY
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data.Slice(8).GetByteValue(4, 4);
            set => this.data.Slice(8).SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets defines the number of effects which would be sent after this field. This is currently not supported.
        /// </summary>
        public byte EffectCount
        {
            get => this.data[9];
            set => this.data[9] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: One or more NPCs got into the observed scope of the player.
    /// Causes reaction on client side: The client adds the NPCs to the shown map.
    /// </summary>
    public readonly ref struct AddNpcsToScope075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddNpcsToScope075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddNpcsToScope075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddNpcsToScope075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddNpcsToScope075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x13;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the npc count.
        /// </summary>
        public byte NpcCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="NpcData"/> of the specified index.
        /// </summary>
        public NpcData this[int index] => new NpcData(this.data.Slice(5 + (index * NpcData.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddNpcsToScope075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddNpcsToScope075(Span<byte> packet) => new AddNpcsToScope075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddNpcsToScope075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddNpcsToScope075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="NpcData"/>.
        /// </summary>
        /// <param name="nPCsCount">The count of <see cref="NpcData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int nPCsCount) => nPCsCount * NpcData.Length + 5;


    /// <summary>
    /// Contains the data of an NPC..
    /// </summary>
    public readonly ref struct NpcData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public NpcData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data.Slice(0));
            set => WriteUInt16BigEndian(this.data.Slice(0), value);
        }

        /// <summary>
        /// Gets or sets the type number.
        /// </summary>
        public byte TypeNumber
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the is poisoned.
        /// </summary>
        public bool IsPoisoned
        {
            get => this.data.Slice(3).GetBoolean(0);
            set => this.data.Slice(3).SetBoolean(value, 0);
        }

        /// <summary>
        /// Gets or sets the is iced.
        /// </summary>
        public bool IsIced
        {
            get => this.data.Slice(3).GetBoolean(1);
            set => this.data.Slice(3).SetBoolean(value, 1);
        }

        /// <summary>
        /// Gets or sets the is damage buffed.
        /// </summary>
        public bool IsDamageBuffed
        {
            get => this.data.Slice(3).GetBoolean(2);
            set => this.data.Slice(3).SetBoolean(value, 2);
        }

        /// <summary>
        /// Gets or sets the is defense buffed.
        /// </summary>
        public bool IsDefenseBuffed
        {
            get => this.data.Slice(3).GetBoolean(3);
            set => this.data.Slice(3).SetBoolean(value, 3);
        }

        /// <summary>
        /// Gets or sets the current position x.
        /// </summary>
        public byte CurrentPositionX
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the current position y.
        /// </summary>
        public byte CurrentPositionY
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the target position x.
        /// </summary>
        public byte TargetPositionX
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the target position y.
        /// </summary>
        public byte TargetPositionY
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data.Slice(8).GetByteValue(4, 4);
            set => this.data.Slice(8).SetByteValue(value, 4, 4);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: One or more objects (player, npc, etc.) on the map got out of scope, e.g. when the own player moved away from it/them or the object itself moved.
    /// Causes reaction on client side: The game client removes the objects from the game map.
    /// </summary>
    public readonly ref struct MapObjectOutOfScope
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MapObjectOutOfScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MapObjectOutOfScope(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MapObjectOutOfScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MapObjectOutOfScope(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x14;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the object count.
        /// </summary>
        public byte ObjectCount
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets the <see cref="ObjectId"/> of the specified index.
        /// </summary>
        public ObjectId this[int index] => new ObjectId(this.data.Slice(4 + (index * ObjectId.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MapObjectOutOfScope"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MapObjectOutOfScope(Span<byte> packet) => new MapObjectOutOfScope(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MapObjectOutOfScope"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MapObjectOutOfScope packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="ObjectId"/>.
        /// </summary>
        /// <param name="objectsCount">The count of <see cref="ObjectId"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int objectsCount) => objectsCount * ObjectId.Length + 4;


    /// <summary>
    /// Contains the id of a object..
    /// </summary>
    public readonly ref struct ObjectId
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectId"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectId(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data.Slice(0));
            set => WriteUInt16BigEndian(this.data.Slice(0), value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: An observed object was killed.
    /// Causes reaction on client side: The object is shown as dead.
    /// </summary>
    public readonly ref struct ObjectGotKilled
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectGotKilled"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectGotKilled(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectGotKilled"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectGotKilled(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x17;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the killed id.
        /// </summary>
        public ushort KilledId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Gets or sets the killer id.
        /// </summary>
        public ushort KillerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(7));
            set => WriteUInt16BigEndian(this.data.Slice(7), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectGotKilled"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectGotKilled(Span<byte> packet) => new ObjectGotKilled(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectGotKilled"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectGotKilled packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An object performs an animation.
    /// Causes reaction on client side: The animation is shown for the specified object.
    /// </summary>
    public readonly ref struct ObjectAnimation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectAnimation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectAnimation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectAnimation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectAnimation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x18;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the object id.
        /// </summary>
        public ushort ObjectId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Gets or sets the direction.
        /// </summary>
        public byte Direction
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the animation.
        /// </summary>
        public byte Animation
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => ReadUInt16BigEndian(this.data.Slice(7));
            set => WriteUInt16BigEndian(this.data.Slice(7), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectAnimation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectAnimation(Span<byte> packet) => new ObjectAnimation(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectAnimation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectAnimation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An object performs a skill which has effect on an area.
    /// Causes reaction on client side: The animation is shown on the user interface.
    /// </summary>
    public readonly ref struct AreaSkillAnimation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AreaSkillAnimation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AreaSkillAnimation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AreaSkillAnimation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AreaSkillAnimation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x1E;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public ushort SkillId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(5));
            set => WriteUInt16BigEndian(this.data.Slice(5), value);
        }

        /// <summary>
        /// Gets or sets the point x.
        /// </summary>
        public byte PointX
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the point y.
        /// </summary>
        public byte PointY
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[9];
            set => this.data[9] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkillAnimation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AreaSkillAnimation(Span<byte> packet) => new AreaSkillAnimation(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AreaSkillAnimation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AreaSkillAnimation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An object performs a skill which is directly targetted to another object.
    /// Causes reaction on client side: The animation is shown on the user interface.
    /// </summary>
    public readonly ref struct SkillAnimation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAnimation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillAnimation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAnimation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillAnimation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x19;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public ushort SkillId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(5));
            set => WriteUInt16BigEndian(this.data.Slice(5), value);
        }

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => ReadUInt16BigEndian(this.data.Slice(7));
            set => WriteUInt16BigEndian(this.data.Slice(7), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAnimation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillAnimation(Span<byte> packet) => new SkillAnimation(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillAnimation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillAnimation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The appearance of a player changed, all surrounding players are informed about it.
    /// Causes reaction on client side: The appearance of the player is updated.
    /// </summary>
    public readonly ref struct AppearanceChanged
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AppearanceChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AppearanceChanged(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AppearanceChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AppearanceChanged(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x25;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the changed player id.
        /// </summary>
        public ushort ChangedPlayerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AppearanceChanged"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AppearanceChanged(Span<byte> packet) => new AppearanceChanged(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AppearanceChanged"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AppearanceChanged packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
    }


    /// <summary>
    /// Is sent by the server when: The server wants to show a message above any kind of character, even NPCs.
    /// Causes reaction on client side: The message is shown above the character.
    /// </summary>
    public readonly ref struct ObjectMessage
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectMessage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectMessage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x01;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the object id.
        /// </summary>
        public ushort ObjectId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(5, this.data.Length - 5, System.Text.Encoding.UTF8);
            set => this.data.Slice(5).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectMessage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectMessage(Span<byte> packet) => new ObjectMessage(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectMessage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectMessage packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 5;
    }


    /// <summary>
    /// Is sent by the server when: Another player requests party from the receiver of this message.
    /// Causes reaction on client side: The party request is shown.
    /// </summary>
    public readonly ref struct PartyRequest
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PartyRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x40;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the requester id.
        /// </summary>
        public ushort RequesterId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PartyRequest(Span<byte> packet) => new PartyRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PartyRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PartyRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A player joined a party or requested the current party list by opening the party dialog.
    /// Causes reaction on client side: The party list is updated.
    /// </summary>
    public readonly ref struct PartyList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PartyList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x42;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the count.
        /// </summary>
        public byte Count
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="PartyMember"/> of the specified index.
        /// </summary>
        public PartyMember this[int index] => new PartyMember(this.data.Slice(5 + (index * PartyMember.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PartyList(Span<byte> packet) => new PartyList(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PartyList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PartyList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="PartyMember"/>.
        /// </summary>
        /// <param name="membersCount">The count of <see cref="PartyMember"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int membersCount) => membersCount * PartyMember.Length + 5;


    /// <summary>
    /// Data about a party member..
    /// </summary>
    public readonly ref struct PartyMember
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyMember"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyMember(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 24;

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(0, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the index.
        /// </summary>
        public byte Index
        {
            get => this.data[10];
            set => this.data[10] = value;
        }

        /// <summary>
        /// Gets or sets the map id.
        /// </summary>
        public byte MapId
        {
            get => this.data[11];
            set => this.data[11] = value;
        }

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[12];
            set => this.data[12] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[13];
            set => this.data[13] = value;
        }

        /// <summary>
        /// Gets or sets the current health.
        /// </summary>
        public uint CurrentHealth
        {
            get => ReadUInt32LittleEndian(this.data.Slice(16));
            set => WriteUInt32LittleEndian(this.data.Slice(16), value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public uint MaximumHealth
        {
            get => ReadUInt32LittleEndian(this.data.Slice(20));
            set => WriteUInt32LittleEndian(this.data.Slice(20), value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: A party member got removed from a party in which the player is in.
    /// Causes reaction on client side: The party member with the specified index is removed from the party list on the user interface.
    /// </summary>
    public readonly ref struct RemovePartyMember
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="RemovePartyMember"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public RemovePartyMember(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RemovePartyMember"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private RemovePartyMember(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x43;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the index.
        /// </summary>
        public byte Index
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="RemovePartyMember"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator RemovePartyMember(Span<byte> packet) => new RemovePartyMember(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="RemovePartyMember"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(RemovePartyMember packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Periodically, when the health state of the party changed.
    /// Causes reaction on client side: The party health list is updated.
    /// </summary>
    public readonly ref struct PartyHealthUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyHealthUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyHealthUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyHealthUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PartyHealthUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x44;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the count.
        /// </summary>
        public byte Count
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets the <see cref="PartyMemberHealth"/> of the specified index.
        /// </summary>
        public PartyMemberHealth this[int index] => new PartyMemberHealth(this.data.Slice(4 + (index * PartyMemberHealth.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyHealthUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PartyHealthUpdate(Span<byte> packet) => new PartyHealthUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PartyHealthUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PartyHealthUpdate packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="PartyMemberHealth"/>.
        /// </summary>
        /// <param name="membersCount">The count of <see cref="PartyMemberHealth"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int membersCount) => membersCount * PartyMemberHealth.Length + 4;


    /// <summary>
    /// Health of a party member.
    /// </summary>
    public readonly ref struct PartyMemberHealth
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyMemberHealth"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyMemberHealth(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 1;

        /// <summary>
        /// Gets or sets the index.
        /// </summary>
        public byte Index
        {
            get => this.data.Slice(0).GetByteValue(4, 4);
            set => this.data.Slice(0).SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets a value from 0 to 10 about the health of a player. 10 means the current health is 100% of the maximum health.
        /// </summary>
        public byte Value
        {
            get => this.data.Slice(0).GetByteValue(4, 0);
            set => this.data.Slice(0).SetByteValue(value, 4, 0);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to open his shop and this request was successful.
    /// Causes reaction on client side: The own player shop is shown as open.
    /// </summary>
    public readonly ref struct PlayerShopOpenSuccessful
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopOpenSuccessful"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopOpenSuccessful(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopOpenSuccessful"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopOpenSuccessful(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Success = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x2;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(4).GetBoolean();
            set => this.data.Slice(4).SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopOpenSuccessful"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopOpenSuccessful(Span<byte> packet) => new PlayerShopOpenSuccessful(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopOpenSuccessful"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopOpenSuccessful packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the trading partner checked or unchecked the trade accept button.
    /// Causes reaction on client side: The game client updates the trade button state accordingly.
    /// </summary>
    public readonly ref struct TradeButtonStateChanged
    {
        /// <summary>
        /// Defines the state of the trade button.
        /// </summary>
        public enum TradeButtonState
        {
            /// <summary>
            /// Trade button is not pressed. It means that the trade is not yet accepted by the trader.
            /// </summary>
            Unchecked = 0,

            /// <summary>
            /// Trade Button is pressed. It means that the trade is accepted by the trader.
            /// </summary>
            Checked = 1,

            /// <summary>
            /// This state is only sent to the client. After some seconds the client is changing back to normal Unchecked.
            /// </summary>
            Red = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeButtonStateChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeButtonStateChanged(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeButtonStateChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeButtonStateChanged(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC3;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the state.
        /// </summary>
        public TradeButtonStateChanged.TradeButtonState State
        {
            get => (TradeButtonState)this.data.Slice(4)[0];
            set => this.data.Slice(4)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeButtonStateChanged"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeButtonStateChanged(Span<byte> packet) => new TradeButtonStateChanged(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeButtonStateChanged"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeButtonStateChanged packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The trade money has been set by a previous request of the player.
    /// Causes reaction on client side: The money which was set into the trade by the player is updated on the UI.
    /// </summary>
    public readonly ref struct TradeMoneySetResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeMoneySetResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeMoneySetResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeMoneySetResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeMoneySetResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3A;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeMoneySetResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeMoneySetResponse(Span<byte> packet) => new TradeMoneySetResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeMoneySetResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeMoneySetResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: This message is sent when the trading partner put a certain amount of money (also 0) into the trade.
    /// Causes reaction on client side: It overrides all previous sent money values.
    /// </summary>
    public readonly ref struct TradeMoneyUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeMoneyUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeMoneyUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeMoneyUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeMoneyUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3B;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the money amount.
        /// </summary>
        public uint MoneyAmount
        {
            get => ReadUInt32LittleEndian(this.data.Slice(4));
            set => WriteUInt32LittleEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeMoneyUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeMoneyUpdate(Span<byte> packet) => new TradeMoneyUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeMoneyUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeMoneyUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player which receives this message, sent a trade request to another player. This message is sent when the other player responded to this request.
    /// Causes reaction on client side: If the trade was accepted, a trade dialog is opened. Otherwise, a message is shown.
    /// </summary>
    public readonly ref struct TradeRequestAnswer
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeRequestAnswer"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeRequestAnswer(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeRequestAnswer"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeRequestAnswer(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x37;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 20;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the accepted.
        /// </summary>
        public bool Accepted
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the trade partner level.
        /// </summary>
        public ushort TradePartnerLevel
        {
            get => ReadUInt16BigEndian(this.data.Slice(14));
            set => WriteUInt16BigEndian(this.data.Slice(14), value);
        }

        /// <summary>
        /// Gets or sets the guild id.
        /// </summary>
        public uint GuildId
        {
            get => ReadUInt32LittleEndian(this.data.Slice(16));
            set => WriteUInt32LittleEndian(this.data.Slice(16), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeRequestAnswer"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeRequestAnswer(Span<byte> packet) => new TradeRequestAnswer(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeRequestAnswer"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeRequestAnswer packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A trade was requested by another player.
    /// Causes reaction on client side: A trade request dialog is shown.
    /// </summary>
    public readonly ref struct TradeRequest
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x36;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 13;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeRequest(Span<byte> packet) => new TradeRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A trade was finished.
    /// Causes reaction on client side: The trade dialog is closed. Depending on the result, a message is shown.
    /// </summary>
    public readonly ref struct TradeFinished
    {
        /// <summary>
        /// Defines the result of a finished trade.
        /// </summary>
        public enum TradeResult
        {
            /// <summary>
            /// The trade was cancelled.
            /// </summary>
            Cancelled = 0,

            /// <summary>
            /// The trade was successful.
            /// </summary>
            Success = 1,

            /// <summary>
            /// The trade failed because of a full inventory.
            /// </summary>
            FailedByFullInventory = 2,

            /// <summary>
            /// The trade failed because the request timed out.
            /// </summary>
            TimedOut = 3,

            /// <summary>
            /// The trade failed because one or more items were not allowed to trade.
            /// </summary>
            FailedByItemsNotAllowedToTrade = 4,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeFinished"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeFinished(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeFinished"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeFinished(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3D;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public TradeFinished.TradeResult Result
        {
            get => (TradeResult)this.data.Slice(4)[0];
            set => this.data.Slice(4)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeFinished"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeFinished(Span<byte> packet) => new TradeFinished(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeFinished"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeFinished packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The trading partner added an item to the trade.
    /// Causes reaction on client side: The item is added in the trade dialog.
    /// </summary>
    public readonly ref struct TradeItemAdded
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeItemAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeItemAdded(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeItemAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeItemAdded(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x39;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the to slot.
        /// </summary>
        public byte ToSlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeItemAdded"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeItemAdded(Span<byte> packet) => new TradeItemAdded(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeItemAdded"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeItemAdded packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
    }


    /// <summary>
    /// Is sent by the server when: The trading partner removed an item from the trade.
    /// Causes reaction on client side: The item is removed from the trade dialog.
    /// </summary>
    public readonly ref struct TradeItemRemoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeItemRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeItemRemoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeItemRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeItemRemoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x38;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the slot.
        /// </summary>
        public byte Slot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeItemRemoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeItemRemoved(Span<byte> packet) => new TradeItemRemoved(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeItemRemoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeItemRemoved packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the login request has been processed by the server.
    /// Causes reaction on client side: Shows the result. When it was successful, the client proceeds by sending a character list request.
    /// </summary>
    public readonly ref struct LoginResponse
    {
        /// <summary>
        /// The result of a login request.
        /// </summary>
        public enum LoginResult
        {
            /// <summary>
            /// The password was wrong.
            /// </summary>
            InvalidPassword = 0,

            /// <summary>
            /// The login succeeded.
            /// </summary>
            Okay = 1,

            /// <summary>
            /// The account is invalid.
            /// </summary>
            AccountInvalid = 2,

            /// <summary>
            /// The account is already connected.
            /// </summary>
            AccountAlreadyConnected = 3,

            /// <summary>
            /// The server is full.
            /// </summary>
            ServerIsFull = 4,

            /// <summary>
            /// The account is blocked.
            /// </summary>
            AccountBlocked = 5,

            /// <summary>
            /// The game client has the wrong version.
            /// </summary>
            WrongVersion = 6,

            /// <summary>
            /// An internal error occured during connection.
            /// </summary>
            ConnectionError = 7,

            /// <summary>
            /// Connection closed because of three failed login requests.
            /// </summary>
            ConnectionClosed3Fails = 8,

            /// <summary>
            /// There is no payment information.
            /// </summary>
            NoChargeInfo = 9,

            /// <summary>
            /// The subscription term is over.
            /// </summary>
            SubscriptionTermOver = 10,

            /// <summary>
            /// The subscription time is over.
            /// </summary>
            SubscriptionTimeOver = 11,

            /// <summary>
            /// The account is temporarily blocked.
            /// </summary>
            TemporaryBlocked = 14,

            /// <summary>
            /// Only players over 15 years are allowed to connect.
            /// </summary>
            OnlyPlayersOver15Yrs = 17,

            /// <summary>
            /// The client connected from a blocked country.
            /// </summary>
            BadCountry = 210,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LoginResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LoginResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LoginResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LoginResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public LoginResponse.LoginResult Success
        {
            get => (LoginResult)this.data.Slice(4)[0];
            set => this.data.Slice(4)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LoginResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LoginResponse(Span<byte> packet) => new LoginResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LoginResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LoginResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the logout request has been processed by the server.
    /// Causes reaction on client side: Depending on the result, the game client closes the game or changes to another selection screen.
    /// </summary>
    public readonly ref struct LogoutResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LogoutResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LogoutResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LogoutResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LogoutResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x02;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public LogOutType Type
        {
            get => (LogOutType)this.data.Slice(4)[0];
            set => this.data.Slice(4)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LogoutResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LogoutResponse(Span<byte> packet) => new LogoutResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LogoutResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LogoutResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A player sends a chat message.
    /// Causes reaction on client side: The message is shown in the chat box and above the character of the sender.
    /// </summary>
    public readonly ref struct ChatMessage
    {
        /// <summary>
        /// Defines the type of a chat message.
        /// </summary>
        public enum ChatMessageType
        {
            /// <summary>
            /// The message is a normal chat message, e.g. public, within a party or guild.
            /// </summary>
            Normal = 0,

            /// <summary>
            /// The message is sent privately to the receiving player.
            /// </summary>
            Whisper = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ChatMessage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ChatMessage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public ChatMessage.ChatMessageType Type
        {
            get => (ChatMessageType)this.data.Slice(2)[0];
            set => this.data.Slice(2)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the sender.
        /// </summary>
        public string Sender
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(13, this.data.Length - 13, System.Text.Encoding.UTF8);
            set => this.data.Slice(13).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ChatMessage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ChatMessage(Span<byte> packet) => new ChatMessage(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ChatMessage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ChatMessage packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 13;
    }


    /// <summary>
    /// Is sent by the server when: An object got hit in two cases: 1. When the own player is hit; 2. When the own player attacked some other object which got hit.
    /// Causes reaction on client side: The damage is shown at the object which received the hit.
    /// </summary>
    public readonly ref struct ObjectHit
    {
        /// <summary>
        /// Defines the kind of the damage.
        /// </summary>
        public enum DamageKind
        {
            /// <summary>
            /// Red color, used by normal damage.
            /// </summary>
            NormalRed = 0,

            /// <summary>
            /// Cyan color, usually used by ignore defense damage.
            /// </summary>
            IgnoreDefenseCyan = 1,

            /// <summary>
            /// Light green color, usually used by excellent damage.
            /// </summary>
            ExcellentLightGreen = 2,

            /// <summary>
            /// Blue color, usually used by critical damage.
            /// </summary>
            CriticalBlue = 3,

            /// <summary>
            /// Light pink color.
            /// </summary>
            LightPink = 4,

            /// <summary>
            /// Dark green color, usually used by poison damage.
            /// </summary>
            PoisonDarkGreen = 5,

            /// <summary>
            /// Dark pink color, usually used by reflected damage.
            /// </summary>
            ReflectedDarkPink = 6,

            /// <summary>
            /// White color.
            /// </summary>
            White = 7,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectHit"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectHit(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectHit"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectHit(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the header code.
        /// </summary>
        public byte HeaderCode
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the object id.
        /// </summary>
        public ushort ObjectId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Gets or sets the health damage.
        /// </summary>
        public ushort HealthDamage
        {
            get => ReadUInt16BigEndian(this.data.Slice(5));
            set => WriteUInt16BigEndian(this.data.Slice(5), value);
        }

        /// <summary>
        /// Gets or sets the kind.
        /// </summary>
        public ObjectHit.DamageKind Kind
        {
            get => (DamageKind)this.data.Slice(7).GetByteValue(4, 0);
            set => this.data.Slice(7).SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the is double damage.
        /// </summary>
        public bool IsDoubleDamage
        {
            get => this.data.Slice(7).GetBoolean(6);
            set => this.data.Slice(7).SetBoolean(value, 6);
        }

        /// <summary>
        /// Gets or sets the is triple damage.
        /// </summary>
        public bool IsTripleDamage
        {
            get => this.data.Slice(7).GetBoolean(7);
            set => this.data.Slice(7).SetBoolean(value, 7);
        }

        /// <summary>
        /// Gets or sets the shield damage.
        /// </summary>
        public ushort ShieldDamage
        {
            get => ReadUInt16BigEndian(this.data.Slice(8));
            set => WriteUInt16BigEndian(this.data.Slice(8), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectHit"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectHit(Span<byte> packet) => new ObjectHit(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectHit"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectHit packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An object in the observed scope (including the own player) moved instantly.
    /// Causes reaction on client side: The position of the object is updated on client side.
    /// </summary>
    public readonly ref struct ObjectMoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectMoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectMoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectMoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectMoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x15;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the header code.
        /// </summary>
        public byte HeaderCode
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the object id.
        /// </summary>
        public ushort ObjectId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectMoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectMoved(Span<byte> packet) => new ObjectMoved(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectMoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectMoved packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An object in the observed scope (including the own player) walked to another position.
    /// Causes reaction on client side: The object is animated to walk to the new position.
    /// </summary>
    public readonly ref struct ObjectWalked
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectWalked"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectWalked(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectWalked"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectWalked(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xD4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the header code.
        /// </summary>
        public byte HeaderCode
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the object id.
        /// </summary>
        public ushort ObjectId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Gets or sets the target x.
        /// </summary>
        public byte TargetX
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the target y.
        /// </summary>
        public byte TargetY
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the target rotation.
        /// </summary>
        public byte TargetRotation
        {
            get => this.data.Slice(7).GetByteValue(4, 4);
            set => this.data.Slice(7).SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets the step count.
        /// </summary>
        public byte StepCount
        {
            get => this.data.Slice(7).GetByteValue(4, 0);
            set => this.data.Slice(7).SetByteValue(value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the step data.
        /// </summary>
        public Span<byte> StepData
        {
            get => this.data.Slice(8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectWalked"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectWalked(Span<byte> packet) => new ObjectWalked(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectWalked"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectWalked packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="StepData"/>.
        /// </summary>
        /// <param name="stepDataLength">The length in bytes of <see cref="StepData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int stepDataLength) => stepDataLength + 8;
    }


    /// <summary>
    /// Is sent by the server when: A player gained experience.
    /// Causes reaction on client side: The experience is added to the experience counter and bar.
    /// </summary>
    public readonly ref struct ExperienceGained
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ExperienceGained"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ExperienceGained(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExperienceGained"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ExperienceGained(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x16;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the killed object id.
        /// </summary>
        public ushort KilledObjectId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Gets or sets the added experience.
        /// </summary>
        public ushort AddedExperience
        {
            get => ReadUInt16BigEndian(this.data.Slice(5));
            set => WriteUInt16BigEndian(this.data.Slice(5), value);
        }

        /// <summary>
        /// Gets or sets the damage of last hit.
        /// </summary>
        public ushort DamageOfLastHit
        {
            get => ReadUInt16BigEndian(this.data.Slice(7));
            set => WriteUInt16BigEndian(this.data.Slice(7), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ExperienceGained"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ExperienceGained(Span<byte> packet) => new ExperienceGained(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ExperienceGained"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ExperienceGained packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The map was changed on the server side.
    /// Causes reaction on client side: The game client changes to the specified map and coordinates.
    /// </summary>
    public readonly ref struct MapChanged
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MapChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MapChanged(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MapChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MapChanged(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Success = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x1C;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x0F;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 15;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(4).GetBoolean();
            set => this.data.Slice(4).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the map number.
        /// </summary>
        public ushort MapNumber
        {
            get => ReadUInt16BigEndian(this.data.Slice(5));
            set => WriteUInt16BigEndian(this.data.Slice(5), value);
        }

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[9];
            set => this.data[9] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MapChanged"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MapChanged(Span<byte> packet) => new MapChanged(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MapChanged"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MapChanged packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: When entering the game world with a character.
    /// Causes reaction on client side: The client restores this configuration in its user interface.
    /// </summary>
    public readonly ref struct ApplyKeyConfiguration
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ApplyKeyConfiguration"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ApplyKeyConfiguration(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ApplyKeyConfiguration"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ApplyKeyConfiguration(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x30;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the binary data of the key configuration
        /// </summary>
        public Span<byte> Configuration
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ApplyKeyConfiguration"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ApplyKeyConfiguration(Span<byte> packet) => new ApplyKeyConfiguration(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ApplyKeyConfiguration"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ApplyKeyConfiguration packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="Configuration"/>.
        /// </summary>
        /// <param name="configurationLength">The length in bytes of <see cref="Configuration"/> on which the required size depends.</param>
        public static int GetRequiredSize(int configurationLength) => configurationLength + 4;
    }


    /// <summary>
    /// Is sent by the server when: The items dropped on the ground.
    /// Causes reaction on client side: The client adds the items to the ground.
    /// </summary>
    public readonly ref struct ItemsDropped
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemsDropped"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemsDropped(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemsDropped"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemsDropped(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x20;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="DroppedItem"/> of the specified index.
        /// </summary>
        public DroppedItem this[int index, int droppedItemLength] => new DroppedItem(this.data.Slice(5 + (index * droppedItemLength)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemsDropped"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemsDropped(Span<byte> packet) => new ItemsDropped(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemsDropped"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemsDropped packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="DroppedItem"/> and it's size.
        /// </summary>
        /// <param name="itemsCount">The count of <see cref="DroppedItem"/> from which the size will be calculated.</param>
        /// <param name="structLength">The length of <see cref="DroppedItem"/> from which the size will be calculated.</param>
          public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 5;


    /// <summary>
    /// Contains the data about a dropped item..
    /// </summary>
    public readonly ref struct DroppedItem
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="DroppedItem"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public DroppedItem(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data.Slice(0));
            set => WriteUInt16BigEndian(this.data.Slice(0), value);
        }

        /// <summary>
        /// Gets or sets if this flag is set, the item is added to the map with an animation and sound. Otherwise it's just added like it was already on the ground before.
        /// </summary>
        public bool IsFreshDrop
        {
            get => this.data.Slice(0).GetBoolean(7);
            set => this.data.Slice(0).SetBoolean(value, 7);
        }

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
    }
    }


    /// <summary>
    /// Is sent by the server when: A dropped item was removed from the ground of the map, e.g. when it timed out or was picked up.
    /// Causes reaction on client side: The client removes the item from the ground of the map.
    /// </summary>
    public readonly ref struct ItemDropRemoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemDropRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemDropRemoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemDropRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemDropRemoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x21;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="DroppedItemId"/> of the specified index.
        /// </summary>
        public DroppedItemId this[int index] => new DroppedItemId(this.data.Slice(5 + (index * DroppedItemId.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemDropRemoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemDropRemoved(Span<byte> packet) => new ItemDropRemoved(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemDropRemoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemDropRemoved packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="DroppedItemId"/>.
        /// </summary>
        /// <param name="itemDataCount">The count of <see cref="DroppedItemId"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int itemDataCount) => itemDataCount * DroppedItemId.Length + 5;


    /// <summary>
    /// Contains the id of a dropped item..
    /// </summary>
    public readonly ref struct DroppedItemId
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="DroppedItemId"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public DroppedItemId(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data.Slice(0));
            set => WriteUInt16BigEndian(this.data.Slice(0), value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: A new item was added to the inventory.
    /// Causes reaction on client side: The client adds the item to the inventory user interface.
    /// </summary>
    public readonly ref struct ItemAddedToInventory
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemAddedToInventory"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemAddedToInventory(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemAddedToInventory"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemAddedToInventory(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x22;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemAddedToInventory"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemAddedToInventory(Span<byte> packet) => new ItemAddedToInventory(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemAddedToInventory"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemAddedToInventory packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
    }


    /// <summary>
    /// Is sent by the server when: The player requested to drop an item of his inventory. This message is the response about the success of the request.
    /// Causes reaction on client side: If successful, the client removes the item from the inventory user interface.
    /// </summary>
    public readonly ref struct ItemDropResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemDropResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemDropResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemDropResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemDropResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x23;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemDropResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemDropResponse(Span<byte> packet) => new ItemDropResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemDropResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemDropResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player requested to pick up an item from to ground to add it to his inventory, but it failed.
    /// Causes reaction on client side: Depending on the reason, the game client shows a message.
    /// </summary>
    public readonly ref struct ItemPickUpRequestFailed
    {
        /// <summary>
        /// Defines the possible fail reasons
        /// </summary>
        public enum ItemPickUpFailReason
        {
            /// <summary>
            /// The picked up item was combined into an existing item of the players inventory. A separate durability update will be sent to the client.
            /// </summary>
            ItemStacked = 253,

            /// <summary>
            /// The maximum inventory money has been reached, so the money wasn't picked up. Should not be used, because it's used in the InventoryMoneyUpdate message.
            /// </summary>
            __MaximumInventoryMoneyReached = 254,

            /// <summary>
            /// The general, non-specific reason. It just failed.
            /// </summary>
            General = 255,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemPickUpRequestFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemPickUpRequestFailed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemPickUpRequestFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemPickUpRequestFailed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x22;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the fail reason.
        /// </summary>
        public ItemPickUpRequestFailed.ItemPickUpFailReason FailReason
        {
            get => (ItemPickUpFailReason)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemPickUpRequestFailed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemPickUpRequestFailed(Span<byte> packet) => new ItemPickUpRequestFailed(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemPickUpRequestFailed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemPickUpRequestFailed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The players money amount of the inventory has been changed and needs an update.
    /// Causes reaction on client side: The money is updated in the inventory user interface.
    /// </summary>
    public readonly ref struct InventoryMoneyUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="InventoryMoneyUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public InventoryMoneyUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InventoryMoneyUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private InventoryMoneyUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x22;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFE;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the money.
        /// </summary>
        public uint Money
        {
            get => ReadUInt32BigEndian(this.data.Slice(4));
            set => WriteUInt32BigEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="InventoryMoneyUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator InventoryMoneyUpdate(Span<byte> packet) => new InventoryMoneyUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="InventoryMoneyUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(InventoryMoneyUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An item in the inventory or vault of the player has been moved.
    /// Causes reaction on client side: The client updates the position of item in the user interface.
    /// </summary>
    public readonly ref struct ItemMoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemMoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemMoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemMoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemMoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x24;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the target storage type.
        /// </summary>
        public ItemStorageKind TargetStorageType
        {
            get => (ItemStorageKind)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the target slot.
        /// </summary>
        public byte TargetSlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemMoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemMoved(Span<byte> packet) => new ItemMoved(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemMoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemMoved packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
    }


    /// <summary>
    /// Is sent by the server when: An item in the inventory or vault of the player could not be moved as requested by the player.
    /// Causes reaction on client side: The client restores the position of item in the user interface.
    /// </summary>
    public readonly ref struct ItemMoveRequestFailed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemMoveRequestFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemMoveRequestFailed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemMoveRequestFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemMoveRequestFailed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x24;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFF;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemMoveRequestFailed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemMoveRequestFailed(Span<byte> packet) => new ItemMoveRequestFailed(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemMoveRequestFailed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemMoveRequestFailed packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
    }


    /// <summary>
    /// Is sent by the server when: Periodically, or if the current health or shield changed on the server side, e.g. by hits.
    /// Causes reaction on client side: The health and shield bar is updated on the game client user interface.
    /// </summary>
    public readonly ref struct CurrentHealthAndShield
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CurrentHealthAndShield(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CurrentHealthAndShield(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x26;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFF;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the health.
        /// </summary>
        public ushort Health
        {
            get => ReadUInt16BigEndian(this.data.Slice(4));
            set => WriteUInt16BigEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the shield.
        /// </summary>
        public ushort Shield
        {
            get => ReadUInt16BigEndian(this.data.Slice(7));
            set => WriteUInt16BigEndian(this.data.Slice(7), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CurrentHealthAndShield"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CurrentHealthAndShield(Span<byte> packet) => new CurrentHealthAndShield(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CurrentHealthAndShield"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CurrentHealthAndShield packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: When the maximum health changed, e.g. by adding stat points or changed items.
    /// Causes reaction on client side: The health and shield bar is updated on the game client user interface.
    /// </summary>
    public readonly ref struct MaximumHealthAndShield
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MaximumHealthAndShield(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MaximumHealthAndShield(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x26;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFE;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the health.
        /// </summary>
        public ushort Health
        {
            get => ReadUInt16BigEndian(this.data.Slice(4));
            set => WriteUInt16BigEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the shield.
        /// </summary>
        public ushort Shield
        {
            get => ReadUInt16BigEndian(this.data.Slice(7));
            set => WriteUInt16BigEndian(this.data.Slice(7), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MaximumHealthAndShield"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MaximumHealthAndShield(Span<byte> packet) => new MaximumHealthAndShield(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MaximumHealthAndShield"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MaximumHealthAndShield packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: When the consumption of an item failed.
    /// Causes reaction on client side: The game client gets a feedback about a failed consumption, and allows for do further consumption requests.
    /// </summary>
    public readonly ref struct ItemConsumptionFailed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemConsumptionFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemConsumptionFailed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemConsumptionFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemConsumptionFailed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x26;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFD;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the health.
        /// </summary>
        public ushort Health
        {
            get => ReadUInt16BigEndian(this.data.Slice(4));
            set => WriteUInt16BigEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the shield.
        /// </summary>
        public ushort Shield
        {
            get => ReadUInt16BigEndian(this.data.Slice(7));
            set => WriteUInt16BigEndian(this.data.Slice(7), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemConsumptionFailed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemConsumptionFailed(Span<byte> packet) => new ItemConsumptionFailed(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemConsumptionFailed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemConsumptionFailed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The currently available mana or ability has changed, e.g. by using a skill.
    /// Causes reaction on client side: The mana and ability bar is updated on the game client user interface.
    /// </summary>
    public readonly ref struct CurrentManaAndAbility
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CurrentManaAndAbility(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CurrentManaAndAbility(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x27;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFF;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the mana.
        /// </summary>
        public ushort Mana
        {
            get => ReadUInt16BigEndian(this.data.Slice(4));
            set => WriteUInt16BigEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the ability.
        /// </summary>
        public ushort Ability
        {
            get => ReadUInt16BigEndian(this.data.Slice(6));
            set => WriteUInt16BigEndian(this.data.Slice(6), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CurrentManaAndAbility"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CurrentManaAndAbility(Span<byte> packet) => new CurrentManaAndAbility(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CurrentManaAndAbility"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CurrentManaAndAbility packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The maximum available mana or ability has changed, e.g. by adding stat points.
    /// Causes reaction on client side: The mana and ability bar is updated on the game client user interface.
    /// </summary>
    public readonly ref struct MaximumManaAndAbility
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MaximumManaAndAbility(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MaximumManaAndAbility(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x27;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFE;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the mana.
        /// </summary>
        public ushort Mana
        {
            get => ReadUInt16BigEndian(this.data.Slice(4));
            set => WriteUInt16BigEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the ability.
        /// </summary>
        public ushort Ability
        {
            get => ReadUInt16BigEndian(this.data.Slice(6));
            set => WriteUInt16BigEndian(this.data.Slice(6), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MaximumManaAndAbility"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MaximumManaAndAbility(Span<byte> packet) => new MaximumManaAndAbility(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MaximumManaAndAbility"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MaximumManaAndAbility packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The item has been removed from the inventory of the player.
    /// Causes reaction on client side: The client removes the item in the inventory user interface.
    /// </summary>
    public readonly ref struct ItemRemoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemRemoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemRemoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                this.TrueFlag = 1;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x28;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the affected slot of the item in the inventory.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the true flag.
        /// </summary>
        public byte TrueFlag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemRemoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemRemoved(Span<byte> packet) => new ItemRemoved(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemRemoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemRemoved packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The client requested to consume a special item, e.g. a bottle of Ale.
    /// Causes reaction on client side: The player is shown in a red color and has increased attack speed.
    /// </summary>
    public readonly ref struct ConsumeItemWithEffect
    {
        /// <summary>
        /// Defines a consumed item.
        /// </summary>
        public enum ConsumedItemType
        {
            /// <summary>
            /// The player consumes a bottle of ale, usually 80 seconds effect time.
            /// </summary>
            Ale = 0,

            /// <summary>
            /// The player consumes a redemy of love, usually 90 seconds effect time.
            /// </summary>
            RedemyOfLove = 1,

            /// <summary>
            /// The player consumes a potion of soul, usually 60 seconds effect time.
            /// </summary>
            PotionOfSoul = 77,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConsumeItemWithEffect"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ConsumeItemWithEffect(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConsumeItemWithEffect"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ConsumeItemWithEffect(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x29;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the item type.
        /// </summary>
        public ConsumeItemWithEffect.ConsumedItemType ItemType
        {
            get => (ConsumedItemType)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the effect time in seconds.
        /// </summary>
        public ushort EffectTimeInSeconds
        {
            get => ReadUInt16BigEndian(this.data.Slice(4));
            set => WriteUInt16BigEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ConsumeItemWithEffect"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ConsumeItemWithEffect(Span<byte> packet) => new ConsumeItemWithEffect(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ConsumeItemWithEffect"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ConsumeItemWithEffect packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The durability of an item in the inventory of the player has been changed.
    /// Causes reaction on client side: The client updates the item in the inventory user interface.
    /// </summary>
    public readonly ref struct ItemDurabilityChanged
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemDurabilityChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemDurabilityChanged(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemDurabilityChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemDurabilityChanged(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x2A;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the durability.
        /// </summary>
        public byte Durability
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets true, if the change resulted from an item consumption; otherwise, false
        /// </summary>
        public bool ByConsumption
        {
            get => this.data.Slice(5).GetBoolean();
            set => this.data.Slice(5).SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemDurabilityChanged"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemDurabilityChanged(Span<byte> packet) => new ItemDurabilityChanged(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemDurabilityChanged"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemDurabilityChanged packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the client talked to an NPC which should cause a dialog to open on the client side.
    /// Causes reaction on client side: The client opens the specified dialog.
    /// </summary>
    public readonly ref struct NpcWindowResponse
    {
        /// <summary>
        /// Defines the kind of npc window which should be shown on the client.
        /// </summary>
        public enum NpcWindow
        {
            /// <summary>
            /// A merchant window.
            /// </summary>
            Merchant = 0,

            /// <summary>
            /// Another merchant window.
            /// </summary>
            Merchant1 = 1,

            /// <summary>
            /// A vault storage.
            /// </summary>
            VaultStorage = 2,

            /// <summary>
            /// A chaos machine window.
            /// </summary>
            ChaosMachine = 3,

            /// <summary>
            /// A devil square window.
            /// </summary>
            DevilSquare = 4,

            /// <summary>
            /// A blood castle window.
            /// </summary>
            BloodCastle = 6,

            /// <summary>
            /// The pet trainer window.
            /// </summary>
            PetTrainer = 7,

            /// <summary>
            /// The lahap window.
            /// </summary>
            Lahap = 9,

            /// <summary>
            /// The castle senior window.
            /// </summary>
            CastleSeniorNPC = 12,

            /// <summary>
            /// The elphis refinery window.
            /// </summary>
            ElphisRefinery = 17,

            /// <summary>
            /// The refine stone making window.
            /// </summary>
            RefineStoneMaking = 18,

            /// <summary>
            /// The jewel of harmony option removal window.
            /// </summary>
            RemoveJohOption = 19,

            /// <summary>
            /// The illusion temple window.
            /// </summary>
            IllusionTemple = 20,

            /// <summary>
            /// The chaos card combination window.
            /// </summary>
            ChaosCardCombination = 21,

            /// <summary>
            /// The cherry blossom branches assembly window.
            /// </summary>
            CherryBlossomBranchesAssembly = 22,

            /// <summary>
            /// The seed master window.
            /// </summary>
            SeedMaster = 23,

            /// <summary>
            /// The seed researcher window.
            /// </summary>
            SeedResearcher = 24,

            /// <summary>
            /// The stat reinitializer window.
            /// </summary>
            StatReInitializer = 25,

            /// <summary>
            /// The delgado lucky coin registration window.
            /// </summary>
            DelgadoLuckyCoinRegistration = 32,

            /// <summary>
            /// The doorkeeper titus duel watch window.
            /// </summary>
            DoorkeeperTitusDuelWatch = 33,

            /// <summary>
            /// The lugard doppelganger entry window.
            /// </summary>
            LugardDoppelgangerEntry = 35,

            /// <summary>
            /// The jerint gaion event entry window.
            /// </summary>
            JerintGaionEvententry = 36,

            /// <summary>
            /// The julia warp market server window.
            /// </summary>
            JuliaWarpMarketServer = 37,

            /// <summary>
            /// The dialog window which allows to exchange or refine Lucky Item. Used by NPC "David".
            /// </summary>
            CombineLuckyItem = 38,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcWindowResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public NpcWindowResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcWindowResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private NpcWindowResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x30;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 11;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the window.
        /// </summary>
        public NpcWindowResponse.NpcWindow Window
        {
            get => (NpcWindow)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="NpcWindowResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator NpcWindowResponse(Span<byte> packet) => new NpcWindowResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="NpcWindowResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(NpcWindowResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player opens a merchant npc or the vault. It's sent after the dialog was opened by another message.
    /// Causes reaction on client side: The client shows the items in the opened dialog.
    /// </summary>
    public readonly ref struct StoreItemList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="StoreItemList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public StoreItemList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StoreItemList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private StoreItemList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x31;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public ushort ItemCount
        {
            get => ReadUInt16BigEndian(this.data.Slice(4));
            set => WriteUInt16BigEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets the <see cref="StoredItem"/> of the specified index.
        /// </summary>
        public StoredItem this[int index, int storedItemLength] => new StoredItem(this.data.Slice(6 + (index * storedItemLength)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="StoreItemList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator StoreItemList(Span<byte> packet) => new StoreItemList(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="StoreItemList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(StoreItemList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="StoredItem"/> and it's size.
        /// </summary>
        /// <param name="itemsCount">The count of <see cref="StoredItem"/> from which the size will be calculated.</param>
        /// <param name="structLength">The length of <see cref="StoredItem"/> from which the size will be calculated.</param>
          public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 6;
    }


    /// <summary>
    /// Is sent by the server when: The request of buying an item from a NPC failed.
    /// Causes reaction on client side: The client is responsive again. Without this message, it may stuck.
    /// </summary>
    public readonly ref struct NpcItemBuyFailed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcItemBuyFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public NpcItemBuyFailed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcItemBuyFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private NpcItemBuyFailed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x32;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFF;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="NpcItemBuyFailed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator NpcItemBuyFailed(Span<byte> packet) => new NpcItemBuyFailed(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="NpcItemBuyFailed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(NpcItemBuyFailed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The request of buying an item from a player or npc was successful.
    /// Causes reaction on client side: The bought item is added to the inventory.
    /// </summary>
    public readonly ref struct ItemBought
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemBought"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemBought(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemBought"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemBought(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x32;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemBought"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemBought(Span<byte> packet) => new ItemBought(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemBought"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemBought packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
    }


    /// <summary>
    /// Is sent by the server when: The result of a previous item sell request.
    /// Causes reaction on client side: The amount of specified money is set at the players inventory.
    /// </summary>
    public readonly ref struct NpcItemSellResult
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcItemSellResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public NpcItemSellResult(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcItemSellResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private NpcItemSellResult(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x33;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the money.
        /// </summary>
        public uint Money
        {
            get => ReadUInt32LittleEndian(this.data.Slice(4));
            set => WriteUInt32LittleEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="NpcItemSellResult"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator NpcItemSellResult(Span<byte> packet) => new NpcItemSellResult(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="NpcItemSellResult"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(NpcItemSellResult packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player requested to set a price for an item of the players shop.
    /// Causes reaction on client side: The item gets a price on the user interface.
    /// </summary>
    public readonly ref struct PlayerShopSetItemPriceResponse
    {
        /// <summary>
        /// Describes the possible results of setting an item price in a player shop.
        /// </summary>
        public enum ItemPriceSetResult
        {
            /// <summary>
            /// Failed, e.g. because the shop feature is deactivated
            /// </summary>
            Failed = 0,

            /// <summary>
            /// The price has been set successfully
            /// </summary>
            Success = 1,

            /// <summary>
            /// Failed because the item slot was out of range
            /// </summary>
            ItemSlotOutOfRange = 2,

            /// <summary>
            /// Failed because the item could not be found
            /// </summary>
            ItemNotFound = 3,

            /// <summary>
            /// Failed because the price was negative
            /// </summary>
            PriceNegative = 4,

            /// <summary>
            /// Failed because the item is blocked
            /// </summary>
            ItemIsBlocked = 5,

            /// <summary>
            /// Failed because the character level is too low (below level 6)
            /// </summary>
            CharacterLevelTooLow = 6,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopSetItemPriceResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopSetItemPriceResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopSetItemPriceResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopSetItemPriceResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public PlayerShopSetItemPriceResponse.ItemPriceSetResult Result
        {
            get => (ItemPriceSetResult)this.data.Slice(4)[0];
            set => this.data.Slice(4)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopSetItemPriceResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopSetItemPriceResponse(Span<byte> packet) => new PlayerShopSetItemPriceResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopSetItemPriceResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopSetItemPriceResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a player in scope requested to close his shop or after all items has been sold.
    /// Causes reaction on client side: The player shop not shown as open anymore.
    /// </summary>
    public readonly ref struct PlayerShopClosed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopClosed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopClosed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopClosed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopClosed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Success = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x3;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(4).GetBoolean();
            set => this.data.Slice(4).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(5));
            set => WriteUInt16BigEndian(this.data.Slice(5), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopClosed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopClosed(Span<byte> packet) => new PlayerShopClosed(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopClosed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopClosed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An item of the players shop was sold to another player.
    /// Causes reaction on client side: The item is removed from the players inventory and a blue system message appears.
    /// </summary>
    public readonly ref struct PlayerShopItemSoldToPlayer
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItemSoldToPlayer"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopItemSoldToPlayer(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItemSoldToPlayer"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopItemSoldToPlayer(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x08;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 15;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the buyer name.
        /// </summary>
        public string BuyerName
        {
            get => this.data.ExtractString(5, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(5, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopItemSoldToPlayer"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopItemSoldToPlayer(Span<byte> packet) => new PlayerShopItemSoldToPlayer(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopItemSoldToPlayer"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopItemSoldToPlayer packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to close his shop or after all items has been sold.
    /// Causes reaction on client side: The player shop dialog is closed for the shop of the specified player.
    /// </summary>
    public readonly ref struct ClosePlayerShopDialog
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ClosePlayerShopDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ClosePlayerShopDialog(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ClosePlayerShopDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ClosePlayerShopDialog(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x12;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(4));
            set => WriteUInt16BigEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ClosePlayerShopDialog"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ClosePlayerShopDialog(Span<byte> packet) => new ClosePlayerShopDialog(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ClosePlayerShopDialog"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ClosePlayerShopDialog packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to open a shop of another player.
    /// Causes reaction on client side: The player shop dialog is shown with the provided item data.
    /// </summary>
    public readonly ref struct PlayerShopItemList
    {
        /// <summary>
        /// The kind of action which led to the list message.
        /// </summary>
        public enum ActionKind
        {
            /// <summary>
            /// The list was requested.
            /// </summary>
            ByRequest = 5,

            /// <summary>
            /// The list was changed, e.g. because an item was sold.
            /// </summary>
            UpdateAfterItemChange = 19,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItemList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopItemList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItemList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopItemList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
                this.Success = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x05;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2HeaderWithSubCode Header => new C2HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the action.
        /// </summary>
        public PlayerShopItemList.ActionKind Action
        {
            get => (ActionKind)this.data.Slice(4)[0];
            set => this.data.Slice(4)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(5).GetBoolean();
            set => this.data.Slice(5).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(6));
            set => WriteUInt16BigEndian(this.data.Slice(6), value);
        }

        /// <summary>
        /// Gets or sets the player name.
        /// </summary>
        public string PlayerName
        {
            get => this.data.ExtractString(8, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(8, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the shop name.
        /// </summary>
        public string ShopName
        {
            get => this.data.ExtractString(18, 36, System.Text.Encoding.UTF8);
            set => this.data.Slice(18, 36).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[54];
            set => this.data[54] = value;
        }

        /// <summary>
        /// Gets the <see cref="PlayerShopItem"/> of the specified index.
        /// </summary>
        public PlayerShopItem this[int index] => new PlayerShopItem(this.data.Slice(55 + (index * PlayerShopItem.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopItemList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopItemList(Span<byte> packet) => new PlayerShopItemList(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopItemList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopItemList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="PlayerShopItem"/>.
        /// </summary>
        /// <param name="itemsCount">The count of <see cref="PlayerShopItem"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int itemsCount) => itemsCount * PlayerShopItem.Length + 55;
    }


    /// <summary>
    /// Is sent by the server when: After the player gets into scope of a player with an opened shop.
    /// Causes reaction on client side: The player shop title is shown at the specified players.
    /// </summary>
    public readonly ref struct PlayerShops
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShops"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShops(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShops"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShops(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2HeaderWithSubCode Header => new C2HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the shop count.
        /// </summary>
        public byte ShopCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets the <see cref="PlayerShop"/> of the specified index.
        /// </summary>
        public PlayerShop this[int index] => new PlayerShop(this.data.Slice(6 + (index * PlayerShop.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShops"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShops(Span<byte> packet) => new PlayerShops(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShops"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShops packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="PlayerShop"/>.
        /// </summary>
        /// <param name="shopsCount">The count of <see cref="PlayerShop"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int shopsCount) => shopsCount * PlayerShop.Length + 6;


    /// <summary>
    /// Data of the shop of a player..
    /// </summary>
    public readonly ref struct PlayerShop
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShop"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShop(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 38;

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(0));
            set => WriteUInt16BigEndian(this.data.Slice(0), value);
        }

        /// <summary>
        /// Gets or sets the store name.
        /// </summary>
        public string StoreName
        {
            get => this.data.ExtractString(2, 36, System.Text.Encoding.UTF8);
            set => this.data.Slice(2, 36).WriteString(value, System.Text.Encoding.UTF8);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the game client requested it, usually after a successful login.
    /// Causes reaction on client side: The game client shows the available characters of the account.
    /// </summary>
    public readonly ref struct CharacterList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the creation flags.
        /// </summary>
        public byte CreationFlags
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the move cnt.
        /// </summary>
        public byte MoveCnt
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the character count.
        /// </summary>
        public byte CharacterCount
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the is vault extended.
        /// </summary>
        public bool IsVaultExtended
        {
            get => this.data.Slice(7).GetBoolean();
            set => this.data.Slice(7).SetBoolean(value);
        }

        /// <summary>
        /// Gets the <see cref="CharacterData"/> of the specified index.
        /// </summary>
        public CharacterData this[int index] => new CharacterData(this.data.Slice(8 + (index * CharacterData.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterList(Span<byte> packet) => new CharacterList(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
        /// </summary>
        /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 8;


    /// <summary>
    /// Data of one character in the list..
    /// </summary>
    public readonly ref struct CharacterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 34;

        /// <summary>
        /// Gets or sets the slot index.
        /// </summary>
        public byte SlotIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(1, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(1, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => ReadUInt16LittleEndian(this.data.Slice(12));
            set => WriteUInt16LittleEndian(this.data.Slice(12), value);
        }

        /// <summary>
        /// Gets or sets the status.
        /// </summary>
        public CharacterStatus Status
        {
            get => (CharacterStatus)this.data.Slice(14).GetByteValue(4, 0);
            set => this.data.Slice(14).SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the is item block active.
        /// </summary>
        public bool IsItemBlockActive
        {
            get => this.data.Slice(14).GetBoolean(4);
            set => this.data.Slice(14).SetBoolean(value, 4);
        }

        /// <summary>
        /// Gets or sets the appearance.
        /// </summary>
        public Span<byte> Appearance
        {
            get => this.data.Slice(15, 18);
        }

        /// <summary>
        /// Gets or sets the guild position.
        /// </summary>
        public GuildMemberRole GuildPosition
        {
            get => (GuildMemberRole)this.data.Slice(33)[0];
            set => this.data.Slice(33)[0] = (byte)value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the game client requested it, usually after a successful login.
    /// Causes reaction on client side: The game client shows the available characters of the account.
    /// </summary>
    public readonly ref struct CharacterList075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterList075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterList075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the character count.
        /// </summary>
        public byte CharacterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="CharacterData"/> of the specified index.
        /// </summary>
        public CharacterData this[int index] => new CharacterData(this.data.Slice(5 + (index * CharacterData.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterList075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterList075(Span<byte> packet) => new CharacterList075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterList075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterList075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
        /// </summary>
        /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 5;


    /// <summary>
    /// Data of one character in the list..
    /// </summary>
    public readonly ref struct CharacterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 24;

        /// <summary>
        /// Gets or sets the slot index.
        /// </summary>
        public byte SlotIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(1, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(1, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => ReadUInt16LittleEndian(this.data.Slice(11));
            set => WriteUInt16LittleEndian(this.data.Slice(11), value);
        }

        /// <summary>
        /// Gets or sets the status.
        /// </summary>
        public CharacterStatus Status
        {
            get => (CharacterStatus)this.data.Slice(13).GetByteValue(4, 0);
            set => this.data.Slice(13).SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the is item block active.
        /// </summary>
        public bool IsItemBlockActive
        {
            get => this.data.Slice(13).GetBoolean(4);
            set => this.data.Slice(13).SetBoolean(value, 4);
        }

        /// <summary>
        /// Gets or sets the appearance.
        /// </summary>
        public Span<byte> Appearance
        {
            get => this.data.Slice(14, 9);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the server successfully processed a character creation request.
    /// Causes reaction on client side: The new character is shown in the character list
    /// </summary>
    public readonly ref struct CharacterCreationSuccessful
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterCreationSuccessful"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterCreationSuccessful(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterCreationSuccessful"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterCreationSuccessful(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Success = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 42;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(4).GetBoolean();
            set => this.data.Slice(4).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the character name.
        /// </summary>
        public string CharacterName
        {
            get => this.data.ExtractString(5, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(5, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the character slot.
        /// </summary>
        public byte CharacterSlot
        {
            get => this.data[15];
            set => this.data[15] = value;
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => ReadUInt16LittleEndian(this.data.Slice(16));
            set => WriteUInt16LittleEndian(this.data.Slice(16), value);
        }

        /// <summary>
        /// Gets or sets the class.
        /// </summary>
        public CharacterClassNumber Class
        {
            get => (CharacterClassNumber)this.data.Slice(18).GetByteValue(8, 3);
            set => this.data.Slice(18).SetByteValue((byte)value, 8, 3);
        }

        /// <summary>
        /// Gets or sets the character status.
        /// </summary>
        public byte CharacterStatus
        {
            get => this.data[19];
            set => this.data[19] = value;
        }

        /// <summary>
        /// Gets or sets the preview data.
        /// </summary>
        public Span<byte> PreviewData
        {
            get => this.data.Slice(20);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterCreationSuccessful"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterCreationSuccessful(Span<byte> packet) => new CharacterCreationSuccessful(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterCreationSuccessful"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterCreationSuccessful packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="PreviewData"/>.
        /// </summary>
        /// <param name="previewDataLength">The length in bytes of <see cref="PreviewData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int previewDataLength) => previewDataLength + 20;
    }


    /// <summary>
    /// Is sent by the server when: After the server processed a character creation request without success.
    /// Causes reaction on client side: A message is shown that it failed. 
    /// </summary>
    public readonly ref struct CharacterCreationFailed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterCreationFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterCreationFailed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterCreationFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterCreationFailed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterCreationFailed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterCreationFailed(Span<byte> packet) => new CharacterCreationFailed(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterCreationFailed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterCreationFailed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a the hero state of an observed character changed.
    /// Causes reaction on client side: The color of the name of the character is changed accordingly and a message is shown.
    /// </summary>
    public readonly ref struct HeroStateChanged
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="HeroStateChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public HeroStateChanged(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="HeroStateChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private HeroStateChanged(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x08;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(4));
            set => WriteUInt16BigEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the new state.
        /// </summary>
        public CharacterHeroState NewState
        {
            get => (CharacterHeroState)this.data.Slice(6)[0];
            set => this.data.Slice(6)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="HeroStateChanged"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator HeroStateChanged(Span<byte> packet) => new HeroStateChanged(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="HeroStateChanged"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(HeroStateChanged packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </summary>
    public readonly ref struct SkillAdded
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillAdded(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillAdded(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Flag = 0xFE;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the flag.
        /// </summary>
        public byte Flag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the skill number.
        /// </summary>
        public ushort SkillNumber
        {
            get => ReadUInt16LittleEndian(this.data.Slice(7));
            set => WriteUInt16LittleEndian(this.data.Slice(7), value);
        }

        /// <summary>
        /// Gets or sets the skill level.
        /// </summary>
        public byte SkillLevel
        {
            get => this.data[9];
            set => this.data[9] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAdded"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillAdded(Span<byte> packet) => new SkillAdded(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillAdded"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillAdded packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </summary>
    public readonly ref struct SkillRemoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillRemoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillRemoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Flag = 0xFF;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the flag.
        /// </summary>
        public byte Flag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the skill number.
        /// </summary>
        public ushort SkillNumber
        {
            get => ReadUInt16LittleEndian(this.data.Slice(7));
            set => WriteUInt16LittleEndian(this.data.Slice(7), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillRemoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillRemoved(Span<byte> packet) => new SkillRemoved(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillRemoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillRemoved packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Usually, when the player entered the game with a character. When skills get added or removed, this message is sent as well, but with a misleading count.
    /// Causes reaction on client side: The skill list gets initialized.
    /// </summary>
    public readonly ref struct SkillListUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillListUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillListUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets mixed usage: Skill list count (when list). 0xFE when adding a skill, 0xFF when removing a Skill.
        /// </summary>
        public byte Count
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="SkillEntry"/> of the specified index.
        /// </summary>
        public SkillEntry this[int index] => new SkillEntry(this.data.Slice(6 + (index * SkillEntry.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillListUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillListUpdate(Span<byte> packet) => new SkillListUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillListUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillListUpdate packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="SkillEntry"/>.
        /// </summary>
        /// <param name="skillsCount">The count of <see cref="SkillEntry"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int skillsCount) => skillsCount * SkillEntry.Length + 6;


    /// <summary>
    /// Structure for a skill entry of the skill list..
    /// </summary>
    public readonly ref struct SkillEntry
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillEntry"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillEntry(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the skill number.
        /// </summary>
        public ushort SkillNumber
        {
            get => ReadUInt16LittleEndian(this.data.Slice(1));
            set => WriteUInt16LittleEndian(this.data.Slice(1), value);
        }

        /// <summary>
        /// Gets or sets the skill level.
        /// </summary>
        public byte SkillLevel
        {
            get => this.data[2];
            set => this.data[2] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </summary>
    public readonly ref struct SkillAdded075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAdded075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillAdded075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAdded075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillAdded075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Flag = 0xFE;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the flag.
        /// </summary>
        public byte Flag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the skill number and level.
        /// </summary>
        public ushort SkillNumberAndLevel
        {
            get => ReadUInt16BigEndian(this.data.Slice(6));
            set => WriteUInt16BigEndian(this.data.Slice(6), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAdded075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillAdded075(Span<byte> packet) => new SkillAdded075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillAdded075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillAdded075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </summary>
    public readonly ref struct SkillRemoved075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillRemoved075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillRemoved075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillRemoved075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillRemoved075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Flag = 0xFF;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the flag.
        /// </summary>
        public byte Flag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the skill number and level.
        /// </summary>
        public ushort SkillNumberAndLevel
        {
            get => ReadUInt16BigEndian(this.data.Slice(6));
            set => WriteUInt16BigEndian(this.data.Slice(6), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillRemoved075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillRemoved075(Span<byte> packet) => new SkillRemoved075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillRemoved075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillRemoved075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Usually, when the player entered the game with a character. When skills get added or removed, this message is sent as well, but with a misleading count.
    /// Causes reaction on client side: The skill list gets initialized.
    /// </summary>
    public readonly ref struct SkillListUpdate075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillListUpdate075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillListUpdate075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets mixed usage: Skill list count (when list). 0xFE when adding a skill, 0xFF when removing a Skill.
        /// </summary>
        public byte Count
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="SkillEntry"/> of the specified index.
        /// </summary>
        public SkillEntry this[int index] => new SkillEntry(this.data.Slice(5 + (index * SkillEntry.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillListUpdate075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillListUpdate075(Span<byte> packet) => new SkillListUpdate075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillListUpdate075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillListUpdate075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="SkillEntry"/>.
        /// </summary>
        /// <param name="skillsCount">The count of <see cref="SkillEntry"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int skillsCount) => skillsCount * SkillEntry.Length + 5;


    /// <summary>
    /// Structure for a skill entry of the skill list..
    /// </summary>
    public readonly ref struct SkillEntry
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillEntry"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillEntry(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 3;

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the skill number and level.
        /// </summary>
        public ushort SkillNumberAndLevel
        {
            get => ReadUInt16BigEndian(this.data.Slice(1));
            set => WriteUInt16BigEndian(this.data.Slice(1), value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the client focused the character successfully on the server side.
    /// Causes reaction on client side: The client highlights the focused character.
    /// </summary>
    public readonly ref struct CharacterFocused
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterFocused"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterFocused(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterFocused"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterFocused(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x15;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 15;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the character name.
        /// </summary>
        public string CharacterName
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterFocused"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterFocused(Span<byte> packet) => new CharacterFocused(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterFocused"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterFocused packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the server processed a character stat increase request packet.
    /// Causes reaction on client side: If it was successful, adds a point to the requested stat type.
    /// </summary>
    public readonly ref struct CharacterStatIncreaseResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterStatIncreaseResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterStatIncreaseResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x06;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(4).GetBoolean(4);
            set => this.data.Slice(4).SetBoolean(value, 4);
        }

        /// <summary>
        /// Gets or sets the attribute.
        /// </summary>
        public CharacterStatAttribute Attribute
        {
            get => (CharacterStatAttribute)this.data.Slice(4).GetByteValue(4, 0);
            set => this.data.Slice(4).SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the updated dependent maximum stat.
        /// </summary>
        public ushort UpdatedDependentMaximumStat
        {
            get => ReadUInt16LittleEndian(this.data.Slice(6));
            set => WriteUInt16LittleEndian(this.data.Slice(6), value);
        }

        /// <summary>
        /// Gets or sets the updated maximum shield.
        /// </summary>
        public ushort UpdatedMaximumShield
        {
            get => ReadUInt16LittleEndian(this.data.Slice(8));
            set => WriteUInt16LittleEndian(this.data.Slice(8), value);
        }

        /// <summary>
        /// Gets or sets the updated maximum ability.
        /// </summary>
        public ushort UpdatedMaximumAbility
        {
            get => ReadUInt16LittleEndian(this.data.Slice(10));
            set => WriteUInt16LittleEndian(this.data.Slice(10), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterStatIncreaseResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterStatIncreaseResponse(Span<byte> packet) => new CharacterStatIncreaseResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterStatIncreaseResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterStatIncreaseResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the server processed a character delete response of the client.
    /// Causes reaction on client side: If successful, the character is deleted from the character selection screen. Otherwise, a message is shown.
    /// </summary>
    public readonly ref struct CharacterDeleteResponse
    {
        /// <summary>
        /// Result of a character delete request.
        /// </summary>
        public enum CharacterDeleteResult
        {
            /// <summary>
            /// Deleting was not successful
            /// </summary>
            Unsuccessful = 0,

            /// <summary>
            /// Deleting was successful
            /// </summary>
            Successful = 1,

            /// <summary>
            /// Deleting was not successful because a wrong security code was entered
            /// </summary>
            WrongSecurityCode = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterDeleteResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterDeleteResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterDeleteResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterDeleteResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x02;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public CharacterDeleteResponse.CharacterDeleteResult Result
        {
            get => (CharacterDeleteResult)this.data.Slice(4)[0];
            set => this.data.Slice(4)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterDeleteResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterDeleteResponse(Span<byte> packet) => new CharacterDeleteResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterDeleteResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterDeleteResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a character leveled up.
    /// Causes reaction on client side: Updates the level (and other related stats) in the game client and shows an effect.
    /// </summary>
    public readonly ref struct CharacterLevelUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterLevelUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterLevelUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x05;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 24;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => ReadUInt16LittleEndian(this.data.Slice(4));
            set => WriteUInt16LittleEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the level up points.
        /// </summary>
        public ushort LevelUpPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(6));
            set => WriteUInt16LittleEndian(this.data.Slice(6), value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => ReadUInt16LittleEndian(this.data.Slice(8));
            set => WriteUInt16LittleEndian(this.data.Slice(8), value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => ReadUInt16LittleEndian(this.data.Slice(10));
            set => WriteUInt16LittleEndian(this.data.Slice(10), value);
        }

        /// <summary>
        /// Gets or sets the maximum shield.
        /// </summary>
        public ushort MaximumShield
        {
            get => ReadUInt16LittleEndian(this.data.Slice(12));
            set => WriteUInt16LittleEndian(this.data.Slice(12), value);
        }

        /// <summary>
        /// Gets or sets the maximum ability.
        /// </summary>
        public ushort MaximumAbility
        {
            get => ReadUInt16LittleEndian(this.data.Slice(14));
            set => WriteUInt16LittleEndian(this.data.Slice(14), value);
        }

        /// <summary>
        /// Gets or sets the fruit points.
        /// </summary>
        public ushort FruitPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(16));
            set => WriteUInt16LittleEndian(this.data.Slice(16), value);
        }

        /// <summary>
        /// Gets or sets the maximum fruit points.
        /// </summary>
        public ushort MaximumFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(18));
            set => WriteUInt16LittleEndian(this.data.Slice(18), value);
        }

        /// <summary>
        /// Gets or sets the negative fruit points.
        /// </summary>
        public ushort NegativeFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(20));
            set => WriteUInt16LittleEndian(this.data.Slice(20), value);
        }

        /// <summary>
        /// Gets or sets the maximum negative fruit points.
        /// </summary>
        public ushort MaximumNegativeFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(22));
            set => WriteUInt16LittleEndian(this.data.Slice(22), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterLevelUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterLevelUpdate(Span<byte> packet) => new CharacterLevelUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterLevelUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterLevelUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the character was selected by the player and entered the game.
    /// Causes reaction on client side: The characters enters the game world.
    /// </summary>
    public readonly ref struct CharacterInformation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterInformation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterInformation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x03;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 72;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the x.
        /// </summary>
        public byte X
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the y.
        /// </summary>
        public byte Y
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the map id.
        /// </summary>
        public ushort MapId
        {
            get => ReadUInt16LittleEndian(this.data.Slice(6));
            set => WriteUInt16LittleEndian(this.data.Slice(6), value);
        }

        /// <summary>
        /// Gets or sets the current experience.
        /// </summary>
        public ulong CurrentExperience
        {
            get => ReadUInt64BigEndian(this.data.Slice(8));
            set => WriteUInt64BigEndian(this.data.Slice(8), value);
        }

        /// <summary>
        /// Gets or sets the experience for next level.
        /// </summary>
        public ulong ExperienceForNextLevel
        {
            get => ReadUInt64BigEndian(this.data.Slice(16));
            set => WriteUInt64BigEndian(this.data.Slice(16), value);
        }

        /// <summary>
        /// Gets or sets the level up points.
        /// </summary>
        public ushort LevelUpPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(24));
            set => WriteUInt16LittleEndian(this.data.Slice(24), value);
        }

        /// <summary>
        /// Gets or sets the strength.
        /// </summary>
        public ushort Strength
        {
            get => ReadUInt16LittleEndian(this.data.Slice(26));
            set => WriteUInt16LittleEndian(this.data.Slice(26), value);
        }

        /// <summary>
        /// Gets or sets the agility.
        /// </summary>
        public ushort Agility
        {
            get => ReadUInt16LittleEndian(this.data.Slice(28));
            set => WriteUInt16LittleEndian(this.data.Slice(28), value);
        }

        /// <summary>
        /// Gets or sets the vitality.
        /// </summary>
        public ushort Vitality
        {
            get => ReadUInt16LittleEndian(this.data.Slice(30));
            set => WriteUInt16LittleEndian(this.data.Slice(30), value);
        }

        /// <summary>
        /// Gets or sets the energy.
        /// </summary>
        public ushort Energy
        {
            get => ReadUInt16LittleEndian(this.data.Slice(32));
            set => WriteUInt16LittleEndian(this.data.Slice(32), value);
        }

        /// <summary>
        /// Gets or sets the current health.
        /// </summary>
        public ushort CurrentHealth
        {
            get => ReadUInt16LittleEndian(this.data.Slice(34));
            set => WriteUInt16LittleEndian(this.data.Slice(34), value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => ReadUInt16LittleEndian(this.data.Slice(36));
            set => WriteUInt16LittleEndian(this.data.Slice(36), value);
        }

        /// <summary>
        /// Gets or sets the current mana.
        /// </summary>
        public ushort CurrentMana
        {
            get => ReadUInt16LittleEndian(this.data.Slice(38));
            set => WriteUInt16LittleEndian(this.data.Slice(38), value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => ReadUInt16LittleEndian(this.data.Slice(40));
            set => WriteUInt16LittleEndian(this.data.Slice(40), value);
        }

        /// <summary>
        /// Gets or sets the current shield.
        /// </summary>
        public ushort CurrentShield
        {
            get => ReadUInt16LittleEndian(this.data.Slice(42));
            set => WriteUInt16LittleEndian(this.data.Slice(42), value);
        }

        /// <summary>
        /// Gets or sets the maximum shield.
        /// </summary>
        public ushort MaximumShield
        {
            get => ReadUInt16LittleEndian(this.data.Slice(44));
            set => WriteUInt16LittleEndian(this.data.Slice(44), value);
        }

        /// <summary>
        /// Gets or sets the current ability.
        /// </summary>
        public ushort CurrentAbility
        {
            get => ReadUInt16LittleEndian(this.data.Slice(46));
            set => WriteUInt16LittleEndian(this.data.Slice(46), value);
        }

        /// <summary>
        /// Gets or sets the maximum ability.
        /// </summary>
        public ushort MaximumAbility
        {
            get => ReadUInt16LittleEndian(this.data.Slice(48));
            set => WriteUInt16LittleEndian(this.data.Slice(48), value);
        }

        /// <summary>
        /// Gets or sets the money.
        /// </summary>
        public uint Money
        {
            get => ReadUInt32LittleEndian(this.data.Slice(52));
            set => WriteUInt32LittleEndian(this.data.Slice(52), value);
        }

        /// <summary>
        /// Gets or sets the hero state.
        /// </summary>
        public CharacterHeroState HeroState
        {
            get => (CharacterHeroState)this.data.Slice(56)[0];
            set => this.data.Slice(56)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the status.
        /// </summary>
        public CharacterStatus Status
        {
            get => (CharacterStatus)this.data.Slice(57)[0];
            set => this.data.Slice(57)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the used fruit points.
        /// </summary>
        public ushort UsedFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(58));
            set => WriteUInt16LittleEndian(this.data.Slice(58), value);
        }

        /// <summary>
        /// Gets or sets the max fruit points.
        /// </summary>
        public ushort MaxFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(60));
            set => WriteUInt16LittleEndian(this.data.Slice(60), value);
        }

        /// <summary>
        /// Gets or sets the leadership.
        /// </summary>
        public ushort Leadership
        {
            get => ReadUInt16LittleEndian(this.data.Slice(62));
            set => WriteUInt16LittleEndian(this.data.Slice(62), value);
        }

        /// <summary>
        /// Gets or sets the used negative fruit points.
        /// </summary>
        public ushort UsedNegativeFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(64));
            set => WriteUInt16LittleEndian(this.data.Slice(64), value);
        }

        /// <summary>
        /// Gets or sets the max negative fruit points.
        /// </summary>
        public ushort MaxNegativeFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(66));
            set => WriteUInt16LittleEndian(this.data.Slice(66), value);
        }

        /// <summary>
        /// Gets or sets the is vault extended.
        /// </summary>
        public bool IsVaultExtended
        {
            get => this.data.Slice(68).GetBoolean();
            set => this.data.Slice(68).SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInformation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterInformation(Span<byte> packet) => new CharacterInformation(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterInformation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterInformation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the character was selected by the player and entered the game.
    /// Causes reaction on client side: The characters enters the game world.
    /// </summary>
    public readonly ref struct CharacterInformation075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterInformation075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterInformation075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x03;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 42;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new C3HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the x.
        /// </summary>
        public byte X
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the y.
        /// </summary>
        public byte Y
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the map id.
        /// </summary>
        public byte MapId
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the current experience.
        /// </summary>
        public uint CurrentExperience
        {
            get => ReadUInt32LittleEndian(this.data.Slice(8));
            set => WriteUInt32LittleEndian(this.data.Slice(8), value);
        }

        /// <summary>
        /// Gets or sets the experience for next level.
        /// </summary>
        public uint ExperienceForNextLevel
        {
            get => ReadUInt32LittleEndian(this.data.Slice(12));
            set => WriteUInt32LittleEndian(this.data.Slice(12), value);
        }

        /// <summary>
        /// Gets or sets the level up points.
        /// </summary>
        public ushort LevelUpPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(16));
            set => WriteUInt16LittleEndian(this.data.Slice(16), value);
        }

        /// <summary>
        /// Gets or sets the strength.
        /// </summary>
        public ushort Strength
        {
            get => ReadUInt16LittleEndian(this.data.Slice(18));
            set => WriteUInt16LittleEndian(this.data.Slice(18), value);
        }

        /// <summary>
        /// Gets or sets the agility.
        /// </summary>
        public ushort Agility
        {
            get => ReadUInt16LittleEndian(this.data.Slice(20));
            set => WriteUInt16LittleEndian(this.data.Slice(20), value);
        }

        /// <summary>
        /// Gets or sets the vitality.
        /// </summary>
        public ushort Vitality
        {
            get => ReadUInt16LittleEndian(this.data.Slice(22));
            set => WriteUInt16LittleEndian(this.data.Slice(22), value);
        }

        /// <summary>
        /// Gets or sets the energy.
        /// </summary>
        public ushort Energy
        {
            get => ReadUInt16LittleEndian(this.data.Slice(24));
            set => WriteUInt16LittleEndian(this.data.Slice(24), value);
        }

        /// <summary>
        /// Gets or sets the current health.
        /// </summary>
        public ushort CurrentHealth
        {
            get => ReadUInt16LittleEndian(this.data.Slice(26));
            set => WriteUInt16LittleEndian(this.data.Slice(26), value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => ReadUInt16LittleEndian(this.data.Slice(28));
            set => WriteUInt16LittleEndian(this.data.Slice(28), value);
        }

        /// <summary>
        /// Gets or sets the current mana.
        /// </summary>
        public ushort CurrentMana
        {
            get => ReadUInt16LittleEndian(this.data.Slice(30));
            set => WriteUInt16LittleEndian(this.data.Slice(30), value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => ReadUInt16LittleEndian(this.data.Slice(32));
            set => WriteUInt16LittleEndian(this.data.Slice(32), value);
        }

        /// <summary>
        /// Gets or sets the money.
        /// </summary>
        public uint Money
        {
            get => ReadUInt32LittleEndian(this.data.Slice(36));
            set => WriteUInt32LittleEndian(this.data.Slice(36), value);
        }

        /// <summary>
        /// Gets or sets the hero state.
        /// </summary>
        public CharacterHeroState HeroState
        {
            get => (CharacterHeroState)this.data.Slice(40)[0];
            set => this.data.Slice(40)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the status.
        /// </summary>
        public CharacterStatus Status
        {
            get => (CharacterStatus)this.data.Slice(41)[0];
            set => this.data.Slice(41)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInformation075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterInformation075(Span<byte> packet) => new CharacterInformation075(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterInformation075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterInformation075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player entered the game or finished a trade.
    /// Causes reaction on client side: The user interface of the inventory is initialized with all of its items.
    /// </summary>
    public readonly ref struct CharacterInventory
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInventory"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterInventory(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInventory"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterInventory(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC4;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C4HeaderWithSubCode Header => new C4HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets the <see cref="StoredItem"/> of the specified index.
        /// </summary>
        public StoredItem this[int index, int storedItemLength] => new StoredItem(this.data.Slice(6 + (index * storedItemLength)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInventory"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterInventory(Span<byte> packet) => new CharacterInventory(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterInventory"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterInventory packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="StoredItem"/> and it's size.
        /// </summary>
        /// <param name="itemsCount">The count of <see cref="StoredItem"/> from which the size will be calculated.</param>
        /// <param name="structLength">The length of <see cref="StoredItem"/> from which the size will be calculated.</param>
          public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 6;
    }


    /// <summary>
    /// Is sent by the server when: An item in the inventory got upgraded by the player, e.g. by applying a jewel.
    /// Causes reaction on client side: The item is updated on the user interface.
    /// </summary>
    public readonly ref struct InventoryItemUpgraded
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="InventoryItemUpgraded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public InventoryItemUpgraded(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InventoryItemUpgraded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private InventoryItemUpgraded(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x14;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="InventoryItemUpgraded"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator InventoryItemUpgraded(Span<byte> packet) => new InventoryItemUpgraded(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="InventoryItemUpgraded"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(InventoryItemUpgraded packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
    }


    /// <summary>
    /// Is sent by the server when: After entering the game with a master class character.
    /// Causes reaction on client side: The master related data is available.
    /// </summary>
    public readonly ref struct MasterStatsUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterStatsUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MasterStatsUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterStatsUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MasterStatsUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x50;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 32;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the master level.
        /// </summary>
        public ushort MasterLevel
        {
            get => ReadUInt16LittleEndian(this.data.Slice(4));
            set => WriteUInt16LittleEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the master experience.
        /// </summary>
        public ulong MasterExperience
        {
            get => ReadUInt64BigEndian(this.data.Slice(6));
            set => WriteUInt64BigEndian(this.data.Slice(6), value);
        }

        /// <summary>
        /// Gets or sets the master experience of next level.
        /// </summary>
        public ulong MasterExperienceOfNextLevel
        {
            get => ReadUInt64BigEndian(this.data.Slice(14));
            set => WriteUInt64BigEndian(this.data.Slice(14), value);
        }

        /// <summary>
        /// Gets or sets the master level up points.
        /// </summary>
        public ushort MasterLevelUpPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(22));
            set => WriteUInt16LittleEndian(this.data.Slice(22), value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => ReadUInt16LittleEndian(this.data.Slice(24));
            set => WriteUInt16LittleEndian(this.data.Slice(24), value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => ReadUInt16LittleEndian(this.data.Slice(26));
            set => WriteUInt16LittleEndian(this.data.Slice(26), value);
        }

        /// <summary>
        /// Gets or sets the maximum shield.
        /// </summary>
        public ushort MaximumShield
        {
            get => ReadUInt16LittleEndian(this.data.Slice(28));
            set => WriteUInt16LittleEndian(this.data.Slice(28), value);
        }

        /// <summary>
        /// Gets or sets the maximum ability.
        /// </summary>
        public ushort MaximumAbility
        {
            get => ReadUInt16LittleEndian(this.data.Slice(30));
            set => WriteUInt16LittleEndian(this.data.Slice(30), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterStatsUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MasterStatsUpdate(Span<byte> packet) => new MasterStatsUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MasterStatsUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MasterStatsUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a master skill level has been changed (usually increased).
    /// Causes reaction on client side: The level is updated in the master skill tree.
    /// </summary>
    public readonly ref struct MasterSkillLevelUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MasterSkillLevelUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MasterSkillLevelUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x52;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 28;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(4).GetBoolean();
            set => this.data.Slice(4).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the master level up points.
        /// </summary>
        public ushort MasterLevelUpPoints
        {
            get => ReadUInt16LittleEndian(this.data.Slice(6));
            set => WriteUInt16LittleEndian(this.data.Slice(6), value);
        }

        /// <summary>
        /// Gets or sets the index of the master skill on the clients master skill tree for the given character class.
        /// </summary>
        public byte MasterSkillIndex
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the master skill number.
        /// </summary>
        public ushort MasterSkillNumber
        {
            get => ReadUInt16LittleEndian(this.data.Slice(12));
            set => WriteUInt16LittleEndian(this.data.Slice(12), value);
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public byte Level
        {
            get => this.data[16];
            set => this.data[16] = value;
        }

        /// <summary>
        /// Gets or sets the display value.
        /// </summary>
        public float DisplayValue
        {
            get => BitConverter.ToSingle(this.data.Slice(20));
            set => BitConverter.GetBytes(value).CopyTo(this.data.Slice(20));
        }

        /// <summary>
        /// Gets or sets the display value of next level.
        /// </summary>
        public float DisplayValueOfNextLevel
        {
            get => BitConverter.ToSingle(this.data.Slice(24));
            set => BitConverter.GetBytes(value).CopyTo(this.data.Slice(24));
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterSkillLevelUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MasterSkillLevelUpdate(Span<byte> packet) => new MasterSkillLevelUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MasterSkillLevelUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MasterSkillLevelUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Usually after entering the game with a master character.
    /// Causes reaction on client side: The data is available in the master skill tree.
    /// </summary>
    public readonly ref struct MasterSkillList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MasterSkillList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MasterSkillList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x53;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2HeaderWithSubCode Header => new C2HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the master skill count.
        /// </summary>
        public uint MasterSkillCount
        {
            get => ReadUInt32LittleEndian(this.data.Slice(8));
            set => WriteUInt32LittleEndian(this.data.Slice(8), value);
        }

        /// <summary>
        /// Gets the <see cref="MasterSkillEntry"/> of the specified index.
        /// </summary>
        public MasterSkillEntry this[int index] => new MasterSkillEntry(this.data.Slice(12 + (index * MasterSkillEntry.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterSkillList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MasterSkillList(Span<byte> packet) => new MasterSkillList(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MasterSkillList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MasterSkillList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="MasterSkillEntry"/>.
        /// </summary>
        /// <param name="skillsCount">The count of <see cref="MasterSkillEntry"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int skillsCount) => skillsCount * MasterSkillEntry.Length + 12;


    /// <summary>
    /// An entry in the master skill list..
    /// </summary>
    public readonly ref struct MasterSkillEntry
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillEntry"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MasterSkillEntry(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets or sets the index of the master skill on the clients master skill tree for the given character class.
        /// </summary>
        public byte MasterSkillIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public byte Level
        {
            get => this.data[1];
            set => this.data[1] = value;
        }

        /// <summary>
        /// Gets or sets the display value.
        /// </summary>
        public float DisplayValue
        {
            get => BitConverter.ToSingle(this.data.Slice(4));
            set => BitConverter.GetBytes(value).CopyTo(this.data.Slice(4));
        }

        /// <summary>
        /// Gets or sets the display value of next level.
        /// </summary>
        public float DisplayValueOfNextLevel
        {
            get => BitConverter.ToSingle(this.data.Slice(8));
            set => BitConverter.GetBytes(value).CopyTo(this.data.Slice(8));
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct ServerMessage
    {
        /// <summary>
        /// Defines a type of a server message.
        /// </summary>
        public enum MessageType
        {
            /// <summary>
            /// The message is shown as centered golden message in the client.
            /// </summary>
            GoldenCenter = 0,

            /// <summary>
            /// The message is shown as a blue system message.
            /// </summary>
            BlueNormal = 1,

            /// <summary>
            /// The message is a guild notice, centered in green.
            /// </summary>
            GuildNotice = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ServerMessage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ServerMessage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x0D;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public ServerMessage.MessageType Type
        {
            get => (MessageType)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(4, this.data.Length - 4, System.Text.Encoding.UTF8);
            set => this.data.Slice(4).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerMessage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ServerMessage(Span<byte> packet) => new ServerMessage(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ServerMessage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ServerMessage packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 4;
    }


    /// <summary>
    /// Is sent by the server when: A player requested to join a guild. This message is sent then to the guild master.
    /// Causes reaction on client side: The guild master gets a message box with the request popping up.
    /// </summary>
    public readonly ref struct GuildJoinRequest
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildJoinRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildJoinRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildJoinRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildJoinRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x50;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the requester id.
        /// </summary>
        public ushort RequesterId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildJoinRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildJoinRequest(Span<byte> packet) => new GuildJoinRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildJoinRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildJoinRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a guild master responded to a request of a player to join his guild. This message is sent back to the requesting player.
    /// Causes reaction on client side: The requester gets a corresponding message showing.
    /// </summary>
    public readonly ref struct GuildJoinResponse
    {
        /// <summary>
        /// The result of the guild join request.
        /// </summary>
        public enum GuildJoinRequestResult
        {
            /// <summary>
            /// Refused by the guild master.
            /// </summary>
            Refused = 0,

            /// <summary>
            /// Accepted by the guild master.
            /// </summary>
            Accepted = 1,

            /// <summary>
            /// The guild is full.
            /// </summary>
            GuildFull = 2,

            /// <summary>
            /// The guild master is disconnected.
            /// </summary>
            Disconnected = 3,

            /// <summary>
            /// The requested player is not the guild master of its guild.
            /// </summary>
            NotTheGuildMaster = 4,

            /// <summary>
            /// The player already has a guild.
            /// </summary>
            AlreadyHaveGuild = 5,

            /// <summary>
            /// he guild master or the requesting player is busy, e.g. by another request or by an ongoing guild war.
            /// </summary>
            GuildMasterOrRequesterIsBusy = 6,

            /// <summary>
            /// The requesting player needs a minimum level of 6.
            /// </summary>
            MinimumLevel6 = 7,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildJoinResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildJoinResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildJoinResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildJoinResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x51;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public GuildJoinResponse.GuildJoinRequestResult Result
        {
            get => (GuildJoinRequestResult)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildJoinResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildJoinResponse(Span<byte> packet) => new GuildJoinResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildJoinResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildJoinResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a game client requested the list of players of his guild, which is usually the case when the player opens the guild dialog at the game client.
    /// Causes reaction on client side: The list of player is available at the client.
    /// </summary>
    public readonly ref struct GuildList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x52;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the is in guild.
        /// </summary>
        public bool IsInGuild
        {
            get => this.data.Slice(4).GetBoolean();
            set => this.data.Slice(4).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the guild member count.
        /// </summary>
        public byte GuildMemberCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the total score.
        /// </summary>
        public uint TotalScore
        {
            get => ReadUInt32LittleEndian(this.data.Slice(8));
            set => WriteUInt32LittleEndian(this.data.Slice(8), value);
        }

        /// <summary>
        /// Gets or sets the current score.
        /// </summary>
        public byte CurrentScore
        {
            get => this.data[12];
            set => this.data[12] = value;
        }

        /// <summary>
        /// Gets or sets the rival guild name.
        /// </summary>
        public string RivalGuildName
        {
            get => this.data.ExtractString(13, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(13, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets the <see cref="GuildMember"/> of the specified index.
        /// </summary>
        public GuildMember this[int index] => new GuildMember(this.data.Slice(24 + (index * GuildMember.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildList(Span<byte> packet) => new GuildList(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="GuildMember"/>.
        /// </summary>
        /// <param name="membersCount">The count of <see cref="GuildMember"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int membersCount) => membersCount * GuildMember.Length + 24;


    /// <summary>
    /// Contains the data of one guild member..
    /// </summary>
    public readonly ref struct GuildMember
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildMember"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildMember(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 13;

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(0, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the server id.
        /// </summary>
        public byte ServerId
        {
            get => this.data[10];
            set => this.data[10] = value;
        }

        /// <summary>
        /// Gets or sets the server id 2.
        /// </summary>
        public byte ServerId2
        {
            get => this.data[11];
            set => this.data[11] = value;
        }

        /// <summary>
        /// Gets or sets the role.
        /// </summary>
        public GuildMemberRole Role
        {
            get => (GuildMemberRole)this.data.Slice(12)[0];
            set => this.data.Slice(12)[0] = (byte)value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After a guild master sent a request to kick a player from its guild and the server processed this request.
    /// Causes reaction on client side: The client shows a message depending on the result.
    /// </summary>
    public readonly ref struct GuildKickResponse
    {
        /// <summary>
        /// The result of the guild kick request.
        /// </summary>
        public enum GuildKickSuccess
        {
            /// <summary>
            /// The kick request failed.
            /// </summary>
            Failed = 0,

            /// <summary>
            /// The kick request was successful.
            /// </summary>
            KickSucceeded = 1,

            /// <summary>
            /// The guild has been disbanded.
            /// </summary>
            GuildDisband = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildKickResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildKickResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildKickResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildKickResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x53;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public GuildKickResponse.GuildKickSuccess Result
        {
            get => (GuildKickSuccess)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildKickResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildKickResponse(Span<byte> packet) => new GuildKickResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildKickResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildKickResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a player started talking to the guild master NPC and the player is allowed to create a guild.
    /// Causes reaction on client side: The client shows the guild master dialog.
    /// </summary>
    public readonly ref struct ShowGuildMasterDialog
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ShowGuildMasterDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ShowGuildMasterDialog(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ShowGuildMasterDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ShowGuildMasterDialog(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x54;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 3;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ShowGuildMasterDialog"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ShowGuildMasterDialog(Span<byte> packet) => new ShowGuildMasterDialog(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ShowGuildMasterDialog"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ShowGuildMasterDialog packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a player started talking to the guild master NPC and the player proceeds to create a guild.
    /// Causes reaction on client side: The client shows the guild creation dialog.
    /// </summary>
    public readonly ref struct ShowGuildCreationDialog
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ShowGuildCreationDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ShowGuildCreationDialog(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ShowGuildCreationDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ShowGuildCreationDialog(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x55;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 3;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ShowGuildCreationDialog"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ShowGuildCreationDialog(Span<byte> packet) => new ShowGuildCreationDialog(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ShowGuildCreationDialog"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ShowGuildCreationDialog packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a player requested to create a guild at the guild master NPC.
    /// Causes reaction on client side: Depending on the result, a message is shown.
    /// </summary>
    public readonly ref struct GuildCreationResult
    {
        /// <summary>
        /// Defines a guild creation error.
        /// </summary>
        public enum GuildCreationErrorType
        {
            /// <summary>
            /// No error occured.
            /// </summary>
            None = 0,

            /// <summary>
            /// The requested guild name is already taken.
            /// </summary>
            GuildNameAlreadyTaken = 179,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildCreationResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildCreationResult(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildCreationResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildCreationResult(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x56;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the error.
        /// </summary>
        public GuildCreationResult.GuildCreationErrorType Error
        {
            get => (GuildCreationErrorType)this.data.Slice(4)[0];
            set => this.data.Slice(4)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildCreationResult"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildCreationResult(Span<byte> packet) => new GuildCreationResult(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildCreationResult"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildCreationResult packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A player left a guild. This message is sent to the player and all surrounding players.
    /// Causes reaction on client side: The player is not longer shown as a guild member.
    /// </summary>
    public readonly ref struct GuildMemberLeftGuild
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildMemberLeftGuild"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildMemberLeftGuild(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildMemberLeftGuild"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildMemberLeftGuild(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x5D;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(3));
            set => WriteUInt16BigEndian(this.data.Slice(3), value);
        }

        /// <summary>
        /// Gets or sets the is guild master.
        /// </summary>
        public bool IsGuildMaster
        {
            get => this.data.Slice(3).GetBoolean(7);
            set => this.data.Slice(3).SetBoolean(value, 7);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildMemberLeftGuild"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildMemberLeftGuild(Span<byte> packet) => new GuildMemberLeftGuild(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildMemberLeftGuild"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildMemberLeftGuild packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The server wants to visibly assign a player to a guild, e.g. when two players met each other and one of them is a guild member.
    /// Causes reaction on client side: The players which belong to the guild are shown as guild players. If the game client doesn't met a player of this guild yet, it will send another request to get the guild information.
    /// </summary>
    public readonly ref struct AssignCharacterToGuild
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AssignCharacterToGuild"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AssignCharacterToGuild(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AssignCharacterToGuild"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AssignCharacterToGuild(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x65;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the player count.
        /// </summary>
        public byte PlayerCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="GuildMemberRelation"/> of the specified index.
        /// </summary>
        public GuildMemberRelation this[int index] => new GuildMemberRelation(this.data.Slice(5 + (index * GuildMemberRelation.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AssignCharacterToGuild"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AssignCharacterToGuild(Span<byte> packet) => new AssignCharacterToGuild(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AssignCharacterToGuild"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AssignCharacterToGuild packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="GuildMemberRelation"/>.
        /// </summary>
        /// <param name="membersCount">The count of <see cref="GuildMemberRelation"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int membersCount) => membersCount * GuildMemberRelation.Length + 5;


    /// <summary>
    /// Relation between a guild and a member..
    /// </summary>
    public readonly ref struct GuildMemberRelation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildMemberRelation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildMemberRelation(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets or sets the guild id.
        /// </summary>
        public uint GuildId
        {
            get => ReadUInt32LittleEndian(this.data.Slice(0));
            set => WriteUInt32LittleEndian(this.data.Slice(0), value);
        }

        /// <summary>
        /// Gets or sets the role.
        /// </summary>
        public GuildMemberRole Role
        {
            get => (GuildMemberRole)this.data.Slice(4)[0];
            set => this.data.Slice(4)[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the is player appearing new.
        /// </summary>
        public bool IsPlayerAppearingNew
        {
            get => this.data.Slice(7).GetBoolean(7);
            set => this.data.Slice(7).SetBoolean(value, 7);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data.Slice(7));
            set => WriteUInt16BigEndian(this.data.Slice(7), value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: A game client requested the (public) info of a guild, e.g. when it met a player of previously unknown guild.
    /// Causes reaction on client side: The players which belong to the guild are shown as guild players.
    /// </summary>
    public readonly ref struct GuildInformation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildInformation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildInformation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x66;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 60;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the guild id.
        /// </summary>
        public uint GuildId
        {
            get => ReadUInt32LittleEndian(this.data.Slice(4));
            set => WriteUInt32LittleEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the guild type.
        /// </summary>
        public byte GuildType
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the alliance guild name.
        /// </summary>
        public string AllianceGuildName
        {
            get => this.data.ExtractString(9, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(9, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the guild name.
        /// </summary>
        public string GuildName
        {
            get => this.data.ExtractString(17, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(17, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the logo.
        /// </summary>
        public Span<byte> Logo
        {
            get => this.data.Slice(25, 32);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildInformation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildInformation(Span<byte> packet) => new GuildInformation(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildInformation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildInformation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to move money between the vault and inventory.
    /// Causes reaction on client side: The game client updates the money values of vault and inventory.
    /// </summary>
    public readonly ref struct VaultMoneyUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultMoneyUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public VaultMoneyUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultMoneyUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private VaultMoneyUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x81;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the vault money.
        /// </summary>
        public uint VaultMoney
        {
            get => ReadUInt32LittleEndian(this.data.Slice(4));
            set => WriteUInt32LittleEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the inventory money.
        /// </summary>
        public uint InventoryMoney
        {
            get => ReadUInt32LittleEndian(this.data.Slice(8));
            set => WriteUInt32LittleEndian(this.data.Slice(8), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="VaultMoneyUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator VaultMoneyUpdate(Span<byte> packet) => new VaultMoneyUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="VaultMoneyUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(VaultMoneyUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to close the vault, this confirmation is sent back to the client.
    /// Causes reaction on client side: The game client closes the vault dialog.
    /// </summary>
    public readonly ref struct VaultClosed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultClosed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public VaultClosed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultClosed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private VaultClosed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x82;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 3;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="VaultClosed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator VaultClosed(Span<byte> packet) => new VaultClosed(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="VaultClosed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(VaultClosed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to open the vault.
    /// Causes reaction on client side: The game client updates the UI to show the current vault protection state.
    /// </summary>
    public readonly ref struct VaultProtectionInformation
    {
        /// <summary>
        /// Defines the vault protection state.
        /// </summary>
        public enum VaultProtectionState
        {
            /// <summary>
            /// The vault is unprotected.
            /// </summary>
            Unprotected = 0,

            /// <summary>
            /// The vault is protected and locked. To move items or money, the player needs to unlock it.
            /// </summary>
            Locked = 1,

            /// <summary>
            /// The vault is protected and locked. The user-requested unlock failed by a wrong pin.
            /// </summary>
            UnlockFailedByWrongPin = 10,

            /// <summary>
            /// The vault is protected and locked and the player-requested pin setting failed because of the lock.
            /// </summary>
            SetPinFailedBecauseLock = 11,

            /// <summary>
            /// The vault is protected, but was unlocked by the player.
            /// </summary>
            Unlocked = 12,

            /// <summary>
            /// The vault is protected and the player-requested pin removal failed by using the wrong password.
            /// </summary>
            RemovePinFailedByWrongPassword = 13,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultProtectionInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public VaultProtectionInformation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultProtectionInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private VaultProtectionInformation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x83;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the protection state.
        /// </summary>
        public VaultProtectionInformation.VaultProtectionState ProtectionState
        {
            get => (VaultProtectionState)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="VaultProtectionInformation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator VaultProtectionInformation(Span<byte> packet) => new VaultProtectionInformation(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="VaultProtectionInformation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(VaultProtectionInformation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After entering the game with a character.
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct MessengerInitialization
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MessengerInitialization"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MessengerInitialization(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessengerInitialization"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MessengerInitialization(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC0;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new C2Header(this.data);

        /// <summary>
        /// Gets or sets the letter count.
        /// </summary>
        public byte LetterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the maximum letter count.
        /// </summary>
        public byte MaximumLetterCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the friend count.
        /// </summary>
        public byte FriendCount
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets the <see cref="Friend"/> of the specified index.
        /// </summary>
        public Friend this[int index] => new Friend(this.data.Slice(7 + (index * Friend.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MessengerInitialization"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MessengerInitialization(Span<byte> packet) => new MessengerInitialization(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MessengerInitialization"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MessengerInitialization packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="Friend"/>.
        /// </summary>
        /// <param name="friendsCount">The count of <see cref="Friend"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int friendsCount) => friendsCount * Friend.Length + 7;


    /// <summary>
    /// The structure which contains the friend name and online state..
    /// </summary>
    public readonly ref struct Friend
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="Friend"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public Friend(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 11;

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(0, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the server id on which the player currently is online. 0xFF means offline.
        /// </summary>
        public byte ServerId
        {
            get => this.data[1];
            set => this.data[1] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After a friend has been added to the friend list.
    /// Causes reaction on client side: The friend appears in the friend list.
    /// </summary>
    public readonly ref struct FriendAdded
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendAdded(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendAdded(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.ServerId = 0xFF;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 15;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the friend name.
        /// </summary>
        public string FriendName
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the server id on which the player currently is online. 0xFF means offline.
        /// </summary>
        public byte ServerId
        {
            get => this.data[14];
            set => this.data[14] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendAdded"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendAdded(Span<byte> packet) => new FriendAdded(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendAdded"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendAdded packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a player has requested to add another player as friend. This other player gets this message.
    /// Causes reaction on client side: The friend request appears on the user interface.
    /// </summary>
    public readonly ref struct FriendRequest
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC2;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 13;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the requester.
        /// </summary>
        public string Requester
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendRequest(Span<byte> packet) => new FriendRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a friend has been removed from the friend list.
    /// Causes reaction on client side: The friend is removed from the friend list.
    /// </summary>
    public readonly ref struct FriendDeleted
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendDeleted"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendDeleted(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendDeleted"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendDeleted(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 14;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the friend name.
        /// </summary>
        public string FriendName
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendDeleted"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendDeleted(Span<byte> packet) => new FriendDeleted(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendDeleted"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendDeleted packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a friend has been added to the friend list.
    /// Causes reaction on client side: The friend appears in the friend list.
    /// </summary>
    public readonly ref struct FriendOnlineStateUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendOnlineStateUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendOnlineStateUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendOnlineStateUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendOnlineStateUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC4;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 14;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the friend name.
        /// </summary>
        public string FriendName
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the server id on which the player currently is online. 0xFF means offline.
        /// </summary>
        public byte ServerId
        {
            get => this.data[13];
            set => this.data[13] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendOnlineStateUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendOnlineStateUpdate(Span<byte> packet) => new FriendOnlineStateUpdate(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendOnlineStateUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendOnlineStateUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to send a letter to another player.
    /// Causes reaction on client side: Depending on the result, the letter send dialog closes or an error message appears.
    /// </summary>
    public readonly ref struct LetterSendResponse
    {
        /// <summary>
        /// Describes the result of a letter send request.
        /// </summary>
        public enum LetterSendRequestResult
        {
            /// <summary>
            /// The letter wasn't sent because there was an internal problem. The user should try again.
            /// </summary>
            TryAgain = 0,

            /// <summary>
            /// The letter was sent.
            /// </summary>
            Success = 1,

            /// <summary>
            /// The mailbox of the recipient is full.
            /// </summary>
            MailboxFull = 2,

            /// <summary>
            /// The receiver does not exist.
            /// </summary>
            ReceiverNotExists = 3,

            /// <summary>
            /// A letter can't be sent to yourself.
            /// </summary>
            CantSendToYourself = 4,

            /// <summary>
            /// The sender doesn't have enough money to send a letter.
            /// </summary>
            NotEnoughMoney = 7,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LetterSendResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LetterSendResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LetterSendResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LetterSendResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC5;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the letter id.
        /// </summary>
        public uint LetterId
        {
            get => ReadUInt32LittleEndian(this.data.Slice(4));
            set => WriteUInt32LittleEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public LetterSendResponse.LetterSendRequestResult Result
        {
            get => (LetterSendRequestResult)this.data.Slice(3)[0];
            set => this.data.Slice(3)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LetterSendResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LetterSendResponse(Span<byte> packet) => new LetterSendResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LetterSendResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LetterSendResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a letter has been received or after the player entered the game with a character.
    /// Causes reaction on client side: The letter appears in the letter list.
    /// </summary>
    public readonly ref struct AddLetter
    {
        /// <summary>
        /// Describes the state of a letter.
        /// </summary>
        public enum LetterState
        {
            /// <summary>
            /// The letter was read before.
            /// </summary>
            Read = 0,

            /// <summary>
            /// The letter wasn't read yet.
            /// </summary>
            Unread = 1,

            /// <summary>
            /// The letter is new (= was just sent by the sender) and wasn't read yet. It will notify the user about the received letter.
            /// </summary>
            New = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddLetter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddLetter(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddLetter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddLetter(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC6;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 79;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the letter index.
        /// </summary>
        public ushort LetterIndex
        {
            get => ReadUInt16LittleEndian(this.data.Slice(4));
            set => WriteUInt16LittleEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the sender name.
        /// </summary>
        public string SenderName
        {
            get => this.data.ExtractString(6, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the timestamp.
        /// </summary>
        public string Timestamp
        {
            get => this.data.ExtractString(16, 30, System.Text.Encoding.UTF8);
            set => this.data.Slice(16, 30).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the subject.
        /// </summary>
        public string Subject
        {
            get => this.data.ExtractString(46, 32, System.Text.Encoding.UTF8);
            set => this.data.Slice(46, 32).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the state.
        /// </summary>
        public AddLetter.LetterState State
        {
            get => (LetterState)this.data.Slice(78)[0];
            set => this.data.Slice(78)[0] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddLetter"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddLetter(Span<byte> packet) => new AddLetter(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddLetter"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddLetter packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to read a letter.
    /// Causes reaction on client side: The letter is opened in a new dialog.
    /// </summary>
    public readonly ref struct OpenLetter
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="OpenLetter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public OpenLetter(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="OpenLetter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private OpenLetter(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC4;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C4Header Header => new C4Header(this.data);

        /// <summary>
        /// Gets or sets the letter index.
        /// </summary>
        public ushort LetterIndex
        {
            get => ReadUInt16LittleEndian(this.data.Slice(4));
            set => WriteUInt16LittleEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Gets or sets the message size.
        /// </summary>
        public ushort MessageSize
        {
            get => ReadUInt16LittleEndian(this.data.Slice(6));
            set => WriteUInt16LittleEndian(this.data.Slice(6), value);
        }

        /// <summary>
        /// Gets or sets the sender appearance.
        /// </summary>
        public Span<byte> SenderAppearance
        {
            get => this.data.Slice(8, 18);
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[26];
            set => this.data[26] = value;
        }

        /// <summary>
        /// Gets or sets the animation.
        /// </summary>
        public byte Animation
        {
            get => this.data[27];
            set => this.data[27] = value;
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(28, this.data.Length - 28, System.Text.Encoding.UTF8);
            set => this.data.Slice(28).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="OpenLetter"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator OpenLetter(Span<byte> packet) => new OpenLetter(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="OpenLetter"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(OpenLetter packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 28;
    }


    /// <summary>
    /// Is sent by the server when: After a letter has been deleted by the request of the player.
    /// Causes reaction on client side: The letter is removed from the letter list.
    /// </summary>
    public readonly ref struct RemoveLetter
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="RemoveLetter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public RemoveLetter(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RemoveLetter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private RemoveLetter(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                this.RequestSuccessful = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC8;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the request successful.
        /// </summary>
        public bool RequestSuccessful
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the letter index.
        /// </summary>
        public ushort LetterIndex
        {
            get => ReadUInt16LittleEndian(this.data.Slice(4));
            set => WriteUInt16LittleEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="RemoveLetter"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator RemoveLetter(Span<byte> packet) => new RemoveLetter(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="RemoveLetter"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(RemoveLetter packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player is invited to join a chat room on the chat server.
    /// Causes reaction on client side: The game client connects to the chat server and joins the chat room with the specified authentication data.
    /// </summary>
    public readonly ref struct ChatRoomConnectionInfo
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatRoomConnectionInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ChatRoomConnectionInfo(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatRoomConnectionInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ChatRoomConnectionInfo(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                this.Type = 1;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xCA;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 36;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the chat server ip.
        /// </summary>
        public string ChatServerIp
        {
            get => this.data.ExtractString(3, 15, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 15).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the chat room id.
        /// </summary>
        public ushort ChatRoomId
        {
            get => ReadUInt16LittleEndian(this.data.Slice(18));
            set => WriteUInt16LittleEndian(this.data.Slice(18), value);
        }

        /// <summary>
        /// Gets or sets the authentication token.
        /// </summary>
        public uint AuthenticationToken
        {
            get => ReadUInt32LittleEndian(this.data.Slice(20));
            set => WriteUInt32LittleEndian(this.data.Slice(20), value);
        }

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public byte Type
        {
            get => this.data[24];
            set => this.data[24] = value;
        }

        /// <summary>
        /// Gets or sets the friend name.
        /// </summary>
        public string FriendName
        {
            get => this.data.ExtractString(25, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(25, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(35).GetBoolean();
            set => this.data.Slice(35).SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ChatRoomConnectionInfo"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ChatRoomConnectionInfo(Span<byte> packet) => new ChatRoomConnectionInfo(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ChatRoomConnectionInfo"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ChatRoomConnectionInfo packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player requested to add another player to his friend list and the server processed this request.
    /// Causes reaction on client side: The game client knows if the invitation could be sent to the other player.
    /// </summary>
    public readonly ref struct FriendInvitationResult
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendInvitationResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendInvitationResult(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendInvitationResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendInvitationResult(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xCB;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new C3Header(this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data.Slice(3).GetBoolean();
            set => this.data.Slice(3).SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the request id.
        /// </summary>
        public uint RequestId
        {
            get => ReadUInt32BigEndian(this.data.Slice(4));
            set => WriteUInt32BigEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendInvitationResult"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendInvitationResult(Span<byte> packet) => new FriendInvitationResult(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendInvitationResult"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendInvitationResult packet) => packet.data; 
    }
        /// <summary>
        /// Defines the role of a guild member.
        /// </summary>
        public enum GuildMemberRole
        {
            /// <summary>
            /// The member is a normal member without special rights.
            /// </summary>
            NormalMember = 0,

            /// <summary>
            /// The member is a battle master.
            /// </summary>
            BattleMaster = 32,

            /// <summary>
            /// The member is the guild master.
            /// </summary>
            GuildMaster = 128,

            /// <summary>
            /// The character is not a member, therefore the role is undefined.
            /// </summary>
            Undefined = 255,
        }

        /// <summary>
        /// The status of a character.
        /// </summary>
        public enum CharacterStatus
        {
            /// <summary>
            /// The state of the character is normal.
            /// </summary>
            Normal = 0,

            /// <summary>
            /// The character is banned from the game.
            /// </summary>
            Banned = 1,

            /// <summary>
            /// The character is a game master.
            /// </summary>
            GameMaster = 32,
        }

}