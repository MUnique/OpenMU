// <copyright file="ServerToClientPackets.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Network.Packets.ServerToClient
{
    using System;
    using static System.Buffers.Binary.BinaryPrimitives;

    /// <summary>
    /// The structure for a stored item, e.g. in the inventory or vault..
    /// </summary>
    public readonly ref struct StoredItem
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="StoredItem"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public StoredItem(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets or sets the item slot.
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(1);
        }

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 1;
    }


    /// <summary>
    /// Data of an item in a player shop..
    /// </summary>
    public readonly ref struct PlayerShopItem
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItem"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopItem(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 20;

        /// <summary>
        /// Gets or sets the item slot.
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(1, 12);
        }

        /// <summary>
        /// Gets or sets the price.
        /// </summary>
        public uint Price
        {
            get => ReadUInt32LittleEndian(this.data[16..]);
            set => WriteUInt32LittleEndian(this.data[16..], value);
        }
    }


    /// <summary>
    /// Defines the information which identifies a quest..
    /// </summary>
    public readonly ref struct QuestIdentification
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestIdentification"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public QuestIdentification(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets or sets the number.
        /// </summary>
        public ushort Number
        {
            get => ReadUInt16LittleEndian(this.data);
            set => WriteUInt16LittleEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the group.
        /// </summary>
        public ushort Group
        {
            get => ReadUInt16LittleEndian(this.data[2..]);
            set => WriteUInt16LittleEndian(this.data[2..], value);
        }
    }


    /// <summary>
    /// Defines a condition which must be fulfilled to complete the quest..
    /// </summary>
    public readonly ref struct QuestCondition
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestCondition"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public QuestCondition(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 26;

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public ConditionType Type
        {
            get => (ConditionType)this.data[0];
            set => this.data[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets depending on the condition type, this field contains the identifier of the required thing, e.g. Monster Number, Item Id, Level.
        /// </summary>
        public ushort RequirementId
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the required count.
        /// </summary>
        public uint RequiredCount
        {
            get => ReadUInt32LittleEndian(this.data[6..]);
            set => WriteUInt32LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets the current count.
        /// </summary>
        public uint CurrentCount
        {
            get => ReadUInt32LittleEndian(this.data[10..]);
            set => WriteUInt32LittleEndian(this.data[10..], value);
        }

        /// <summary>
        /// Gets or sets if the condition type is 'Item', this field contains the item data, excluding the item id. The item id can be found in the RequirementId field.
        /// </summary>
        public Span<byte> RequiredItemData
        {
            get => this.data.Slice(14, 12);
        }
    }


    /// <summary>
    /// Defines a reward which is given when the quest is completed..
    /// </summary>
    public readonly ref struct QuestReward
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestReward"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public QuestReward(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 22;

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public RewardType Type
        {
            get => (RewardType)this.data[0];
            set => this.data[0] = (byte)value;
        }

        /// <summary>
        /// Gets or sets depending on the condition type, this field contains the identifier of the required thing, e.g. Monster Number, Item Id, Level.
        /// </summary>
        public ushort RewardId
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the reward count.
        /// </summary>
        public uint RewardCount
        {
            get => ReadUInt32LittleEndian(this.data[6..]);
            set => WriteUInt32LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets if the reward type is 'Item', this field contains its item data.
        /// </summary>
        public Span<byte> RewardedItemData
        {
            get => this.data.Slice(10, 12);
        }
    }


    /// <summary>
    /// Is sent by the server when: After a game client has connected to the game.
    /// Causes reaction on client side: It shows the login dialog.
    /// </summary>
    public readonly ref struct GameServerEntered
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GameServerEntered"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GameServerEntered(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GameServerEntered"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GameServerEntered(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Success = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[4..].GetBoolean();
            set => this.data[4..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[5..]);
            set => WriteUInt16BigEndian(this.data[5..], value);
        }

        /// <summary>
        /// Gets or sets the version string.
        /// </summary>
        public string VersionString
        {
            get => this.data.ExtractString(7, 5, System.Text.Encoding.UTF8);
            set => this.data.Slice(7, 5).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the version.
        /// </summary>
        public Span<byte> Version
        {
            get => this.data.Slice(7, 5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GameServerEntered"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GameServerEntered(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GameServerEntered"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GameServerEntered packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A magic effect was added or removed to the own or another player.
    /// Causes reaction on client side: The user interface updates itself. If it's the effect of the own player, it's shown as icon at the top of the interface.
    /// </summary>
    public readonly ref struct MagicEffectStatus
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MagicEffectStatus"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MagicEffectStatus(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MagicEffectStatus"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MagicEffectStatus(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x07;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the is active.
        /// </summary>
        public bool IsActive
        {
            get => this.data[3..].GetBoolean();
            set => this.data[3..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the effect id.
        /// </summary>
        public byte EffectId
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MagicEffectStatus"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MagicEffectStatus(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MagicEffectStatus"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MagicEffectStatus packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The weather on the current map has been changed or the player entered the map.
    /// Causes reaction on client side: The game client updates the weather effects.
    /// </summary>
    public readonly ref struct WeatherStatusUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="WeatherStatusUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public WeatherStatusUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="WeatherStatusUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private WeatherStatusUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x0F;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets a random value between 0 and 2 (inclusive).
        /// </summary>
        public byte Weather
        {
            get => this.data[3..].GetByteValue(4, 4);
            set => this.data[3..].SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets a random value between 0 and 9 (inclusive).
        /// </summary>
        public byte Variation
        {
            get => this.data[3..].GetByteValue(4, 0);
            set => this.data[3..].SetByteValue(value, 4, 0);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="WeatherStatusUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator WeatherStatusUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="WeatherStatusUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(WeatherStatusUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: One or more character got into the observed scope of the player.
    /// Causes reaction on client side: The client adds the character to the shown map.
    /// </summary>
    public readonly ref partial struct AddCharactersToScope
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddCharactersToScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddCharactersToScope(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddCharactersToScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddCharactersToScope(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the character count.
        /// </summary>
        public byte CharacterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddCharactersToScope"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddCharactersToScope(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddCharactersToScope"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddCharactersToScope packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/> and it's size.
        /// </summary>
        /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        /// <param name="structLength">The length of <see cref="CharacterData"/> from which the size will be calculated.</param>
          public static int GetRequiredSize(int charactersCount, int structLength) => charactersCount * structLength + 5;


    /// <summary>
    /// Contains the data of an NPC..
    /// </summary>
    public readonly ref struct CharacterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the current position x.
        /// </summary>
        public byte CurrentPositionX
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the current position y.
        /// </summary>
        public byte CurrentPositionY
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the appearance.
        /// </summary>
        public Span<byte> Appearance
        {
            get => this.data.Slice(4, 18);
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(22, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(22, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the target position x.
        /// </summary>
        public byte TargetPositionX
        {
            get => this.data[32];
            set => this.data[32] = value;
        }

        /// <summary>
        /// Gets or sets the target position y.
        /// </summary>
        public byte TargetPositionY
        {
            get => this.data[33];
            set => this.data[33] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[34..].GetByteValue(4, 4);
            set => this.data[34..].SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets the hero state.
        /// </summary>
        public CharacterHeroState HeroState
        {
            get => (CharacterHeroState)this.data[34..].GetByteValue(4, 0);
            set => this.data[34..].SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets defines the number of effects which would be sent after this field.
        /// </summary>
        public byte EffectCount
        {
            get => this.data[35];
            set => this.data[35] = value;
        }

        /// <summary>
        /// Gets the <see cref="EffectId"/> of the specified index.
        /// </summary>
        public EffectId this[int index] => new (this.data[(36 + index * EffectId.Length)..]);

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="EffectId"/>.
        /// </summary>
        /// <param name="effectsCount">The count of <see cref="EffectId"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int effectsCount) => effectsCount * EffectId.Length + 36;
    }


    /// <summary>
    /// Contains the id of a magic effect..
    /// </summary>
    public readonly ref struct EffectId
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="EffectId"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public EffectId(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 1;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public byte Id
        {
            get => this.data[0];
            set => this.data[0] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: One or more character got into the observed scope of the player.
    /// Causes reaction on client side: The client adds the character to the shown map.
    /// </summary>
    public readonly ref struct AddCharactersToScope075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddCharactersToScope075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddCharactersToScope075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddCharactersToScope075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddCharactersToScope075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the character count.
        /// </summary>
        public byte CharacterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="CharacterData"/> of the specified index.
        /// </summary>
        public CharacterData this[int index] => new (this.data[(5 + index * CharacterData.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddCharactersToScope075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddCharactersToScope075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddCharactersToScope075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddCharactersToScope075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
        /// </summary>
        /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 5;


    /// <summary>
    /// Contains the data of an NPC..
    /// </summary>
    public readonly ref struct CharacterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 27;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the current position x.
        /// </summary>
        public byte CurrentPositionX
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the current position y.
        /// </summary>
        public byte CurrentPositionY
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the appearance.
        /// </summary>
        public Span<byte> Appearance
        {
            get => this.data.Slice(4, 9);
        }

        /// <summary>
        /// Gets or sets the is poisoned.
        /// </summary>
        public bool IsPoisoned
        {
            get => this.data[13..].GetBoolean(0);
            set => this.data[13..].SetBoolean(value, 0);
        }

        /// <summary>
        /// Gets or sets the is iced.
        /// </summary>
        public bool IsIced
        {
            get => this.data[13..].GetBoolean(1);
            set => this.data[13..].SetBoolean(value, 1);
        }

        /// <summary>
        /// Gets or sets the is damage buffed.
        /// </summary>
        public bool IsDamageBuffed
        {
            get => this.data[13..].GetBoolean(2);
            set => this.data[13..].SetBoolean(value, 2);
        }

        /// <summary>
        /// Gets or sets the is defense buffed.
        /// </summary>
        public bool IsDefenseBuffed
        {
            get => this.data[13..].GetBoolean(3);
            set => this.data[13..].SetBoolean(value, 3);
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(14, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(14, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the target position x.
        /// </summary>
        public byte TargetPositionX
        {
            get => this.data[24];
            set => this.data[24] = value;
        }

        /// <summary>
        /// Gets or sets the target position y.
        /// </summary>
        public byte TargetPositionY
        {
            get => this.data[25];
            set => this.data[25] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[26..].GetByteValue(4, 4);
            set => this.data[26..].SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets the hero state.
        /// </summary>
        public CharacterHeroState HeroState
        {
            get => (CharacterHeroState)this.data[26..].GetByteValue(4, 0);
            set => this.data[26..].SetByteValue((byte)value, 4, 0);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: One or more NPCs got into the observed scope of the player.
    /// Causes reaction on client side: The client adds the NPCs to the shown map.
    /// </summary>
    public readonly ref struct AddNpcsToScope
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddNpcsToScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddNpcsToScope(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddNpcsToScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddNpcsToScope(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x13;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the npc count.
        /// </summary>
        public byte NpcCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="NpcData"/> of the specified index.
        /// </summary>
        public NpcData this[int index] => new (this.data[(5 + index * NpcData.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddNpcsToScope"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddNpcsToScope(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddNpcsToScope"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddNpcsToScope packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="NpcData"/>.
        /// </summary>
        /// <param name="nPCsCount">The count of <see cref="NpcData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int nPCsCount) => nPCsCount * NpcData.Length + 5;


    /// <summary>
    /// Contains the data of an NPC..
    /// </summary>
    public readonly ref struct NpcData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public NpcData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the type number.
        /// </summary>
        public ushort TypeNumber
        {
            get => ReadUInt16BigEndian(this.data[2..]);
            set => WriteUInt16BigEndian(this.data[2..], value);
        }

        /// <summary>
        /// Gets or sets the current position x.
        /// </summary>
        public byte CurrentPositionX
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the current position y.
        /// </summary>
        public byte CurrentPositionY
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the target position x.
        /// </summary>
        public byte TargetPositionX
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the target position y.
        /// </summary>
        public byte TargetPositionY
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[8..].GetByteValue(4, 4);
            set => this.data[8..].SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets defines the number of effects which would be sent after this field. This is currently not supported.
        /// </summary>
        public byte EffectCount
        {
            get => this.data[9];
            set => this.data[9] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: One or more NPCs got into the observed scope of the player.
    /// Causes reaction on client side: The client adds the NPCs to the shown map.
    /// </summary>
    public readonly ref struct AddNpcsToScope075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddNpcsToScope075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddNpcsToScope075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddNpcsToScope075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddNpcsToScope075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x13;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the npc count.
        /// </summary>
        public byte NpcCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="NpcData"/> of the specified index.
        /// </summary>
        public NpcData this[int index] => new (this.data[(5 + index * NpcData.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddNpcsToScope075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddNpcsToScope075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddNpcsToScope075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddNpcsToScope075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="NpcData"/>.
        /// </summary>
        /// <param name="nPCsCount">The count of <see cref="NpcData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int nPCsCount) => nPCsCount * NpcData.Length + 5;


    /// <summary>
    /// Contains the data of an NPC..
    /// </summary>
    public readonly ref struct NpcData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public NpcData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the type number.
        /// </summary>
        public byte TypeNumber
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the is poisoned.
        /// </summary>
        public bool IsPoisoned
        {
            get => this.data[3..].GetBoolean(0);
            set => this.data[3..].SetBoolean(value, 0);
        }

        /// <summary>
        /// Gets or sets the is iced.
        /// </summary>
        public bool IsIced
        {
            get => this.data[3..].GetBoolean(1);
            set => this.data[3..].SetBoolean(value, 1);
        }

        /// <summary>
        /// Gets or sets the is damage buffed.
        /// </summary>
        public bool IsDamageBuffed
        {
            get => this.data[3..].GetBoolean(2);
            set => this.data[3..].SetBoolean(value, 2);
        }

        /// <summary>
        /// Gets or sets the is defense buffed.
        /// </summary>
        public bool IsDefenseBuffed
        {
            get => this.data[3..].GetBoolean(3);
            set => this.data[3..].SetBoolean(value, 3);
        }

        /// <summary>
        /// Gets or sets the current position x.
        /// </summary>
        public byte CurrentPositionX
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the current position y.
        /// </summary>
        public byte CurrentPositionY
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the target position x.
        /// </summary>
        public byte TargetPositionX
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the target position y.
        /// </summary>
        public byte TargetPositionY
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[8..].GetByteValue(4, 4);
            set => this.data[8..].SetByteValue(value, 4, 4);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: One or more summoned monsters got into the observed scope of the player.
    /// Causes reaction on client side: The client adds the monsters to the shown map.
    /// </summary>
    public readonly ref partial struct AddSummonedMonstersToScope
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddSummonedMonstersToScope(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddSummonedMonstersToScope(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x1F;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the monster count.
        /// </summary>
        public byte MonsterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddSummonedMonstersToScope"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddSummonedMonstersToScope(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddSummonedMonstersToScope"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddSummonedMonstersToScope packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="SummonedMonsterData"/> and it's size.
        /// </summary>
        /// <param name="summonedMonstersCount">The count of <see cref="SummonedMonsterData"/> from which the size will be calculated.</param>
        /// <param name="structLength">The length of <see cref="SummonedMonsterData"/> from which the size will be calculated.</param>
          public static int GetRequiredSize(int summonedMonstersCount, int structLength) => summonedMonstersCount * structLength + 5;


    /// <summary>
    /// Contains the data of an NPC..
    /// </summary>
    public readonly ref struct SummonedMonsterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SummonedMonsterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SummonedMonsterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the type number.
        /// </summary>
        public ushort TypeNumber
        {
            get => ReadUInt16BigEndian(this.data[2..]);
            set => WriteUInt16BigEndian(this.data[2..], value);
        }

        /// <summary>
        /// Gets or sets the current position x.
        /// </summary>
        public byte CurrentPositionX
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the current position y.
        /// </summary>
        public byte CurrentPositionY
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the target position x.
        /// </summary>
        public byte TargetPositionX
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the target position y.
        /// </summary>
        public byte TargetPositionY
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[8..].GetByteValue(4, 4);
            set => this.data[8..].SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets the owner character name.
        /// </summary>
        public string OwnerCharacterName
        {
            get => this.data.ExtractString(9, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(9, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets defines the number of effects which would be sent after this field. This is currently not supported.
        /// </summary>
        public byte EffectCount
        {
            get => this.data[19];
            set => this.data[19] = value;
        }

        /// <summary>
        /// Gets the <see cref="EffectId"/> of the specified index.
        /// </summary>
        public EffectId this[int index] => new (this.data[(20 + index * EffectId.Length)..]);

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="EffectId"/>.
        /// </summary>
        /// <param name="effectsCount">The count of <see cref="EffectId"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int effectsCount) => effectsCount * EffectId.Length + 20;
    }


    /// <summary>
    /// Contains the id of a magic effect..
    /// </summary>
    public readonly ref struct EffectId
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="EffectId"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public EffectId(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 1;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public byte Id
        {
            get => this.data[0];
            set => this.data[0] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: One or more summoned monsters got into the observed scope of the player.
    /// Causes reaction on client side: The client adds the monsters to the shown map.
    /// </summary>
    public readonly ref struct AddSummonedMonstersToScope075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddSummonedMonstersToScope075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddSummonedMonstersToScope075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x1F;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the monster count.
        /// </summary>
        public byte MonsterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="SummonedMonsterData"/> of the specified index.
        /// </summary>
        public SummonedMonsterData this[int index] => new (this.data[(5 + index * SummonedMonsterData.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddSummonedMonstersToScope075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddSummonedMonstersToScope075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddSummonedMonstersToScope075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddSummonedMonstersToScope075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="SummonedMonsterData"/>.
        /// </summary>
        /// <param name="summonedMonstersCount">The count of <see cref="SummonedMonsterData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int summonedMonstersCount) => summonedMonstersCount * SummonedMonsterData.Length + 5;


    /// <summary>
    /// Contains the data of an NPC..
    /// </summary>
    public readonly ref struct SummonedMonsterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SummonedMonsterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SummonedMonsterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 19;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the type number.
        /// </summary>
        public byte TypeNumber
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the is poisoned.
        /// </summary>
        public bool IsPoisoned
        {
            get => this.data[3..].GetBoolean(0);
            set => this.data[3..].SetBoolean(value, 0);
        }

        /// <summary>
        /// Gets or sets the is iced.
        /// </summary>
        public bool IsIced
        {
            get => this.data[3..].GetBoolean(1);
            set => this.data[3..].SetBoolean(value, 1);
        }

        /// <summary>
        /// Gets or sets the is damage buffed.
        /// </summary>
        public bool IsDamageBuffed
        {
            get => this.data[3..].GetBoolean(2);
            set => this.data[3..].SetBoolean(value, 2);
        }

        /// <summary>
        /// Gets or sets the is defense buffed.
        /// </summary>
        public bool IsDefenseBuffed
        {
            get => this.data[3..].GetBoolean(3);
            set => this.data[3..].SetBoolean(value, 3);
        }

        /// <summary>
        /// Gets or sets the current position x.
        /// </summary>
        public byte CurrentPositionX
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the current position y.
        /// </summary>
        public byte CurrentPositionY
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the target position x.
        /// </summary>
        public byte TargetPositionX
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the target position y.
        /// </summary>
        public byte TargetPositionY
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[8..].GetByteValue(4, 4);
            set => this.data[8..].SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets the owner character name.
        /// </summary>
        public string OwnerCharacterName
        {
            get => this.data.ExtractString(9, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(9, 10).WriteString(value, System.Text.Encoding.UTF8);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: One or more objects (player, npc, etc.) on the map got out of scope, e.g. when the own player moved away from it/them or the object itself moved.
    /// Causes reaction on client side: The game client removes the objects from the game map.
    /// </summary>
    public readonly ref struct MapObjectOutOfScope
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MapObjectOutOfScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MapObjectOutOfScope(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MapObjectOutOfScope"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MapObjectOutOfScope(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x14;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the object count.
        /// </summary>
        public byte ObjectCount
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets the <see cref="ObjectId"/> of the specified index.
        /// </summary>
        public ObjectId this[int index] => new (this.data[(4 + index * ObjectId.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MapObjectOutOfScope"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MapObjectOutOfScope(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MapObjectOutOfScope"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MapObjectOutOfScope packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="ObjectId"/>.
        /// </summary>
        /// <param name="objectsCount">The count of <see cref="ObjectId"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int objectsCount) => objectsCount * ObjectId.Length + 4;


    /// <summary>
    /// Contains the id of a object..
    /// </summary>
    public readonly ref struct ObjectId
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectId"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectId(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: An observed object was killed.
    /// Causes reaction on client side: The object is shown as dead.
    /// </summary>
    public readonly ref struct ObjectGotKilled
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectGotKilled"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectGotKilled(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectGotKilled"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectGotKilled(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x17;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the killed id.
        /// </summary>
        public ushort KilledId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public ushort SkillId
        {
            get => ReadUInt16BigEndian(this.data[5..]);
            set => WriteUInt16BigEndian(this.data[5..], value);
        }

        /// <summary>
        /// Gets or sets the killer id.
        /// </summary>
        public ushort KillerId
        {
            get => ReadUInt16BigEndian(this.data[7..]);
            set => WriteUInt16BigEndian(this.data[7..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectGotKilled"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectGotKilled(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectGotKilled"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectGotKilled packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An object performs an animation.
    /// Causes reaction on client side: The animation is shown for the specified object.
    /// </summary>
    public readonly ref struct ObjectAnimation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectAnimation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectAnimation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectAnimation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectAnimation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x18;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the object id.
        /// </summary>
        public ushort ObjectId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the direction.
        /// </summary>
        public byte Direction
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the animation.
        /// </summary>
        public byte Animation
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => ReadUInt16BigEndian(this.data[7..]);
            set => WriteUInt16BigEndian(this.data[7..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectAnimation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectAnimation(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectAnimation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectAnimation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An object performs a skill which has effect on an area.
    /// Causes reaction on client side: The animation is shown on the user interface.
    /// </summary>
    public readonly ref struct AreaSkillAnimation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AreaSkillAnimation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AreaSkillAnimation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AreaSkillAnimation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AreaSkillAnimation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x1E;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public ushort SkillId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[5..]);
            set => WriteUInt16BigEndian(this.data[5..], value);
        }

        /// <summary>
        /// Gets or sets the point x.
        /// </summary>
        public byte PointX
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the point y.
        /// </summary>
        public byte PointY
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[9];
            set => this.data[9] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkillAnimation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AreaSkillAnimation(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AreaSkillAnimation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AreaSkillAnimation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An object performs a skill which is directly targeted to another object.
    /// Causes reaction on client side: The animation is shown on the user interface.
    /// </summary>
    public readonly ref struct SkillAnimation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAnimation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillAnimation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAnimation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillAnimation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x19;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public ushort SkillId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[5..]);
            set => WriteUInt16BigEndian(this.data[5..], value);
        }

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => ReadUInt16BigEndian(this.data[7..]);
            set => WriteUInt16BigEndian(this.data[7..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAnimation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillAnimation(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillAnimation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillAnimation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An object performs a skill which has effect on an area.
    /// Causes reaction on client side: The animation is shown on the user interface.
    /// </summary>
    public readonly ref struct AreaSkillAnimation075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AreaSkillAnimation075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AreaSkillAnimation075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AreaSkillAnimation075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AreaSkillAnimation075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x1E;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public byte SkillId
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the point x.
        /// </summary>
        public byte PointX
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the point y.
        /// </summary>
        public byte PointY
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AreaSkillAnimation075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AreaSkillAnimation075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AreaSkillAnimation075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AreaSkillAnimation075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An object performs a skill which is directly targeted to another object.
    /// Causes reaction on client side: The animation is shown on the user interface.
    /// </summary>
    public readonly ref struct SkillAnimation075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAnimation075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillAnimation075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAnimation075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillAnimation075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x19;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public byte SkillId
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => ReadUInt16BigEndian(this.data[6..]);
            set => WriteUInt16BigEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets the effect applied.
        /// </summary>
        public bool EffectApplied
        {
            get => this.data[6..].GetBoolean(7);
            set => this.data[6..].SetBoolean(value, 7);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAnimation075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillAnimation075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillAnimation075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillAnimation075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A player cancelled a specific magic effect of a skill (Infinity Arrow, Wizardry Enhance), or an effect was removed due a timeout (Ice, Poison) or antidote.
    /// Causes reaction on client side: The effect is removed from the target object.
    /// </summary>
    public readonly ref struct MagicEffectCancelled
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MagicEffectCancelled"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MagicEffectCancelled(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MagicEffectCancelled"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MagicEffectCancelled(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x1B;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public ushort SkillId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => ReadUInt16BigEndian(this.data[5..]);
            set => WriteUInt16BigEndian(this.data[5..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MagicEffectCancelled"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MagicEffectCancelled(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MagicEffectCancelled"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MagicEffectCancelled packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A player cancelled a specific magic effect of a skill (Infinity Arrow, Wizardry Enhance), or an effect was removed due a timeout (Ice, Poison) or antidote.
    /// Causes reaction on client side: The effect is removed from the target object.
    /// </summary>
    public readonly ref struct MagicEffectCancelled075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MagicEffectCancelled075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MagicEffectCancelled075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MagicEffectCancelled075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MagicEffectCancelled075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x1B;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the skill id.
        /// </summary>
        public byte SkillId
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MagicEffectCancelled075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MagicEffectCancelled075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MagicEffectCancelled075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MagicEffectCancelled075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The appearance of a player changed, all surrounding players are informed about it.
    /// Causes reaction on client side: The appearance of the player is updated.
    /// </summary>
    public readonly ref struct AppearanceChanged
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AppearanceChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AppearanceChanged(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AppearanceChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AppearanceChanged(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x25;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the changed player id.
        /// </summary>
        public ushort ChangedPlayerId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AppearanceChanged"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AppearanceChanged(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AppearanceChanged"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AppearanceChanged packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
    }


    /// <summary>
    /// Is sent by the server when: The server wants to show a message above any kind of character, even NPCs.
    /// Causes reaction on client side: The message is shown above the character.
    /// </summary>
    public readonly ref struct ObjectMessage
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectMessage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectMessage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x01;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the object id.
        /// </summary>
        public ushort ObjectId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(5, this.data.Length - 5, System.Text.Encoding.UTF8);
            set => this.data.Slice(5).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectMessage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectMessage(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectMessage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectMessage packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 5;
    }


    /// <summary>
    /// Is sent by the server when: Another player requests party from the receiver of this message.
    /// Causes reaction on client side: The party request is shown.
    /// </summary>
    public readonly ref struct PartyRequest
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PartyRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x40;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the requester id.
        /// </summary>
        public ushort RequesterId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PartyRequest(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PartyRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PartyRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A player joined a party or requested the current party list by opening the party dialog.
    /// Causes reaction on client side: The party list is updated.
    /// </summary>
    public readonly ref struct PartyList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PartyList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x42;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the count.
        /// </summary>
        public byte Count
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="PartyMember"/> of the specified index.
        /// </summary>
        public PartyMember this[int index] => new (this.data[(5 + index * PartyMember.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PartyList(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PartyList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PartyList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="PartyMember"/>.
        /// </summary>
        /// <param name="membersCount">The count of <see cref="PartyMember"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int membersCount) => membersCount * PartyMember.Length + 5;


    /// <summary>
    /// Data about a party member..
    /// </summary>
    public readonly ref struct PartyMember
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyMember"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyMember(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 24;

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(0, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the index.
        /// </summary>
        public byte Index
        {
            get => this.data[10];
            set => this.data[10] = value;
        }

        /// <summary>
        /// Gets or sets the map id.
        /// </summary>
        public byte MapId
        {
            get => this.data[11];
            set => this.data[11] = value;
        }

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[12];
            set => this.data[12] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[13];
            set => this.data[13] = value;
        }

        /// <summary>
        /// Gets or sets the current health.
        /// </summary>
        public uint CurrentHealth
        {
            get => ReadUInt32LittleEndian(this.data[16..]);
            set => WriteUInt32LittleEndian(this.data[16..], value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public uint MaximumHealth
        {
            get => ReadUInt32LittleEndian(this.data[20..]);
            set => WriteUInt32LittleEndian(this.data[20..], value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: A player joined a party or requested the current party list by opening the party dialog.
    /// Causes reaction on client side: The party list is updated.
    /// </summary>
    public readonly ref struct PartyList075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyList075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyList075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyList075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PartyList075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x42;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the count.
        /// </summary>
        public byte Count
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="PartyMember"/> of the specified index.
        /// </summary>
        public PartyMember this[int index] => new (this.data[(5 + index * PartyMember.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyList075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PartyList075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PartyList075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PartyList075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="PartyMember"/>.
        /// </summary>
        /// <param name="membersCount">The count of <see cref="PartyMember"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int membersCount) => membersCount * PartyMember.Length + 5;


    /// <summary>
    /// Data about a party member..
    /// </summary>
    public readonly ref struct PartyMember
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyMember"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyMember(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 14;

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(0, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the index.
        /// </summary>
        public byte Index
        {
            get => this.data[10];
            set => this.data[10] = value;
        }

        /// <summary>
        /// Gets or sets the map id.
        /// </summary>
        public byte MapId
        {
            get => this.data[11];
            set => this.data[11] = value;
        }

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[12];
            set => this.data[12] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[13];
            set => this.data[13] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: A party member got removed from a party in which the player is in.
    /// Causes reaction on client side: The party member with the specified index is removed from the party list on the user interface.
    /// </summary>
    public readonly ref struct RemovePartyMember
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="RemovePartyMember"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public RemovePartyMember(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RemovePartyMember"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private RemovePartyMember(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x43;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the index.
        /// </summary>
        public byte Index
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="RemovePartyMember"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator RemovePartyMember(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="RemovePartyMember"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(RemovePartyMember packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Periodically, when the health state of the party changed.
    /// Causes reaction on client side: The party health list is updated.
    /// </summary>
    public readonly ref struct PartyHealthUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyHealthUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyHealthUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyHealthUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PartyHealthUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x44;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the count.
        /// </summary>
        public byte Count
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets the <see cref="PartyMemberHealth"/> of the specified index.
        /// </summary>
        public PartyMemberHealth this[int index] => new (this.data[(4 + index * PartyMemberHealth.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PartyHealthUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PartyHealthUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PartyHealthUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PartyHealthUpdate packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="PartyMemberHealth"/>.
        /// </summary>
        /// <param name="membersCount">The count of <see cref="PartyMemberHealth"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int membersCount) => membersCount * PartyMemberHealth.Length + 4;


    /// <summary>
    /// Health of a party member.
    /// </summary>
    public readonly ref struct PartyMemberHealth
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PartyMemberHealth"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PartyMemberHealth(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 1;

        /// <summary>
        /// Gets or sets the index.
        /// </summary>
        public byte Index
        {
            get => this.data.GetByteValue(4, 4);
            set => this.data.SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets a value from 0 to 10 about the health of a player. 10 means the current health is 100% of the maximum health.
        /// </summary>
        public byte Value
        {
            get => this.data.GetByteValue(4, 0);
            set => this.data.SetByteValue(value, 4, 0);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to open his shop and this request was successful.
    /// Causes reaction on client side: The own player shop is shown as open.
    /// </summary>
    public readonly ref struct PlayerShopOpenSuccessful
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopOpenSuccessful"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopOpenSuccessful(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopOpenSuccessful"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopOpenSuccessful(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Success = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x2;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[4..].GetBoolean();
            set => this.data[4..].SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopOpenSuccessful"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopOpenSuccessful(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopOpenSuccessful"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopOpenSuccessful packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the trading partner checked or unchecked the trade accept button.
    /// Causes reaction on client side: The game client updates the trade button state accordingly.
    /// </summary>
    public readonly ref struct TradeButtonStateChanged
    {
        /// <summary>
        /// Defines the state of the trade button.
        /// </summary>
        public enum TradeButtonState
        {
            /// <summary>
            /// Trade button is not pressed. It means that the trade is not yet accepted by the trader.
            /// </summary>
            Unchecked = 0,

            /// <summary>
            /// Trade Button is pressed. It means that the trade is accepted by the trader.
            /// </summary>
            Checked = 1,

            /// <summary>
            /// This state is only sent to the client. After some seconds the client is changing back to normal Unchecked.
            /// </summary>
            Red = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeButtonStateChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeButtonStateChanged(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeButtonStateChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeButtonStateChanged(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC3;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the state.
        /// </summary>
        public TradeButtonStateChanged.TradeButtonState State
        {
            get => (TradeButtonState)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeButtonStateChanged"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeButtonStateChanged(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeButtonStateChanged"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeButtonStateChanged packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The trade money has been set by a previous request of the player.
    /// Causes reaction on client side: The money which was set into the trade by the player is updated on the UI.
    /// </summary>
    public readonly ref struct TradeMoneySetResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeMoneySetResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeMoneySetResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeMoneySetResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeMoneySetResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3A;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeMoneySetResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeMoneySetResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeMoneySetResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeMoneySetResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: This message is sent when the trading partner put a certain amount of money (also 0) into the trade.
    /// Causes reaction on client side: It overrides all previous sent money values.
    /// </summary>
    public readonly ref struct TradeMoneyUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeMoneyUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeMoneyUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeMoneyUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeMoneyUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3B;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the money amount.
        /// </summary>
        public uint MoneyAmount
        {
            get => ReadUInt32LittleEndian(this.data[4..]);
            set => WriteUInt32LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeMoneyUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeMoneyUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeMoneyUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeMoneyUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player which receives this message, sent a trade request to another player. This message is sent when the other player responded to this request.
    /// Causes reaction on client side: If the trade was accepted, a trade dialog is opened. Otherwise, a message is shown.
    /// </summary>
    public readonly ref struct TradeRequestAnswer
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeRequestAnswer"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeRequestAnswer(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeRequestAnswer"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeRequestAnswer(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x37;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 20;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the accepted.
        /// </summary>
        public bool Accepted
        {
            get => this.data[3..].GetBoolean();
            set => this.data[3..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the trade partner level.
        /// </summary>
        public ushort TradePartnerLevel
        {
            get => ReadUInt16BigEndian(this.data[14..]);
            set => WriteUInt16BigEndian(this.data[14..], value);
        }

        /// <summary>
        /// Gets or sets the guild id.
        /// </summary>
        public uint GuildId
        {
            get => ReadUInt32LittleEndian(this.data[16..]);
            set => WriteUInt32LittleEndian(this.data[16..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeRequestAnswer"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeRequestAnswer(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeRequestAnswer"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeRequestAnswer packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A trade was requested by another player.
    /// Causes reaction on client side: A trade request dialog is shown.
    /// </summary>
    public readonly ref struct TradeRequest
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x36;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 13;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeRequest(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A trade was finished.
    /// Causes reaction on client side: The trade dialog is closed. Depending on the result, a message is shown.
    /// </summary>
    public readonly ref struct TradeFinished
    {
        /// <summary>
        /// Defines the result of a finished trade.
        /// </summary>
        public enum TradeResult
        {
            /// <summary>
            /// The trade was cancelled.
            /// </summary>
            Cancelled = 0,

            /// <summary>
            /// The trade was successful.
            /// </summary>
            Success = 1,

            /// <summary>
            /// The trade failed because of a full inventory.
            /// </summary>
            FailedByFullInventory = 2,

            /// <summary>
            /// The trade failed because the request timed out.
            /// </summary>
            TimedOut = 3,

            /// <summary>
            /// The trade failed because one or more items were not allowed to trade.
            /// </summary>
            FailedByItemsNotAllowedToTrade = 4,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeFinished"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeFinished(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeFinished"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeFinished(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3D;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public TradeFinished.TradeResult Result
        {
            get => (TradeResult)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeFinished"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeFinished(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeFinished"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeFinished packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The trading partner added an item to the trade.
    /// Causes reaction on client side: The item is added in the trade dialog.
    /// </summary>
    public readonly ref struct TradeItemAdded
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeItemAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeItemAdded(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeItemAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeItemAdded(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x39;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the to slot.
        /// </summary>
        public byte ToSlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeItemAdded"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeItemAdded(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeItemAdded"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeItemAdded packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
    }


    /// <summary>
    /// Is sent by the server when: The trading partner removed an item from the trade.
    /// Causes reaction on client side: The item is removed from the trade dialog.
    /// </summary>
    public readonly ref struct TradeItemRemoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeItemRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public TradeItemRemoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TradeItemRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private TradeItemRemoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x38;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the slot.
        /// </summary>
        public byte Slot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="TradeItemRemoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator TradeItemRemoved(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="TradeItemRemoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(TradeItemRemoved packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the login request has been processed by the server.
    /// Causes reaction on client side: Shows the result. When it was successful, the client proceeds by sending a character list request.
    /// </summary>
    public readonly ref struct LoginResponse
    {
        /// <summary>
        /// The result of a login request.
        /// </summary>
        public enum LoginResult
        {
            /// <summary>
            /// The password was wrong.
            /// </summary>
            InvalidPassword = 0,

            /// <summary>
            /// The login succeeded.
            /// </summary>
            Okay = 1,

            /// <summary>
            /// The account is invalid.
            /// </summary>
            AccountInvalid = 2,

            /// <summary>
            /// The account is already connected.
            /// </summary>
            AccountAlreadyConnected = 3,

            /// <summary>
            /// The server is full.
            /// </summary>
            ServerIsFull = 4,

            /// <summary>
            /// The account is blocked.
            /// </summary>
            AccountBlocked = 5,

            /// <summary>
            /// The game client has the wrong version.
            /// </summary>
            WrongVersion = 6,

            /// <summary>
            /// An internal error occured during connection.
            /// </summary>
            ConnectionError = 7,

            /// <summary>
            /// Connection closed because of three failed login requests.
            /// </summary>
            ConnectionClosed3Fails = 8,

            /// <summary>
            /// There is no payment information.
            /// </summary>
            NoChargeInfo = 9,

            /// <summary>
            /// The subscription term is over.
            /// </summary>
            SubscriptionTermOver = 10,

            /// <summary>
            /// The subscription time is over.
            /// </summary>
            SubscriptionTimeOver = 11,

            /// <summary>
            /// The account is temporarily blocked.
            /// </summary>
            TemporaryBlocked = 14,

            /// <summary>
            /// Only players over 15 years are allowed to connect.
            /// </summary>
            OnlyPlayersOver15Yrs = 17,

            /// <summary>
            /// The client connected from a blocked country.
            /// </summary>
            BadCountry = 210,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LoginResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LoginResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LoginResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LoginResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public LoginResponse.LoginResult Success
        {
            get => (LoginResult)this.data[4];
            set => this.data[4] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LoginResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LoginResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LoginResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LoginResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the logout request has been processed by the server.
    /// Causes reaction on client side: Depending on the result, the game client closes the game or changes to another selection screen.
    /// </summary>
    public readonly ref struct LogoutResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LogoutResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LogoutResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LogoutResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LogoutResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x02;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public LogOutType Type
        {
            get => (LogOutType)this.data[4];
            set => this.data[4] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LogoutResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LogoutResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LogoutResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LogoutResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A player sends a chat message.
    /// Causes reaction on client side: The message is shown in the chat box and above the character of the sender.
    /// </summary>
    public readonly ref struct ChatMessage
    {
        /// <summary>
        /// Defines the type of a chat message.
        /// </summary>
        public enum ChatMessageType
        {
            /// <summary>
            /// The message is a normal chat message, e.g. public, within a party or guild.
            /// </summary>
            Normal = 0,

            /// <summary>
            /// The message is sent privately to the receiving player.
            /// </summary>
            Whisper = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ChatMessage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ChatMessage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public ChatMessage.ChatMessageType Type
        {
            get => (ChatMessageType)this.data[2];
            set => this.data[2] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the sender.
        /// </summary>
        public string Sender
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(13, this.data.Length - 13, System.Text.Encoding.UTF8);
            set => this.data.Slice(13).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ChatMessage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ChatMessage(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ChatMessage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ChatMessage packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 13;
    }


    /// <summary>
    /// Is sent by the server when: An object got hit in two cases: 1. When the own player is hit; 2. When the own player attacked some other object which got hit.
    /// Causes reaction on client side: The damage is shown at the object which received the hit.
    /// </summary>
    public readonly ref struct ObjectHit
    {
        /// <summary>
        /// Defines the kind of the damage.
        /// </summary>
        public enum DamageKind
        {
            /// <summary>
            /// Red color, used by normal damage.
            /// </summary>
            NormalRed = 0,

            /// <summary>
            /// Cyan color, usually used by ignore defense damage.
            /// </summary>
            IgnoreDefenseCyan = 1,

            /// <summary>
            /// Light green color, usually used by excellent damage.
            /// </summary>
            ExcellentLightGreen = 2,

            /// <summary>
            /// Blue color, usually used by critical damage.
            /// </summary>
            CriticalBlue = 3,

            /// <summary>
            /// Light pink color.
            /// </summary>
            LightPink = 4,

            /// <summary>
            /// Dark green color, usually used by poison damage.
            /// </summary>
            PoisonDarkGreen = 5,

            /// <summary>
            /// Dark pink color, usually used by reflected damage.
            /// </summary>
            ReflectedDarkPink = 6,

            /// <summary>
            /// White color.
            /// </summary>
            White = 7,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectHit"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectHit(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectHit"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectHit(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the header code.
        /// </summary>
        public byte HeaderCode
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the object id.
        /// </summary>
        public ushort ObjectId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the health damage.
        /// </summary>
        public ushort HealthDamage
        {
            get => ReadUInt16BigEndian(this.data[5..]);
            set => WriteUInt16BigEndian(this.data[5..], value);
        }

        /// <summary>
        /// Gets or sets the kind.
        /// </summary>
        public ObjectHit.DamageKind Kind
        {
            get => (DamageKind)this.data[7..].GetByteValue(4, 0);
            set => this.data[7..].SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the is double damage.
        /// </summary>
        public bool IsDoubleDamage
        {
            get => this.data[7..].GetBoolean(6);
            set => this.data[7..].SetBoolean(value, 6);
        }

        /// <summary>
        /// Gets or sets the is triple damage.
        /// </summary>
        public bool IsTripleDamage
        {
            get => this.data[7..].GetBoolean(7);
            set => this.data[7..].SetBoolean(value, 7);
        }

        /// <summary>
        /// Gets or sets the shield damage.
        /// </summary>
        public ushort ShieldDamage
        {
            get => ReadUInt16BigEndian(this.data[8..]);
            set => WriteUInt16BigEndian(this.data[8..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectHit"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectHit(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectHit"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectHit packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An object in the observed scope (including the own player) moved instantly.
    /// Causes reaction on client side: The position of the object is updated on client side.
    /// </summary>
    public readonly ref struct ObjectMoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectMoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectMoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectMoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectMoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x15;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the header code.
        /// </summary>
        public byte HeaderCode
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the object id.
        /// </summary>
        public ushort ObjectId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectMoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectMoved(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectMoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectMoved packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An object in the observed scope (including the own player) walked to another position.
    /// Causes reaction on client side: The object is animated to walk to the new position.
    /// </summary>
    public readonly ref struct ObjectWalked
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectWalked"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectWalked(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectWalked"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectWalked(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xD4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the header code.
        /// </summary>
        public byte HeaderCode
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the object id.
        /// </summary>
        public ushort ObjectId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the target x.
        /// </summary>
        public byte TargetX
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the target y.
        /// </summary>
        public byte TargetY
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the target rotation.
        /// </summary>
        public byte TargetRotation
        {
            get => this.data[7..].GetByteValue(4, 4);
            set => this.data[7..].SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets the step count.
        /// </summary>
        public byte StepCount
        {
            get => this.data[7..].GetByteValue(4, 0);
            set => this.data[7..].SetByteValue(value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the step data.
        /// </summary>
        public Span<byte> StepData
        {
            get => this.data.Slice(8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectWalked"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectWalked(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectWalked"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectWalked packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="StepData"/>.
        /// </summary>
        /// <param name="stepDataLength">The length in bytes of <see cref="StepData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int stepDataLength) => stepDataLength + 8;
    }


    /// <summary>
    /// Is sent by the server when: An object in the observed scope (including the own player) walked to another position.
    /// Causes reaction on client side: The object is animated to walk to the new position.
    /// </summary>
    public readonly ref struct ObjectWalked075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectWalked075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ObjectWalked075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjectWalked075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ObjectWalked075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x10;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the object id.
        /// </summary>
        public ushort ObjectId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the target x.
        /// </summary>
        public byte TargetX
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the target y.
        /// </summary>
        public byte TargetY
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the target rotation.
        /// </summary>
        public byte TargetRotation
        {
            get => this.data[7..].GetByteValue(4, 4);
            set => this.data[7..].SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ObjectWalked075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ObjectWalked075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ObjectWalked075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ObjectWalked075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A player gained experience.
    /// Causes reaction on client side: The experience is added to the experience counter and bar.
    /// </summary>
    public readonly ref struct ExperienceGained
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ExperienceGained"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ExperienceGained(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ExperienceGained"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ExperienceGained(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x16;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the killed object id.
        /// </summary>
        public ushort KilledObjectId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the added experience.
        /// </summary>
        public ushort AddedExperience
        {
            get => ReadUInt16BigEndian(this.data[5..]);
            set => WriteUInt16BigEndian(this.data[5..], value);
        }

        /// <summary>
        /// Gets or sets the damage of last hit.
        /// </summary>
        public ushort DamageOfLastHit
        {
            get => ReadUInt16BigEndian(this.data[7..]);
            set => WriteUInt16BigEndian(this.data[7..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ExperienceGained"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ExperienceGained(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ExperienceGained"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ExperienceGained packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The map was changed on the server side.
    /// Causes reaction on client side: The game client changes to the specified map and coordinates.
    /// </summary>
    public readonly ref struct MapChanged
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MapChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MapChanged(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MapChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MapChanged(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.IsMapChange = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x1C;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x0F;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 15;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets if false, it shows the teleport animation (white bubbles), and the client doesn't remove all of the objects in its scope.
        /// </summary>
        public bool IsMapChange
        {
            get => this.data[4..].GetBoolean();
            set => this.data[4..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the map number.
        /// </summary>
        public ushort MapNumber
        {
            get => ReadUInt16BigEndian(this.data[5..]);
            set => WriteUInt16BigEndian(this.data[5..], value);
        }

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[9];
            set => this.data[9] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MapChanged"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MapChanged(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MapChanged"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MapChanged packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The map was changed on the server side.
    /// Causes reaction on client side: The game client changes to the specified map and coordinates.
    /// </summary>
    public readonly ref struct MapChanged075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MapChanged075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MapChanged075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MapChanged075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MapChanged075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                this.IsMapChange = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x1C;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets if false, it shows the teleport animation (white bubbles), and the client doesn't remove all of the objects in its scope.
        /// </summary>
        public bool IsMapChange
        {
            get => this.data[3..].GetBoolean();
            set => this.data[3..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the map number.
        /// </summary>
        public byte MapNumber
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MapChanged075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MapChanged075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MapChanged075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MapChanged075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: When entering the game world with a character.
    /// Causes reaction on client side: The client restores this configuration in its user interface.
    /// </summary>
    public readonly ref struct ApplyKeyConfiguration
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ApplyKeyConfiguration"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ApplyKeyConfiguration(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ApplyKeyConfiguration"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ApplyKeyConfiguration(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x30;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the binary data of the key configuration
        /// </summary>
        public Span<byte> Configuration
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ApplyKeyConfiguration"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ApplyKeyConfiguration(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ApplyKeyConfiguration"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ApplyKeyConfiguration packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="Configuration"/>.
        /// </summary>
        /// <param name="configurationLength">The length in bytes of <see cref="Configuration"/> on which the required size depends.</param>
        public static int GetRequiredSize(int configurationLength) => configurationLength + 4;
    }


    /// <summary>
    /// Is sent by the server when: The items dropped on the ground.
    /// Causes reaction on client side: The client adds the items to the ground.
    /// </summary>
    public readonly ref struct ItemsDropped
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemsDropped"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemsDropped(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemsDropped"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemsDropped(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x20;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="DroppedItem"/> of the specified index.
        /// </summary>
        public DroppedItem this[int index, int droppedItemLength] => new (this.data[(5 + index * droppedItemLength)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemsDropped"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemsDropped(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemsDropped"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemsDropped packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="DroppedItem"/> and it's size.
        /// </summary>
        /// <param name="itemsCount">The count of <see cref="DroppedItem"/> from which the size will be calculated.</param>
        /// <param name="structLength">The length of <see cref="DroppedItem"/> from which the size will be calculated.</param>
          public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 5;


    /// <summary>
    /// Contains the data about a dropped item..
    /// </summary>
    public readonly ref struct DroppedItem
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="DroppedItem"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public DroppedItem(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets if this flag is set, the item is added to the map with an animation and sound. Otherwise it's just added like it was already on the ground before.
        /// </summary>
        public bool IsFreshDrop
        {
            get => this.data.GetBoolean(7);
            set => this.data.SetBoolean(value, 7);
        }

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
    }
    }


    /// <summary>
    /// Is sent by the server when: Money dropped on the ground.
    /// Causes reaction on client side: The client adds the money to the ground.
    /// </summary>
    public readonly ref partial struct MoneyDropped
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MoneyDropped"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MoneyDropped(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MoneyDropped"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MoneyDropped(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)Math.Min(data.Length, Length);
                this.ItemCount = 1;
                this.MoneyNumber = 15;
                this.MoneyGroup = 14;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x20;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 21;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data[5..]);
            set => WriteUInt16BigEndian(this.data[5..], value);
        }

        /// <summary>
        /// Gets or sets if this flag is set, the money is added to the map with an animation and sound. Otherwise it's just added like it was already on the ground before.
        /// </summary>
        public bool IsFreshDrop
        {
            get => this.data[5..].GetBoolean(7);
            set => this.data[5..].SetBoolean(value, 7);
        }

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the money number.
        /// </summary>
        public byte MoneyNumber
        {
            get => this.data[9];
            set => this.data[9] = value;
        }

        /// <summary>
        /// Gets or sets the money group.
        /// </summary>
        public byte MoneyGroup
        {
            get => this.data[14..].GetByteValue(8, 4);
            set => this.data[14..].SetByteValue(value, 8, 4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MoneyDropped"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MoneyDropped(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MoneyDropped"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MoneyDropped packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Money dropped on the ground.
    /// Causes reaction on client side: The client adds the money to the ground.
    /// </summary>
    public readonly ref partial struct MoneyDropped075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MoneyDropped075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MoneyDropped075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MoneyDropped075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MoneyDropped075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)Math.Min(data.Length, Length);
                this.ItemCount = 1;
                this.MoneyNumber = 15;
                this.MoneyGroup = 14;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x20;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 14;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data[5..]);
            set => WriteUInt16BigEndian(this.data[5..], value);
        }

        /// <summary>
        /// Gets or sets if this flag is set, the money is added to the map with an animation and sound. Otherwise it's just added like it was already on the ground before.
        /// </summary>
        public bool IsFreshDrop
        {
            get => this.data[5..].GetBoolean(7);
            set => this.data[5..].SetBoolean(value, 7);
        }

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the money number.
        /// </summary>
        public byte MoneyNumber
        {
            get => this.data[9..].GetByteValue(4, 0);
            set => this.data[9..].SetByteValue(value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the money group.
        /// </summary>
        public byte MoneyGroup
        {
            get => this.data[9..].GetByteValue(4, 4);
            set => this.data[9..].SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MoneyDropped075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MoneyDropped075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MoneyDropped075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MoneyDropped075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A dropped item was removed from the ground of the map, e.g. when it timed out or was picked up.
    /// Causes reaction on client side: The client removes the item from the ground of the map.
    /// </summary>
    public readonly ref struct ItemDropRemoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemDropRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemDropRemoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemDropRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemDropRemoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x21;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="DroppedItemId"/> of the specified index.
        /// </summary>
        public DroppedItemId this[int index] => new (this.data[(5 + index * DroppedItemId.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemDropRemoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemDropRemoved(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemDropRemoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemDropRemoved packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="DroppedItemId"/>.
        /// </summary>
        /// <param name="itemDataCount">The count of <see cref="DroppedItemId"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int itemDataCount) => itemDataCount * DroppedItemId.Length + 5;


    /// <summary>
    /// Contains the id of a dropped item..
    /// </summary>
    public readonly ref struct DroppedItemId
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="DroppedItemId"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public DroppedItemId(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: A new item was added to the inventory.
    /// Causes reaction on client side: The client adds the item to the inventory user interface.
    /// </summary>
    public readonly ref struct ItemAddedToInventory
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemAddedToInventory"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemAddedToInventory(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemAddedToInventory"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemAddedToInventory(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x22;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemAddedToInventory"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemAddedToInventory(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemAddedToInventory"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemAddedToInventory packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
    }


    /// <summary>
    /// Is sent by the server when: The player requested to drop an item of his inventory. This message is the response about the success of the request.
    /// Causes reaction on client side: If successful, the client removes the item from the inventory user interface.
    /// </summary>
    public readonly ref struct ItemDropResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemDropResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemDropResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemDropResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemDropResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x23;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[3..].GetBoolean();
            set => this.data[3..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemDropResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemDropResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemDropResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemDropResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player requested to pick up an item from to ground to add it to his inventory, but it failed.
    /// Causes reaction on client side: Depending on the reason, the game client shows a message.
    /// </summary>
    public readonly ref struct ItemPickUpRequestFailed
    {
        /// <summary>
        /// Defines the possible fail reasons
        /// </summary>
        public enum ItemPickUpFailReason
        {
            /// <summary>
            /// The picked up item was combined into an existing item of the players inventory. A separate durability update will be sent to the client.
            /// </summary>
            ItemStacked = 253,

            /// <summary>
            /// The maximum inventory money has been reached, so the money wasn't picked up. Should not be used, because it's used in the InventoryMoneyUpdate message.
            /// </summary>
            __MaximumInventoryMoneyReached = 254,

            /// <summary>
            /// The general, non-specific reason. It just failed.
            /// </summary>
            General = 255,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemPickUpRequestFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemPickUpRequestFailed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemPickUpRequestFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemPickUpRequestFailed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x22;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the fail reason.
        /// </summary>
        public ItemPickUpRequestFailed.ItemPickUpFailReason FailReason
        {
            get => (ItemPickUpFailReason)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemPickUpRequestFailed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemPickUpRequestFailed(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemPickUpRequestFailed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemPickUpRequestFailed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The players money amount of the inventory has been changed and needs an update.
    /// Causes reaction on client side: The money is updated in the inventory user interface.
    /// </summary>
    public readonly ref struct InventoryMoneyUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="InventoryMoneyUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public InventoryMoneyUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InventoryMoneyUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private InventoryMoneyUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x22;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFE;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the money.
        /// </summary>
        public uint Money
        {
            get => ReadUInt32BigEndian(this.data[4..]);
            set => WriteUInt32BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="InventoryMoneyUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator InventoryMoneyUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="InventoryMoneyUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(InventoryMoneyUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An item in the inventory or vault of the player has been moved.
    /// Causes reaction on client side: The client updates the position of item in the user interface.
    /// </summary>
    public readonly ref struct ItemMoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemMoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemMoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemMoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemMoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x24;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the target storage type.
        /// </summary>
        public ItemStorageKind TargetStorageType
        {
            get => (ItemStorageKind)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the target slot.
        /// </summary>
        public byte TargetSlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemMoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemMoved(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemMoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemMoved packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
    }


    /// <summary>
    /// Is sent by the server when: An item in the inventory or vault of the player could not be moved as requested by the player.
    /// Causes reaction on client side: The client restores the position of item in the user interface.
    /// </summary>
    public readonly ref struct ItemMoveRequestFailed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemMoveRequestFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemMoveRequestFailed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemMoveRequestFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemMoveRequestFailed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x24;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFF;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemMoveRequestFailed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemMoveRequestFailed(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemMoveRequestFailed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemMoveRequestFailed packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
    }


    /// <summary>
    /// Is sent by the server when: Periodically, or if the current health or shield changed on the server side, e.g. by hits.
    /// Causes reaction on client side: The health and shield bar is updated on the game client user interface.
    /// </summary>
    public readonly ref struct CurrentHealthAndShield
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CurrentHealthAndShield(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CurrentHealthAndShield(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x26;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFF;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the health.
        /// </summary>
        public ushort Health
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the shield.
        /// </summary>
        public ushort Shield
        {
            get => ReadUInt16BigEndian(this.data[7..]);
            set => WriteUInt16BigEndian(this.data[7..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CurrentHealthAndShield"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CurrentHealthAndShield(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CurrentHealthAndShield"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CurrentHealthAndShield packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: When the maximum health changed, e.g. by adding stat points or changed items.
    /// Causes reaction on client side: The health and shield bar is updated on the game client user interface.
    /// </summary>
    public readonly ref struct MaximumHealthAndShield
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MaximumHealthAndShield(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumHealthAndShield"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MaximumHealthAndShield(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x26;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFE;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the health.
        /// </summary>
        public ushort Health
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the shield.
        /// </summary>
        public ushort Shield
        {
            get => ReadUInt16BigEndian(this.data[7..]);
            set => WriteUInt16BigEndian(this.data[7..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MaximumHealthAndShield"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MaximumHealthAndShield(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MaximumHealthAndShield"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MaximumHealthAndShield packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: When the consumption of an item failed.
    /// Causes reaction on client side: The game client gets a feedback about a failed consumption, and allows for do further consumption requests.
    /// </summary>
    public readonly ref struct ItemConsumptionFailed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemConsumptionFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemConsumptionFailed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemConsumptionFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemConsumptionFailed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x26;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFD;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the health.
        /// </summary>
        public ushort Health
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the shield.
        /// </summary>
        public ushort Shield
        {
            get => ReadUInt16BigEndian(this.data[7..]);
            set => WriteUInt16BigEndian(this.data[7..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemConsumptionFailed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemConsumptionFailed(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemConsumptionFailed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemConsumptionFailed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The currently available mana or ability has changed, e.g. by using a skill.
    /// Causes reaction on client side: The mana and ability bar is updated on the game client user interface.
    /// </summary>
    public readonly ref struct CurrentManaAndAbility
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CurrentManaAndAbility(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CurrentManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CurrentManaAndAbility(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x27;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFF;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the mana.
        /// </summary>
        public ushort Mana
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the ability.
        /// </summary>
        public ushort Ability
        {
            get => ReadUInt16BigEndian(this.data[6..]);
            set => WriteUInt16BigEndian(this.data[6..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CurrentManaAndAbility"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CurrentManaAndAbility(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CurrentManaAndAbility"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CurrentManaAndAbility packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The maximum available mana or ability has changed, e.g. by adding stat points.
    /// Causes reaction on client side: The mana and ability bar is updated on the game client user interface.
    /// </summary>
    public readonly ref struct MaximumManaAndAbility
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MaximumManaAndAbility(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MaximumManaAndAbility"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MaximumManaAndAbility(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x27;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFE;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the mana.
        /// </summary>
        public ushort Mana
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the ability.
        /// </summary>
        public ushort Ability
        {
            get => ReadUInt16BigEndian(this.data[6..]);
            set => WriteUInt16BigEndian(this.data[6..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MaximumManaAndAbility"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MaximumManaAndAbility(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MaximumManaAndAbility"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MaximumManaAndAbility packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The item has been removed from the inventory of the player.
    /// Causes reaction on client side: The client removes the item in the inventory user interface.
    /// </summary>
    public readonly ref struct ItemRemoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemRemoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemRemoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                this.TrueFlag = 1;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x28;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the affected slot of the item in the inventory.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the true flag.
        /// </summary>
        public byte TrueFlag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemRemoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemRemoved(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemRemoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemRemoved packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The client requested to consume a special item, e.g. a bottle of Ale.
    /// Causes reaction on client side: The player is shown in a red color and has increased attack speed.
    /// </summary>
    public readonly ref struct ConsumeItemWithEffect
    {
        /// <summary>
        /// Defines a consumed item.
        /// </summary>
        public enum ConsumedItemType
        {
            /// <summary>
            /// The player consumes a bottle of ale, usually 80 seconds effect time.
            /// </summary>
            Ale = 0,

            /// <summary>
            /// The player consumes a redemy of love, usually 90 seconds effect time.
            /// </summary>
            RedemyOfLove = 1,

            /// <summary>
            /// The player consumes a potion of soul, usually 60 seconds effect time.
            /// </summary>
            PotionOfSoul = 77,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConsumeItemWithEffect"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ConsumeItemWithEffect(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConsumeItemWithEffect"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ConsumeItemWithEffect(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x29;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the item type.
        /// </summary>
        public ConsumeItemWithEffect.ConsumedItemType ItemType
        {
            get => (ConsumedItemType)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the effect time in seconds.
        /// </summary>
        public ushort EffectTimeInSeconds
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ConsumeItemWithEffect"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ConsumeItemWithEffect(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ConsumeItemWithEffect"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ConsumeItemWithEffect packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The durability of an item in the inventory of the player has been changed.
    /// Causes reaction on client side: The client updates the item in the inventory user interface.
    /// </summary>
    public readonly ref struct ItemDurabilityChanged
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemDurabilityChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemDurabilityChanged(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemDurabilityChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemDurabilityChanged(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x2A;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the durability.
        /// </summary>
        public byte Durability
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets true, if the change resulted from an item consumption; otherwise, false
        /// </summary>
        public bool ByConsumption
        {
            get => this.data[5..].GetBoolean();
            set => this.data[5..].SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemDurabilityChanged"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemDurabilityChanged(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemDurabilityChanged"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemDurabilityChanged packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player requested to consume a fruit.
    /// Causes reaction on client side: The client updates the user interface, by changing the added stat points and used fruit points.
    /// </summary>
    public readonly ref struct FruitConsumptionResponse
    {
        /// <summary>
        /// Defines the result of the fruit consumption request.
        /// </summary>
        public enum FruitConsumptionResult
        {
            /// <summary>
            /// Consumption to add points was successful.
            /// </summary>
            PlusSuccess = 0,

            /// <summary>
            /// Consumption to add points failed.
            /// </summary>
            PlusFailed = 1,

            /// <summary>
            /// Consumption to add points was prevented because some conditions were not correct.
            /// </summary>
            PlusPrevented = 2,

            /// <summary>
            /// Consumption to remove points was successful.
            /// </summary>
            MinusSuccess = 3,

            /// <summary>
            /// Consumption to remove points failed.
            /// </summary>
            MinusFailed = 4,

            /// <summary>
            /// Consumption to remove points was prevented because some conditions were not correct.
            /// </summary>
            MinusPrevented = 5,

            /// <summary>
            /// Consumption to remove points was successful, removed by a fruit acquired through the cash shop.
            /// </summary>
            MinusSuccessCashShopFruit = 6,

            /// <summary>
            /// Consumption was prevented because an item was equipped.
            /// </summary>
            PreventedByEquippedItems = 16,

            /// <summary>
            /// Consumption to add points was prevented because the maximum amount of points have been added.
            /// </summary>
            PlusPreventedByMaximum = 33,

            /// <summary>
            /// Consumption to remove points was prevented because the maximum amount of points have been removed.
            /// </summary>
            MinusPreventedByMaximum = 37,

            /// <summary>
            /// Consumption to remove points was prevented because the base amount of stat points of the character class cannot be undercut.
            /// </summary>
            MinusPreventedByDefault = 38,
        }

        /// <summary>
        /// Defines the type of stat which the fruit modifies.
        /// </summary>
        public enum FruitStatType
        {
            /// <summary>
            /// Fruit which modifies the energy stat.
            /// </summary>
            Energy = 0,

            /// <summary>
            /// Fruit which modifies the vitality stat.
            /// </summary>
            Vitality = 1,

            /// <summary>
            /// Fruit which modifies the agility stat.
            /// </summary>
            Agility = 2,

            /// <summary>
            /// Fruit which modifies the strength stat.
            /// </summary>
            Strength = 3,

            /// <summary>
            /// Fruit which modifies the leadership stat.
            /// </summary>
            Leadership = 4,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FruitConsumptionResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FruitConsumptionResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FruitConsumptionResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FruitConsumptionResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x2C;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public FruitConsumptionResponse.FruitConsumptionResult Result
        {
            get => (FruitConsumptionResult)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the stat points.
        /// </summary>
        public ushort StatPoints
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the stat type.
        /// </summary>
        public FruitConsumptionResponse.FruitStatType StatType
        {
            get => (FruitStatType)this.data[6];
            set => this.data[6] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FruitConsumptionResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FruitConsumptionResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FruitConsumptionResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FruitConsumptionResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the client talked to an NPC which should cause a dialog to open on the client side.
    /// Causes reaction on client side: The client opens the specified dialog.
    /// </summary>
    public readonly ref struct NpcWindowResponse
    {
        /// <summary>
        /// Defines the kind of npc window which should be shown on the client.
        /// </summary>
        public enum NpcWindow
        {
            /// <summary>
            /// A merchant window.
            /// </summary>
            Merchant = 0,

            /// <summary>
            /// Another merchant window.
            /// </summary>
            Merchant1 = 1,

            /// <summary>
            /// A vault storage.
            /// </summary>
            VaultStorage = 2,

            /// <summary>
            /// A chaos machine window.
            /// </summary>
            ChaosMachine = 3,

            /// <summary>
            /// A devil square window.
            /// </summary>
            DevilSquare = 4,

            /// <summary>
            /// A blood castle window.
            /// </summary>
            BloodCastle = 6,

            /// <summary>
            /// The pet trainer window.
            /// </summary>
            PetTrainer = 7,

            /// <summary>
            /// The lahap window.
            /// </summary>
            Lahap = 9,

            /// <summary>
            /// The castle senior window.
            /// </summary>
            CastleSeniorNPC = 12,

            /// <summary>
            /// The elphis refinery window.
            /// </summary>
            ElphisRefinery = 17,

            /// <summary>
            /// The refine stone making window.
            /// </summary>
            RefineStoneMaking = 18,

            /// <summary>
            /// The jewel of harmony option removal window.
            /// </summary>
            RemoveJohOption = 19,

            /// <summary>
            /// The illusion temple window.
            /// </summary>
            IllusionTemple = 20,

            /// <summary>
            /// The chaos card combination window.
            /// </summary>
            ChaosCardCombination = 21,

            /// <summary>
            /// The cherry blossom branches assembly window.
            /// </summary>
            CherryBlossomBranchesAssembly = 22,

            /// <summary>
            /// The seed master window.
            /// </summary>
            SeedMaster = 23,

            /// <summary>
            /// The seed researcher window.
            /// </summary>
            SeedResearcher = 24,

            /// <summary>
            /// The stat reinitializer window.
            /// </summary>
            StatReInitializer = 25,

            /// <summary>
            /// The delgado lucky coin registration window.
            /// </summary>
            DelgadoLuckyCoinRegistration = 32,

            /// <summary>
            /// The doorkeeper titus duel watch window.
            /// </summary>
            DoorkeeperTitusDuelWatch = 33,

            /// <summary>
            /// The lugard doppelganger entry window.
            /// </summary>
            LugardDoppelgangerEntry = 35,

            /// <summary>
            /// The jerint gaion event entry window.
            /// </summary>
            JerintGaionEvententry = 36,

            /// <summary>
            /// The julia warp market server window.
            /// </summary>
            JuliaWarpMarketServer = 37,

            /// <summary>
            /// The dialog window which allows to exchange or refine Lucky Item. Used by NPC "David".
            /// </summary>
            CombineLuckyItem = 38,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcWindowResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public NpcWindowResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcWindowResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private NpcWindowResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x30;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 11;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the window.
        /// </summary>
        public NpcWindowResponse.NpcWindow Window
        {
            get => (NpcWindow)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="NpcWindowResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator NpcWindowResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="NpcWindowResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(NpcWindowResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player opens a merchant npc or the vault. It's sent after the dialog was opened by another message.
    /// Causes reaction on client side: The client shows the items in the opened dialog.
    /// </summary>
    public readonly ref struct StoreItemList
    {
        /// <summary>
        /// Defines the kind of npc window which should be shown on the client.
        /// </summary>
        public enum ItemWindow
        {
            /// <summary>
            /// A normal window.
            /// </summary>
            Normal = 0,

            /// <summary>
            /// A chaos machine window.
            /// </summary>
            ChaosMachine = 3,

            /// <summary>
            /// A failed resurrection (of Dark Horse or Dark Raven) storage dialog.
            /// </summary>
            ResurrectionFailed = 5,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="StoreItemList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public StoreItemList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StoreItemList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private StoreItemList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x31;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public StoreItemList.ItemWindow Type
        {
            get => (ItemWindow)this.data[4];
            set => this.data[4] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets the <see cref="StoredItem"/> of the specified index.
        /// </summary>
        public StoredItem this[int index, int storedItemLength] => new (this.data[(6 + index * storedItemLength)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="StoreItemList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator StoreItemList(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="StoreItemList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(StoreItemList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="StoredItem"/> and it's size.
        /// </summary>
        /// <param name="itemsCount">The count of <see cref="StoredItem"/> from which the size will be calculated.</param>
        /// <param name="structLength">The length of <see cref="StoredItem"/> from which the size will be calculated.</param>
          public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 6;
    }


    /// <summary>
    /// Is sent by the server when: The request of buying an item from a NPC failed.
    /// Causes reaction on client side: The client is responsive again. Without this message, it may stuck.
    /// </summary>
    public readonly ref struct NpcItemBuyFailed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcItemBuyFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public NpcItemBuyFailed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcItemBuyFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private NpcItemBuyFailed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x32;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0xFF;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="NpcItemBuyFailed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator NpcItemBuyFailed(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="NpcItemBuyFailed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(NpcItemBuyFailed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The request of buying an item from a player or npc was successful.
    /// Causes reaction on client side: The bought item is added to the inventory.
    /// </summary>
    public readonly ref struct ItemBought
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemBought"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemBought(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemBought"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemBought(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x32;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemBought"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemBought(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemBought"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemBought packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
    }


    /// <summary>
    /// Is sent by the server when: The result of a previous item sell request.
    /// Causes reaction on client side: The amount of specified money is set at the players inventory.
    /// </summary>
    public readonly ref struct NpcItemSellResult
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcItemSellResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public NpcItemSellResult(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NpcItemSellResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private NpcItemSellResult(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x33;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[3..].GetBoolean();
            set => this.data[3..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the money.
        /// </summary>
        public uint Money
        {
            get => ReadUInt32LittleEndian(this.data[4..]);
            set => WriteUInt32LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="NpcItemSellResult"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator NpcItemSellResult(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="NpcItemSellResult"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(NpcItemSellResult packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player requested to set a price for an item of the players shop.
    /// Causes reaction on client side: The item gets a price on the user interface.
    /// </summary>
    public readonly ref struct PlayerShopSetItemPriceResponse
    {
        /// <summary>
        /// Describes the possible results of setting an item price in a player shop.
        /// </summary>
        public enum ItemPriceSetResult
        {
            /// <summary>
            /// Failed, e.g. because the shop feature is deactivated
            /// </summary>
            Failed = 0,

            /// <summary>
            /// The price has been set successfully
            /// </summary>
            Success = 1,

            /// <summary>
            /// Failed because the item slot was out of range
            /// </summary>
            ItemSlotOutOfRange = 2,

            /// <summary>
            /// Failed because the item could not be found
            /// </summary>
            ItemNotFound = 3,

            /// <summary>
            /// Failed because the price was negative
            /// </summary>
            PriceNegative = 4,

            /// <summary>
            /// Failed because the item is blocked
            /// </summary>
            ItemIsBlocked = 5,

            /// <summary>
            /// Failed because the character level is too low (below level 6)
            /// </summary>
            CharacterLevelTooLow = 6,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopSetItemPriceResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopSetItemPriceResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopSetItemPriceResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopSetItemPriceResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public PlayerShopSetItemPriceResponse.ItemPriceSetResult Result
        {
            get => (ItemPriceSetResult)this.data[4];
            set => this.data[4] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopSetItemPriceResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopSetItemPriceResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopSetItemPriceResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopSetItemPriceResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a player in scope requested to close his shop or after all items has been sold.
    /// Causes reaction on client side: The player shop not shown as open anymore.
    /// </summary>
    public readonly ref struct PlayerShopClosed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopClosed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopClosed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopClosed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopClosed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Success = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x3;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[4..].GetBoolean();
            set => this.data[4..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[5..]);
            set => WriteUInt16BigEndian(this.data[5..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopClosed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopClosed(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopClosed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopClosed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: An item of the players shop was sold to another player.
    /// Causes reaction on client side: The item is removed from the players inventory and a blue system message appears.
    /// </summary>
    public readonly ref struct PlayerShopItemSoldToPlayer
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItemSoldToPlayer"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopItemSoldToPlayer(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItemSoldToPlayer"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopItemSoldToPlayer(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x08;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 15;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the buyer name.
        /// </summary>
        public string BuyerName
        {
            get => this.data.ExtractString(5, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(5, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopItemSoldToPlayer"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopItemSoldToPlayer(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopItemSoldToPlayer"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopItemSoldToPlayer packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to close his shop or after all items has been sold.
    /// Causes reaction on client side: The player shop dialog is closed for the shop of the specified player.
    /// </summary>
    public readonly ref struct ClosePlayerShopDialog
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ClosePlayerShopDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ClosePlayerShopDialog(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ClosePlayerShopDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ClosePlayerShopDialog(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x12;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ClosePlayerShopDialog"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ClosePlayerShopDialog(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ClosePlayerShopDialog"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ClosePlayerShopDialog packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to open a shop of another player.
    /// Causes reaction on client side: The player shop dialog is shown with the provided item data.
    /// </summary>
    public readonly ref struct PlayerShopItemList
    {
        /// <summary>
        /// The kind of action which led to the list message.
        /// </summary>
        public enum ActionKind
        {
            /// <summary>
            /// The list was requested.
            /// </summary>
            ByRequest = 5,

            /// <summary>
            /// The list was changed, e.g. because an item was sold.
            /// </summary>
            UpdateAfterItemChange = 19,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItemList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShopItemList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShopItemList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShopItemList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
                this.Success = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x05;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the action.
        /// </summary>
        public PlayerShopItemList.ActionKind Action
        {
            get => (ActionKind)this.data[4];
            set => this.data[4] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[5..].GetBoolean();
            set => this.data[5..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[6..]);
            set => WriteUInt16BigEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets the player name.
        /// </summary>
        public string PlayerName
        {
            get => this.data.ExtractString(8, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(8, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the shop name.
        /// </summary>
        public string ShopName
        {
            get => this.data.ExtractString(18, 36, System.Text.Encoding.UTF8);
            set => this.data.Slice(18, 36).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[54];
            set => this.data[54] = value;
        }

        /// <summary>
        /// Gets the <see cref="PlayerShopItem"/> of the specified index.
        /// </summary>
        public PlayerShopItem this[int index] => new (this.data[(55 + index * PlayerShopItem.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShopItemList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShopItemList(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShopItemList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShopItemList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="PlayerShopItem"/>.
        /// </summary>
        /// <param name="itemsCount">The count of <see cref="PlayerShopItem"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int itemsCount) => itemsCount * PlayerShopItem.Length + 55;
    }


    /// <summary>
    /// Is sent by the server when: After the player gets into scope of a player with an opened shop.
    /// Causes reaction on client side: The player shop title is shown at the specified players.
    /// </summary>
    public readonly ref struct PlayerShops
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShops"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShops(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShops"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PlayerShops(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x3F;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the shop count.
        /// </summary>
        public byte ShopCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets the <see cref="PlayerShop"/> of the specified index.
        /// </summary>
        public PlayerShop this[int index] => new (this.data[(6 + index * PlayerShop.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PlayerShops"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PlayerShops(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PlayerShops"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PlayerShops packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="PlayerShop"/>.
        /// </summary>
        /// <param name="shopsCount">The count of <see cref="PlayerShop"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int shopsCount) => shopsCount * PlayerShop.Length + 6;


    /// <summary>
    /// Data of the shop of a player..
    /// </summary>
    public readonly ref struct PlayerShop
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayerShop"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PlayerShop(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 38;

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the store name.
        /// </summary>
        public string StoreName
        {
            get => this.data.ExtractString(2, 36, System.Text.Encoding.UTF8);
            set => this.data.Slice(2, 36).WriteString(value, System.Text.Encoding.UTF8);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: The player wears a monster transformation ring.
    /// Causes reaction on client side: The character appears as monster, defined by the Skin property.
    /// </summary>
    public readonly ref struct AddTransformedCharactersToScope075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddTransformedCharactersToScope075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddTransformedCharactersToScope075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddTransformedCharactersToScope075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddTransformedCharactersToScope075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x45;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the character count.
        /// </summary>
        public byte CharacterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="CharacterData"/> of the specified index.
        /// </summary>
        public CharacterData this[int index] => new (this.data[(5 + index * CharacterData.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddTransformedCharactersToScope075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddTransformedCharactersToScope075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddTransformedCharactersToScope075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddTransformedCharactersToScope075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
        /// </summary>
        /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 5;


    /// <summary>
    /// Contains the data of an character..
    /// </summary>
    public readonly ref struct CharacterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 19;

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        public ushort Id
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the current position x.
        /// </summary>
        public byte CurrentPositionX
        {
            get => this.data[2];
            set => this.data[2] = value;
        }

        /// <summary>
        /// Gets or sets the current position y.
        /// </summary>
        public byte CurrentPositionY
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the skin.
        /// </summary>
        public byte Skin
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the is poisoned.
        /// </summary>
        public bool IsPoisoned
        {
            get => this.data[5..].GetBoolean(0);
            set => this.data[5..].SetBoolean(value, 0);
        }

        /// <summary>
        /// Gets or sets the is iced.
        /// </summary>
        public bool IsIced
        {
            get => this.data[5..].GetBoolean(1);
            set => this.data[5..].SetBoolean(value, 1);
        }

        /// <summary>
        /// Gets or sets the is damage buffed.
        /// </summary>
        public bool IsDamageBuffed
        {
            get => this.data[5..].GetBoolean(2);
            set => this.data[5..].SetBoolean(value, 2);
        }

        /// <summary>
        /// Gets or sets the is defense buffed.
        /// </summary>
        public bool IsDefenseBuffed
        {
            get => this.data[5..].GetBoolean(3);
            set => this.data[5..].SetBoolean(value, 3);
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(6, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the target position x.
        /// </summary>
        public byte TargetPositionX
        {
            get => this.data[16];
            set => this.data[16] = value;
        }

        /// <summary>
        /// Gets or sets the target position y.
        /// </summary>
        public byte TargetPositionY
        {
            get => this.data[17];
            set => this.data[17] = value;
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[18..].GetByteValue(4, 4);
            set => this.data[18..].SetByteValue(value, 4, 4);
        }

        /// <summary>
        /// Gets or sets the hero state.
        /// </summary>
        public CharacterHeroState HeroState
        {
            get => (CharacterHeroState)this.data[18..].GetByteValue(4, 0);
            set => this.data[18..].SetByteValue((byte)value, 4, 0);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the game client requested it, usually after a successful login.
    /// Causes reaction on client side: The game client shows the available characters of the account.
    /// </summary>
    public readonly ref struct CharacterList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the creation flags.
        /// </summary>
        public byte CreationFlags
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the move cnt.
        /// </summary>
        public byte MoveCnt
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the character count.
        /// </summary>
        public byte CharacterCount
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the is vault extended.
        /// </summary>
        public bool IsVaultExtended
        {
            get => this.data[7..].GetBoolean();
            set => this.data[7..].SetBoolean(value);
        }

        /// <summary>
        /// Gets the <see cref="CharacterData"/> of the specified index.
        /// </summary>
        public CharacterData this[int index] => new (this.data[(8 + index * CharacterData.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterList(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
        /// </summary>
        /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 8;


    /// <summary>
    /// Data of one character in the list..
    /// </summary>
    public readonly ref struct CharacterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 34;

        /// <summary>
        /// Gets or sets the slot index.
        /// </summary>
        public byte SlotIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(1, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(1, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => ReadUInt16LittleEndian(this.data[12..]);
            set => WriteUInt16LittleEndian(this.data[12..], value);
        }

        /// <summary>
        /// Gets or sets the status.
        /// </summary>
        public CharacterStatus Status
        {
            get => (CharacterStatus)this.data[14..].GetByteValue(4, 0);
            set => this.data[14..].SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the is item block active.
        /// </summary>
        public bool IsItemBlockActive
        {
            get => this.data[14..].GetBoolean(4);
            set => this.data[14..].SetBoolean(value, 4);
        }

        /// <summary>
        /// Gets or sets the appearance.
        /// </summary>
        public Span<byte> Appearance
        {
            get => this.data.Slice(15, 18);
        }

        /// <summary>
        /// Gets or sets the guild position.
        /// </summary>
        public GuildMemberRole GuildPosition
        {
            get => (GuildMemberRole)this.data[33];
            set => this.data[33] = (byte)value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the game client requested it, usually after a successful login.
    /// Causes reaction on client side: The game client shows the available characters of the account.
    /// </summary>
    public readonly ref struct CharacterList075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterList075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterList075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterList075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the character count.
        /// </summary>
        public byte CharacterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="CharacterData"/> of the specified index.
        /// </summary>
        public CharacterData this[int index] => new (this.data[(5 + index * CharacterData.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterList075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterList075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterList075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterList075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
        /// </summary>
        /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 5;


    /// <summary>
    /// Data of one character in the list..
    /// </summary>
    public readonly ref struct CharacterData
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterData"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterData(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 24;

        /// <summary>
        /// Gets or sets the slot index.
        /// </summary>
        public byte SlotIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(1, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(1, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => ReadUInt16BigEndian(this.data[11..]);
            set => WriteUInt16BigEndian(this.data[11..], value);
        }

        /// <summary>
        /// Gets or sets the status.
        /// </summary>
        public CharacterStatus Status
        {
            get => (CharacterStatus)this.data[13..].GetByteValue(4, 0);
            set => this.data[13..].SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the is item block active.
        /// </summary>
        public bool IsItemBlockActive
        {
            get => this.data[13..].GetBoolean(4);
            set => this.data[13..].SetBoolean(value, 4);
        }

        /// <summary>
        /// Gets or sets the appearance.
        /// </summary>
        public Span<byte> Appearance
        {
            get => this.data.Slice(14, 9);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the server successfully processed a character creation request.
    /// Causes reaction on client side: The new character is shown in the character list
    /// </summary>
    public readonly ref struct CharacterCreationSuccessful
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterCreationSuccessful"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterCreationSuccessful(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterCreationSuccessful"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterCreationSuccessful(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Success = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 42;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[4..].GetBoolean();
            set => this.data[4..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the character name.
        /// </summary>
        public string CharacterName
        {
            get => this.data.ExtractString(5, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(5, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the character slot.
        /// </summary>
        public byte CharacterSlot
        {
            get => this.data[15];
            set => this.data[15] = value;
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => ReadUInt16LittleEndian(this.data[16..]);
            set => WriteUInt16LittleEndian(this.data[16..], value);
        }

        /// <summary>
        /// Gets or sets the class.
        /// </summary>
        public CharacterClassNumber Class
        {
            get => (CharacterClassNumber)this.data[18..].GetByteValue(8, 3);
            set => this.data[18..].SetByteValue((byte)value, 8, 3);
        }

        /// <summary>
        /// Gets or sets the character status.
        /// </summary>
        public byte CharacterStatus
        {
            get => this.data[19];
            set => this.data[19] = value;
        }

        /// <summary>
        /// Gets or sets the preview data.
        /// </summary>
        public Span<byte> PreviewData
        {
            get => this.data.Slice(20);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterCreationSuccessful"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterCreationSuccessful(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterCreationSuccessful"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterCreationSuccessful packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="PreviewData"/>.
        /// </summary>
        /// <param name="previewDataLength">The length in bytes of <see cref="PreviewData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int previewDataLength) => previewDataLength + 20;
    }


    /// <summary>
    /// Is sent by the server when: After the server processed a character creation request without success.
    /// Causes reaction on client side: A message is shown that it failed. 
    /// </summary>
    public readonly ref struct CharacterCreationFailed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterCreationFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterCreationFailed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterCreationFailed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterCreationFailed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterCreationFailed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterCreationFailed(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterCreationFailed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterCreationFailed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The character respawned after death.
    /// Causes reaction on client side: The character respawns with the specified attributes at the specified map.
    /// </summary>
    public readonly ref struct RespawnAfterDeath075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="RespawnAfterDeath075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public RespawnAfterDeath075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RespawnAfterDeath075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private RespawnAfterDeath075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x04;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 20;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the position x.
        /// </summary>
        public byte PositionX
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the position y.
        /// </summary>
        public byte PositionY
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the map number.
        /// </summary>
        public byte MapNumber
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the direction.
        /// </summary>
        public byte Direction
        {
            get => this.data[7];
            set => this.data[7] = value;
        }

        /// <summary>
        /// Gets or sets the current health.
        /// </summary>
        public ushort CurrentHealth
        {
            get => ReadUInt16LittleEndian(this.data[8..]);
            set => WriteUInt16LittleEndian(this.data[8..], value);
        }

        /// <summary>
        /// Gets or sets the current mana.
        /// </summary>
        public ushort CurrentMana
        {
            get => ReadUInt16LittleEndian(this.data[10..]);
            set => WriteUInt16LittleEndian(this.data[10..], value);
        }

        /// <summary>
        /// Gets or sets the experience.
        /// </summary>
        public uint Experience
        {
            get => ReadUInt32LittleEndian(this.data[12..]);
            set => WriteUInt32LittleEndian(this.data[12..], value);
        }

        /// <summary>
        /// Gets or sets the money.
        /// </summary>
        public uint Money
        {
            get => ReadUInt32LittleEndian(this.data[16..]);
            set => WriteUInt32LittleEndian(this.data[16..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="RespawnAfterDeath075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator RespawnAfterDeath075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="RespawnAfterDeath075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(RespawnAfterDeath075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The character got damaged by being poisoned on old client versions.
    /// Causes reaction on client side: Removes the damage from the health without showing a damage number.
    /// </summary>
    public readonly ref struct PoisonDamage
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PoisonDamage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PoisonDamage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PoisonDamage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PoisonDamage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x07;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the health damage.
        /// </summary>
        public ushort HealthDamage
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the current shield.
        /// </summary>
        public ushort CurrentShield
        {
            get => ReadUInt16BigEndian(this.data[6..]);
            set => WriteUInt16BigEndian(this.data[6..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PoisonDamage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PoisonDamage(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PoisonDamage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PoisonDamage packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a the hero state of an observed character changed.
    /// Causes reaction on client side: The color of the name of the character is changed accordingly and a message is shown.
    /// </summary>
    public readonly ref struct HeroStateChanged
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="HeroStateChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public HeroStateChanged(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="HeroStateChanged"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private HeroStateChanged(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x08;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[4..]);
            set => WriteUInt16BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the new state.
        /// </summary>
        public CharacterHeroState NewState
        {
            get => (CharacterHeroState)this.data[6];
            set => this.data[6] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="HeroStateChanged"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator HeroStateChanged(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="HeroStateChanged"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(HeroStateChanged packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </summary>
    public readonly ref struct SkillAdded
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillAdded(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillAdded(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Flag = 0xFE;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the flag.
        /// </summary>
        public byte Flag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the skill number.
        /// </summary>
        public ushort SkillNumber
        {
            get => ReadUInt16LittleEndian(this.data[7..]);
            set => WriteUInt16LittleEndian(this.data[7..], value);
        }

        /// <summary>
        /// Gets or sets the skill level.
        /// </summary>
        public byte SkillLevel
        {
            get => this.data[9];
            set => this.data[9] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAdded"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillAdded(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillAdded"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillAdded packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </summary>
    public readonly ref struct SkillRemoved
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillRemoved(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillRemoved"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillRemoved(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Flag = 0xFF;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the flag.
        /// </summary>
        public byte Flag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the skill number.
        /// </summary>
        public ushort SkillNumber
        {
            get => ReadUInt16LittleEndian(this.data[7..]);
            set => WriteUInt16LittleEndian(this.data[7..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillRemoved"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillRemoved(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillRemoved"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillRemoved packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Usually, when the player entered the game with a character. When skills get added or removed, this message is sent as well, but with a misleading count.
    /// Causes reaction on client side: The skill list gets initialized.
    /// </summary>
    public readonly ref struct SkillListUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillListUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillListUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets mixed usage: Skill list count (when list). 0xFE when adding a skill, 0xFF when removing a Skill.
        /// </summary>
        public byte Count
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="SkillEntry"/> of the specified index.
        /// </summary>
        public SkillEntry this[int index] => new (this.data[(6 + index * SkillEntry.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillListUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillListUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillListUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillListUpdate packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="SkillEntry"/>.
        /// </summary>
        /// <param name="skillsCount">The count of <see cref="SkillEntry"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int skillsCount) => skillsCount * SkillEntry.Length + 6;


    /// <summary>
    /// Structure for a skill entry of the skill list..
    /// </summary>
    public readonly ref struct SkillEntry
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillEntry"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillEntry(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the skill number.
        /// </summary>
        public ushort SkillNumber
        {
            get => ReadUInt16LittleEndian(this.data[1..]);
            set => WriteUInt16LittleEndian(this.data[1..], value);
        }

        /// <summary>
        /// Gets or sets the skill level.
        /// </summary>
        public byte SkillLevel
        {
            get => this.data[2];
            set => this.data[2] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </summary>
    public readonly ref struct SkillAdded075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAdded075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillAdded075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillAdded075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillAdded075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Flag = 1;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the flag.
        /// </summary>
        public byte Flag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the skill number and level.
        /// </summary>
        public ushort SkillNumberAndLevel
        {
            get => ReadUInt16BigEndian(this.data[6..]);
            set => WriteUInt16BigEndian(this.data[6..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillAdded075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillAdded075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillAdded075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillAdded075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </summary>
    public readonly ref struct SkillRemoved075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillRemoved075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillRemoved075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillRemoved075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillRemoved075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Flag = 0;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the flag.
        /// </summary>
        public byte Flag
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the skill number and level.
        /// </summary>
        public ushort SkillNumberAndLevel
        {
            get => ReadUInt16BigEndian(this.data[6..]);
            set => WriteUInt16BigEndian(this.data[6..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillRemoved075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillRemoved075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillRemoved075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillRemoved075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Usually, when the player entered the game with a character. When skills get added or removed, this message is sent as well, but with a misleading count.
    /// Causes reaction on client side: The skill list gets initialized.
    /// </summary>
    public readonly ref struct SkillListUpdate075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillListUpdate075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillListUpdate075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SkillListUpdate075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x11;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets mixed usage: Skill list count (when list). 0xFE when adding a skill, 0xFF when removing a Skill.
        /// </summary>
        public byte Count
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="SkillEntry"/> of the specified index.
        /// </summary>
        public SkillEntry this[int index] => new (this.data[(5 + index * SkillEntry.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SkillListUpdate075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SkillListUpdate075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SkillListUpdate075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SkillListUpdate075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="SkillEntry"/>.
        /// </summary>
        /// <param name="skillsCount">The count of <see cref="SkillEntry"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int skillsCount) => skillsCount * SkillEntry.Length + 5;


    /// <summary>
    /// Structure for a skill entry of the skill list..
    /// </summary>
    public readonly ref struct SkillEntry
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SkillEntry"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SkillEntry(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 3;

        /// <summary>
        /// Gets or sets the skill index.
        /// </summary>
        public byte SkillIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the skill number and level.
        /// </summary>
        public ushort SkillNumberAndLevel
        {
            get => ReadUInt16BigEndian(this.data[1..]);
            set => WriteUInt16BigEndian(this.data[1..], value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the client focused the character successfully on the server side.
    /// Causes reaction on client side: The client highlights the focused character.
    /// </summary>
    public readonly ref struct CharacterFocused
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterFocused"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterFocused(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterFocused"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterFocused(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x15;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 15;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the character name.
        /// </summary>
        public string CharacterName
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterFocused"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterFocused(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterFocused"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterFocused packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the server processed a character stat increase request packet.
    /// Causes reaction on client side: If it was successful, adds a point to the requested stat type.
    /// </summary>
    public readonly ref struct CharacterStatIncreaseResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterStatIncreaseResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterStatIncreaseResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x06;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[4..].GetBoolean(4);
            set => this.data[4..].SetBoolean(value, 4);
        }

        /// <summary>
        /// Gets or sets the attribute.
        /// </summary>
        public CharacterStatAttribute Attribute
        {
            get => (CharacterStatAttribute)this.data[4..].GetByteValue(4, 0);
            set => this.data[4..].SetByteValue((byte)value, 4, 0);
        }

        /// <summary>
        /// Gets or sets the updated dependent maximum stat.
        /// </summary>
        public ushort UpdatedDependentMaximumStat
        {
            get => ReadUInt16LittleEndian(this.data[6..]);
            set => WriteUInt16LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets the updated maximum shield.
        /// </summary>
        public ushort UpdatedMaximumShield
        {
            get => ReadUInt16LittleEndian(this.data[8..]);
            set => WriteUInt16LittleEndian(this.data[8..], value);
        }

        /// <summary>
        /// Gets or sets the updated maximum ability.
        /// </summary>
        public ushort UpdatedMaximumAbility
        {
            get => ReadUInt16LittleEndian(this.data[10..]);
            set => WriteUInt16LittleEndian(this.data[10..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterStatIncreaseResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterStatIncreaseResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterStatIncreaseResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterStatIncreaseResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the server processed a character delete response of the client.
    /// Causes reaction on client side: If successful, the character is deleted from the character selection screen. Otherwise, a message is shown.
    /// </summary>
    public readonly ref struct CharacterDeleteResponse
    {
        /// <summary>
        /// Result of a character delete request.
        /// </summary>
        public enum CharacterDeleteResult
        {
            /// <summary>
            /// Deleting was not successful
            /// </summary>
            Unsuccessful = 0,

            /// <summary>
            /// Deleting was successful
            /// </summary>
            Successful = 1,

            /// <summary>
            /// Deleting was not successful because a wrong security code was entered
            /// </summary>
            WrongSecurityCode = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterDeleteResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterDeleteResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterDeleteResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterDeleteResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x02;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public CharacterDeleteResponse.CharacterDeleteResult Result
        {
            get => (CharacterDeleteResult)this.data[4];
            set => this.data[4] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterDeleteResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterDeleteResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterDeleteResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterDeleteResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a character leveled up.
    /// Causes reaction on client side: Updates the level (and other related stats) in the game client and shows an effect.
    /// </summary>
    public readonly ref struct CharacterLevelUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterLevelUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterLevelUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x05;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 24;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public ushort Level
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the level up points.
        /// </summary>
        public ushort LevelUpPoints
        {
            get => ReadUInt16LittleEndian(this.data[6..]);
            set => WriteUInt16LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => ReadUInt16LittleEndian(this.data[8..]);
            set => WriteUInt16LittleEndian(this.data[8..], value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => ReadUInt16LittleEndian(this.data[10..]);
            set => WriteUInt16LittleEndian(this.data[10..], value);
        }

        /// <summary>
        /// Gets or sets the maximum shield.
        /// </summary>
        public ushort MaximumShield
        {
            get => ReadUInt16LittleEndian(this.data[12..]);
            set => WriteUInt16LittleEndian(this.data[12..], value);
        }

        /// <summary>
        /// Gets or sets the maximum ability.
        /// </summary>
        public ushort MaximumAbility
        {
            get => ReadUInt16LittleEndian(this.data[14..]);
            set => WriteUInt16LittleEndian(this.data[14..], value);
        }

        /// <summary>
        /// Gets or sets the fruit points.
        /// </summary>
        public ushort FruitPoints
        {
            get => ReadUInt16LittleEndian(this.data[16..]);
            set => WriteUInt16LittleEndian(this.data[16..], value);
        }

        /// <summary>
        /// Gets or sets the maximum fruit points.
        /// </summary>
        public ushort MaximumFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data[18..]);
            set => WriteUInt16LittleEndian(this.data[18..], value);
        }

        /// <summary>
        /// Gets or sets the negative fruit points.
        /// </summary>
        public ushort NegativeFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data[20..]);
            set => WriteUInt16LittleEndian(this.data[20..], value);
        }

        /// <summary>
        /// Gets or sets the maximum negative fruit points.
        /// </summary>
        public ushort MaximumNegativeFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data[22..]);
            set => WriteUInt16LittleEndian(this.data[22..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterLevelUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterLevelUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterLevelUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterLevelUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the character was selected by the player and entered the game.
    /// Causes reaction on client side: The characters enters the game world.
    /// </summary>
    public readonly ref struct CharacterInformation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterInformation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterInformation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x03;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 72;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the x.
        /// </summary>
        public byte X
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the y.
        /// </summary>
        public byte Y
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the map id.
        /// </summary>
        public ushort MapId
        {
            get => ReadUInt16LittleEndian(this.data[6..]);
            set => WriteUInt16LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets the current experience.
        /// </summary>
        public ulong CurrentExperience
        {
            get => ReadUInt64BigEndian(this.data[8..]);
            set => WriteUInt64BigEndian(this.data[8..], value);
        }

        /// <summary>
        /// Gets or sets the experience for next level.
        /// </summary>
        public ulong ExperienceForNextLevel
        {
            get => ReadUInt64BigEndian(this.data[16..]);
            set => WriteUInt64BigEndian(this.data[16..], value);
        }

        /// <summary>
        /// Gets or sets the level up points.
        /// </summary>
        public ushort LevelUpPoints
        {
            get => ReadUInt16LittleEndian(this.data[24..]);
            set => WriteUInt16LittleEndian(this.data[24..], value);
        }

        /// <summary>
        /// Gets or sets the strength.
        /// </summary>
        public ushort Strength
        {
            get => ReadUInt16LittleEndian(this.data[26..]);
            set => WriteUInt16LittleEndian(this.data[26..], value);
        }

        /// <summary>
        /// Gets or sets the agility.
        /// </summary>
        public ushort Agility
        {
            get => ReadUInt16LittleEndian(this.data[28..]);
            set => WriteUInt16LittleEndian(this.data[28..], value);
        }

        /// <summary>
        /// Gets or sets the vitality.
        /// </summary>
        public ushort Vitality
        {
            get => ReadUInt16LittleEndian(this.data[30..]);
            set => WriteUInt16LittleEndian(this.data[30..], value);
        }

        /// <summary>
        /// Gets or sets the energy.
        /// </summary>
        public ushort Energy
        {
            get => ReadUInt16LittleEndian(this.data[32..]);
            set => WriteUInt16LittleEndian(this.data[32..], value);
        }

        /// <summary>
        /// Gets or sets the current health.
        /// </summary>
        public ushort CurrentHealth
        {
            get => ReadUInt16LittleEndian(this.data[34..]);
            set => WriteUInt16LittleEndian(this.data[34..], value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => ReadUInt16LittleEndian(this.data[36..]);
            set => WriteUInt16LittleEndian(this.data[36..], value);
        }

        /// <summary>
        /// Gets or sets the current mana.
        /// </summary>
        public ushort CurrentMana
        {
            get => ReadUInt16LittleEndian(this.data[38..]);
            set => WriteUInt16LittleEndian(this.data[38..], value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => ReadUInt16LittleEndian(this.data[40..]);
            set => WriteUInt16LittleEndian(this.data[40..], value);
        }

        /// <summary>
        /// Gets or sets the current shield.
        /// </summary>
        public ushort CurrentShield
        {
            get => ReadUInt16LittleEndian(this.data[42..]);
            set => WriteUInt16LittleEndian(this.data[42..], value);
        }

        /// <summary>
        /// Gets or sets the maximum shield.
        /// </summary>
        public ushort MaximumShield
        {
            get => ReadUInt16LittleEndian(this.data[44..]);
            set => WriteUInt16LittleEndian(this.data[44..], value);
        }

        /// <summary>
        /// Gets or sets the current ability.
        /// </summary>
        public ushort CurrentAbility
        {
            get => ReadUInt16LittleEndian(this.data[46..]);
            set => WriteUInt16LittleEndian(this.data[46..], value);
        }

        /// <summary>
        /// Gets or sets the maximum ability.
        /// </summary>
        public ushort MaximumAbility
        {
            get => ReadUInt16LittleEndian(this.data[48..]);
            set => WriteUInt16LittleEndian(this.data[48..], value);
        }

        /// <summary>
        /// Gets or sets the money.
        /// </summary>
        public uint Money
        {
            get => ReadUInt32LittleEndian(this.data[52..]);
            set => WriteUInt32LittleEndian(this.data[52..], value);
        }

        /// <summary>
        /// Gets or sets the hero state.
        /// </summary>
        public CharacterHeroState HeroState
        {
            get => (CharacterHeroState)this.data[56];
            set => this.data[56] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the status.
        /// </summary>
        public CharacterStatus Status
        {
            get => (CharacterStatus)this.data[57];
            set => this.data[57] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the used fruit points.
        /// </summary>
        public ushort UsedFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data[58..]);
            set => WriteUInt16LittleEndian(this.data[58..], value);
        }

        /// <summary>
        /// Gets or sets the max fruit points.
        /// </summary>
        public ushort MaxFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data[60..]);
            set => WriteUInt16LittleEndian(this.data[60..], value);
        }

        /// <summary>
        /// Gets or sets the leadership.
        /// </summary>
        public ushort Leadership
        {
            get => ReadUInt16LittleEndian(this.data[62..]);
            set => WriteUInt16LittleEndian(this.data[62..], value);
        }

        /// <summary>
        /// Gets or sets the used negative fruit points.
        /// </summary>
        public ushort UsedNegativeFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data[64..]);
            set => WriteUInt16LittleEndian(this.data[64..], value);
        }

        /// <summary>
        /// Gets or sets the max negative fruit points.
        /// </summary>
        public ushort MaxNegativeFruitPoints
        {
            get => ReadUInt16LittleEndian(this.data[66..]);
            set => WriteUInt16LittleEndian(this.data[66..], value);
        }

        /// <summary>
        /// Gets or sets the is vault extended.
        /// </summary>
        public bool IsVaultExtended
        {
            get => this.data[68..].GetBoolean();
            set => this.data[68..].SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInformation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterInformation(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterInformation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterInformation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the character was selected by the player and entered the game.
    /// Causes reaction on client side: The characters enters the game world.
    /// </summary>
    public readonly ref struct CharacterInformation075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterInformation075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInformation075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterInformation075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x03;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 42;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the x.
        /// </summary>
        public byte X
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the y.
        /// </summary>
        public byte Y
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the map id.
        /// </summary>
        public byte MapId
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the current experience.
        /// </summary>
        public uint CurrentExperience
        {
            get => ReadUInt32LittleEndian(this.data[8..]);
            set => WriteUInt32LittleEndian(this.data[8..], value);
        }

        /// <summary>
        /// Gets or sets the experience for next level.
        /// </summary>
        public uint ExperienceForNextLevel
        {
            get => ReadUInt32LittleEndian(this.data[12..]);
            set => WriteUInt32LittleEndian(this.data[12..], value);
        }

        /// <summary>
        /// Gets or sets the level up points.
        /// </summary>
        public ushort LevelUpPoints
        {
            get => ReadUInt16LittleEndian(this.data[16..]);
            set => WriteUInt16LittleEndian(this.data[16..], value);
        }

        /// <summary>
        /// Gets or sets the strength.
        /// </summary>
        public ushort Strength
        {
            get => ReadUInt16LittleEndian(this.data[18..]);
            set => WriteUInt16LittleEndian(this.data[18..], value);
        }

        /// <summary>
        /// Gets or sets the agility.
        /// </summary>
        public ushort Agility
        {
            get => ReadUInt16LittleEndian(this.data[20..]);
            set => WriteUInt16LittleEndian(this.data[20..], value);
        }

        /// <summary>
        /// Gets or sets the vitality.
        /// </summary>
        public ushort Vitality
        {
            get => ReadUInt16LittleEndian(this.data[22..]);
            set => WriteUInt16LittleEndian(this.data[22..], value);
        }

        /// <summary>
        /// Gets or sets the energy.
        /// </summary>
        public ushort Energy
        {
            get => ReadUInt16LittleEndian(this.data[24..]);
            set => WriteUInt16LittleEndian(this.data[24..], value);
        }

        /// <summary>
        /// Gets or sets the current health.
        /// </summary>
        public ushort CurrentHealth
        {
            get => ReadUInt16LittleEndian(this.data[26..]);
            set => WriteUInt16LittleEndian(this.data[26..], value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => ReadUInt16LittleEndian(this.data[28..]);
            set => WriteUInt16LittleEndian(this.data[28..], value);
        }

        /// <summary>
        /// Gets or sets the current mana.
        /// </summary>
        public ushort CurrentMana
        {
            get => ReadUInt16LittleEndian(this.data[30..]);
            set => WriteUInt16LittleEndian(this.data[30..], value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => ReadUInt16LittleEndian(this.data[32..]);
            set => WriteUInt16LittleEndian(this.data[32..], value);
        }

        /// <summary>
        /// Gets or sets the money.
        /// </summary>
        public uint Money
        {
            get => ReadUInt32LittleEndian(this.data[36..]);
            set => WriteUInt32LittleEndian(this.data[36..], value);
        }

        /// <summary>
        /// Gets or sets the hero state.
        /// </summary>
        public CharacterHeroState HeroState
        {
            get => (CharacterHeroState)this.data[40];
            set => this.data[40] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the status.
        /// </summary>
        public CharacterStatus Status
        {
            get => (CharacterStatus)this.data[41];
            set => this.data[41] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInformation075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterInformation075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterInformation075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterInformation075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player entered the game or finished a trade.
    /// Causes reaction on client side: The user interface of the inventory is initialized with all of its items.
    /// </summary>
    public readonly ref struct CharacterInventory
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInventory"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CharacterInventory(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CharacterInventory"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CharacterInventory(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC4;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x10;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C4HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the item count.
        /// </summary>
        public byte ItemCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets the <see cref="StoredItem"/> of the specified index.
        /// </summary>
        public StoredItem this[int index, int storedItemLength] => new (this.data[(6 + index * storedItemLength)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CharacterInventory"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CharacterInventory(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CharacterInventory"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CharacterInventory packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="StoredItem"/> and it's size.
        /// </summary>
        /// <param name="itemsCount">The count of <see cref="StoredItem"/> from which the size will be calculated.</param>
        /// <param name="structLength">The length of <see cref="StoredItem"/> from which the size will be calculated.</param>
          public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 6;
    }


    /// <summary>
    /// Is sent by the server when: An item in the inventory got upgraded by the player, e.g. by applying a jewel.
    /// Causes reaction on client side: The item is updated on the user interface.
    /// </summary>
    public readonly ref struct InventoryItemUpgraded
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="InventoryItemUpgraded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public InventoryItemUpgraded(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InventoryItemUpgraded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private InventoryItemUpgraded(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x14;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the inventory slot.
        /// </summary>
        public byte InventorySlot
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(5);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="InventoryItemUpgraded"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator InventoryItemUpgraded(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="InventoryItemUpgraded"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(InventoryItemUpgraded packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
    }


    /// <summary>
    /// Is sent by the server when: When health of a summoned monster (Elf Skill) changed.
    /// Causes reaction on client side: The health is updated on the user interface.
    /// </summary>
    public readonly ref struct SummonHealthUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SummonHealthUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SummonHealthUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SummonHealthUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SummonHealthUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x20;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the health percent.
        /// </summary>
        public byte HealthPercent
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SummonHealthUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SummonHealthUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SummonHealthUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SummonHealthUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Every second during a guild soccer match.
    /// Causes reaction on client side: The time is updated on the user interface.
    /// </summary>
    public readonly ref struct GuildSoccerTimeUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildSoccerTimeUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildSoccerTimeUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildSoccerTimeUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildSoccerTimeUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x22;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the seconds.
        /// </summary>
        public ushort Seconds
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildSoccerTimeUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildSoccerTimeUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildSoccerTimeUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildSoccerTimeUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Whenever the score of the soccer game changed, and at the beginning of the match.
    /// Causes reaction on client side: The score is updated on the user interface.
    /// </summary>
    public readonly ref struct GuildSoccerScoreUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildSoccerScoreUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildSoccerScoreUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildSoccerScoreUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildSoccerScoreUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x23;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 22;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the red team name.
        /// </summary>
        public string RedTeamName
        {
            get => this.data.ExtractString(4, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the red team goals.
        /// </summary>
        public byte RedTeamGoals
        {
            get => this.data[12];
            set => this.data[12] = value;
        }

        /// <summary>
        /// Gets or sets the blue team name.
        /// </summary>
        public string BlueTeamName
        {
            get => this.data.ExtractString(13, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(13, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the blue team goals.
        /// </summary>
        public byte BlueTeamGoals
        {
            get => this.data[21];
            set => this.data[21] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildSoccerScoreUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildSoccerScoreUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildSoccerScoreUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildSoccerScoreUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After entering the game with a master class character.
    /// Causes reaction on client side: The master related data is available.
    /// </summary>
    public readonly ref struct MasterStatsUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterStatsUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MasterStatsUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterStatsUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MasterStatsUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x50;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 32;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the master level.
        /// </summary>
        public ushort MasterLevel
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the master experience.
        /// </summary>
        public ulong MasterExperience
        {
            get => ReadUInt64BigEndian(this.data[6..]);
            set => WriteUInt64BigEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets the master experience of next level.
        /// </summary>
        public ulong MasterExperienceOfNextLevel
        {
            get => ReadUInt64BigEndian(this.data[14..]);
            set => WriteUInt64BigEndian(this.data[14..], value);
        }

        /// <summary>
        /// Gets or sets the master level up points.
        /// </summary>
        public ushort MasterLevelUpPoints
        {
            get => ReadUInt16LittleEndian(this.data[22..]);
            set => WriteUInt16LittleEndian(this.data[22..], value);
        }

        /// <summary>
        /// Gets or sets the maximum health.
        /// </summary>
        public ushort MaximumHealth
        {
            get => ReadUInt16LittleEndian(this.data[24..]);
            set => WriteUInt16LittleEndian(this.data[24..], value);
        }

        /// <summary>
        /// Gets or sets the maximum mana.
        /// </summary>
        public ushort MaximumMana
        {
            get => ReadUInt16LittleEndian(this.data[26..]);
            set => WriteUInt16LittleEndian(this.data[26..], value);
        }

        /// <summary>
        /// Gets or sets the maximum shield.
        /// </summary>
        public ushort MaximumShield
        {
            get => ReadUInt16LittleEndian(this.data[28..]);
            set => WriteUInt16LittleEndian(this.data[28..], value);
        }

        /// <summary>
        /// Gets or sets the maximum ability.
        /// </summary>
        public ushort MaximumAbility
        {
            get => ReadUInt16LittleEndian(this.data[30..]);
            set => WriteUInt16LittleEndian(this.data[30..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterStatsUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MasterStatsUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MasterStatsUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MasterStatsUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a master skill level has been changed (usually increased).
    /// Causes reaction on client side: The level is updated in the master skill tree.
    /// </summary>
    public readonly ref struct MasterSkillLevelUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MasterSkillLevelUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillLevelUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MasterSkillLevelUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x52;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 28;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[4..].GetBoolean();
            set => this.data[4..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the master level up points.
        /// </summary>
        public ushort MasterLevelUpPoints
        {
            get => ReadUInt16LittleEndian(this.data[6..]);
            set => WriteUInt16LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets the index of the master skill on the clients master skill tree for the given character class.
        /// </summary>
        public byte MasterSkillIndex
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the master skill number.
        /// </summary>
        public ushort MasterSkillNumber
        {
            get => ReadUInt16LittleEndian(this.data[12..]);
            set => WriteUInt16LittleEndian(this.data[12..], value);
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public byte Level
        {
            get => this.data[16];
            set => this.data[16] = value;
        }

        /// <summary>
        /// Gets or sets the display value.
        /// </summary>
        public float DisplayValue
        {
            get => BitConverter.ToSingle(this.data[20..]);
            set => BitConverter.GetBytes(value).CopyTo(this.data[20..]);
        }

        /// <summary>
        /// Gets or sets the display value of next level.
        /// </summary>
        public float DisplayValueOfNextLevel
        {
            get => BitConverter.ToSingle(this.data[24..]);
            set => BitConverter.GetBytes(value).CopyTo(this.data[24..]);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterSkillLevelUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MasterSkillLevelUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MasterSkillLevelUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MasterSkillLevelUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: Usually after entering the game with a master character.
    /// Causes reaction on client side: The data is available in the master skill tree.
    /// </summary>
    public readonly ref struct MasterSkillList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MasterSkillList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MasterSkillList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x53;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the master skill count.
        /// </summary>
        public uint MasterSkillCount
        {
            get => ReadUInt32LittleEndian(this.data[8..]);
            set => WriteUInt32LittleEndian(this.data[8..], value);
        }

        /// <summary>
        /// Gets the <see cref="MasterSkillEntry"/> of the specified index.
        /// </summary>
        public MasterSkillEntry this[int index] => new (this.data[(12 + index * MasterSkillEntry.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MasterSkillList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MasterSkillList(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MasterSkillList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MasterSkillList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="MasterSkillEntry"/>.
        /// </summary>
        /// <param name="skillsCount">The count of <see cref="MasterSkillEntry"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int skillsCount) => skillsCount * MasterSkillEntry.Length + 12;


    /// <summary>
    /// An entry in the master skill list..
    /// </summary>
    public readonly ref struct MasterSkillEntry
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MasterSkillEntry"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MasterSkillEntry(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets or sets the index of the master skill on the clients master skill tree for the given character class.
        /// </summary>
        public byte MasterSkillIndex
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public byte Level
        {
            get => this.data[1];
            set => this.data[1] = value;
        }

        /// <summary>
        /// Gets or sets the display value.
        /// </summary>
        public float DisplayValue
        {
            get => BitConverter.ToSingle(this.data[4..]);
            set => BitConverter.GetBytes(value).CopyTo(this.data[4..]);
        }

        /// <summary>
        /// Gets or sets the display value of next level.
        /// </summary>
        public float DisplayValueOfNextLevel
        {
            get => BitConverter.ToSingle(this.data[8..]);
            set => BitConverter.GetBytes(value).CopyTo(this.data[8..]);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct ServerMessage
    {
        /// <summary>
        /// Defines a type of a server message.
        /// </summary>
        public enum MessageType
        {
            /// <summary>
            /// The message is shown as centered golden message in the client.
            /// </summary>
            GoldenCenter = 0,

            /// <summary>
            /// The message is shown as a blue system message.
            /// </summary>
            BlueNormal = 1,

            /// <summary>
            /// The message is a guild notice, centered in green.
            /// </summary>
            GuildNotice = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ServerMessage(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerMessage"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ServerMessage(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x0D;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public ServerMessage.MessageType Type
        {
            get => (MessageType)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(4, this.data.Length - 4, System.Text.Encoding.UTF8);
            set => this.data.Slice(4).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerMessage"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ServerMessage(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ServerMessage"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ServerMessage packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 4;
    }


    /// <summary>
    /// Is sent by the server when: A player requested to join a guild. This message is sent then to the guild master.
    /// Causes reaction on client side: The guild master gets a message box with the request popping up.
    /// </summary>
    public readonly ref struct GuildJoinRequest
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildJoinRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildJoinRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildJoinRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildJoinRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x50;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the requester id.
        /// </summary>
        public ushort RequesterId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildJoinRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildJoinRequest(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildJoinRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildJoinRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a guild master responded to a request of a player to join his guild. This message is sent back to the requesting player.
    /// Causes reaction on client side: The requester gets a corresponding message showing.
    /// </summary>
    public readonly ref struct GuildJoinResponse
    {
        /// <summary>
        /// The result of the guild join request.
        /// </summary>
        public enum GuildJoinRequestResult
        {
            /// <summary>
            /// Refused by the guild master.
            /// </summary>
            Refused = 0,

            /// <summary>
            /// Accepted by the guild master.
            /// </summary>
            Accepted = 1,

            /// <summary>
            /// The guild is full.
            /// </summary>
            GuildFull = 2,

            /// <summary>
            /// The guild master is disconnected.
            /// </summary>
            Disconnected = 3,

            /// <summary>
            /// The requested player is not the guild master of its guild.
            /// </summary>
            NotTheGuildMaster = 4,

            /// <summary>
            /// The player already has a guild.
            /// </summary>
            AlreadyHaveGuild = 5,

            /// <summary>
            /// he guild master or the requesting player is busy, e.g. by another request or by an ongoing guild war.
            /// </summary>
            GuildMasterOrRequesterIsBusy = 6,

            /// <summary>
            /// The requesting player needs a minimum level of 6.
            /// </summary>
            MinimumLevel6 = 7,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildJoinResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildJoinResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildJoinResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildJoinResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x51;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public GuildJoinResponse.GuildJoinRequestResult Result
        {
            get => (GuildJoinRequestResult)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildJoinResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildJoinResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildJoinResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildJoinResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a game client requested the list of players of his guild, which is usually the case when the player opens the guild dialog at the game client.
    /// Causes reaction on client side: The list of player is available at the client.
    /// </summary>
    public readonly ref struct GuildList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x52;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the is in guild.
        /// </summary>
        public bool IsInGuild
        {
            get => this.data[4..].GetBoolean();
            set => this.data[4..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the guild member count.
        /// </summary>
        public byte GuildMemberCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the total score.
        /// </summary>
        public uint TotalScore
        {
            get => ReadUInt32LittleEndian(this.data[8..]);
            set => WriteUInt32LittleEndian(this.data[8..], value);
        }

        /// <summary>
        /// Gets or sets the current score.
        /// </summary>
        public byte CurrentScore
        {
            get => this.data[12];
            set => this.data[12] = value;
        }

        /// <summary>
        /// Gets or sets the rival guild name.
        /// </summary>
        public string RivalGuildName
        {
            get => this.data.ExtractString(13, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(13, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets the <see cref="GuildMember"/> of the specified index.
        /// </summary>
        public GuildMember this[int index] => new (this.data[(24 + index * GuildMember.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildList(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="GuildMember"/>.
        /// </summary>
        /// <param name="membersCount">The count of <see cref="GuildMember"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int membersCount) => membersCount * GuildMember.Length + 24;


    /// <summary>
    /// Contains the data of one guild member..
    /// </summary>
    public readonly ref struct GuildMember
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildMember"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildMember(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 13;

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(0, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the server id.
        /// </summary>
        public byte ServerId
        {
            get => this.data[10];
            set => this.data[10] = value;
        }

        /// <summary>
        /// Gets or sets the server id 2.
        /// </summary>
        public byte ServerId2
        {
            get => this.data[11];
            set => this.data[11] = value;
        }

        /// <summary>
        /// Gets or sets the role.
        /// </summary>
        public GuildMemberRole Role
        {
            get => (GuildMemberRole)this.data[12];
            set => this.data[12] = (byte)value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After a game client requested the list of players of his guild, which is usually the case when the player opens the guild dialog at the game client.
    /// Causes reaction on client side: The list of player is available at the client.
    /// </summary>
    public readonly ref struct GuildList075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildList075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildList075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildList075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildList075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x52;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the is in guild.
        /// </summary>
        public bool IsInGuild
        {
            get => this.data[4..].GetBoolean();
            set => this.data[4..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the guild member count.
        /// </summary>
        public byte GuildMemberCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the total score.
        /// </summary>
        public uint TotalScore
        {
            get => ReadUInt32LittleEndian(this.data[8..]);
            set => WriteUInt32LittleEndian(this.data[8..], value);
        }

        /// <summary>
        /// Gets or sets the current score.
        /// </summary>
        public byte CurrentScore
        {
            get => this.data[12];
            set => this.data[12] = value;
        }

        /// <summary>
        /// Gets the <see cref="GuildMember"/> of the specified index.
        /// </summary>
        public GuildMember this[int index] => new (this.data[(13 + index * GuildMember.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildList075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildList075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildList075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildList075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="GuildMember"/>.
        /// </summary>
        /// <param name="membersCount">The count of <see cref="GuildMember"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int membersCount) => membersCount * GuildMember.Length + 13;


    /// <summary>
    /// Contains the data of one guild member..
    /// </summary>
    public readonly ref struct GuildMember
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildMember"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildMember(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(0, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the server id.
        /// </summary>
        public byte ServerId
        {
            get => this.data[10];
            set => this.data[10] = value;
        }

        /// <summary>
        /// Gets or sets the server id 2.
        /// </summary>
        public byte ServerId2
        {
            get => this.data[11];
            set => this.data[11] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After a guild master sent a request to kick a player from its guild and the server processed this request.
    /// Causes reaction on client side: The client shows a message depending on the result.
    /// </summary>
    public readonly ref struct GuildKickResponse
    {
        /// <summary>
        /// The result of the guild kick request.
        /// </summary>
        public enum GuildKickSuccess
        {
            /// <summary>
            /// The kick request failed because of an incorrect password.
            /// </summary>
            FailedPasswordIncorrect = 0,

            /// <summary>
            /// The kick request was successful.
            /// </summary>
            KickSucceeded = 1,

            /// <summary>
            /// The kick failed because player is not guild master.
            /// </summary>
            KickFailedBecausePlayerIsNotGuildMaster = 2,

            /// <summary>
            /// The kick request failed.
            /// </summary>
            Failed = 3,

            /// <summary>
            /// The guild has been disbanded.
            /// </summary>
            GuildDisband = 4,

            /// <summary>
            /// The guild member has been withdrawn.
            /// </summary>
            GuildMemberWithdrawn = 5,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildKickResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildKickResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildKickResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildKickResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x53;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public GuildKickResponse.GuildKickSuccess Result
        {
            get => (GuildKickSuccess)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildKickResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildKickResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildKickResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildKickResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a player started talking to the guild master NPC and the player is allowed to create a guild.
    /// Causes reaction on client side: The client shows the guild master dialog.
    /// </summary>
    public readonly ref struct ShowGuildMasterDialog
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ShowGuildMasterDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ShowGuildMasterDialog(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ShowGuildMasterDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ShowGuildMasterDialog(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x54;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 3;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ShowGuildMasterDialog"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ShowGuildMasterDialog(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ShowGuildMasterDialog"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ShowGuildMasterDialog packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a player started talking to the guild master NPC and the player proceeds to create a guild.
    /// Causes reaction on client side: The client shows the guild creation dialog.
    /// </summary>
    public readonly ref struct ShowGuildCreationDialog
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ShowGuildCreationDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ShowGuildCreationDialog(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ShowGuildCreationDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ShowGuildCreationDialog(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x55;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 3;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ShowGuildCreationDialog"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ShowGuildCreationDialog(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ShowGuildCreationDialog"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ShowGuildCreationDialog packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a player requested to create a guild at the guild master NPC.
    /// Causes reaction on client side: Depending on the result, a message is shown.
    /// </summary>
    public readonly ref struct GuildCreationResult
    {
        /// <summary>
        /// Defines a guild creation error.
        /// </summary>
        public enum GuildCreationErrorType
        {
            /// <summary>
            /// No error occured.
            /// </summary>
            None = 0,

            /// <summary>
            /// The requested guild name is already taken.
            /// </summary>
            GuildNameAlreadyTaken = 179,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildCreationResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildCreationResult(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildCreationResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildCreationResult(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x56;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[3..].GetBoolean();
            set => this.data[3..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the error.
        /// </summary>
        public GuildCreationResult.GuildCreationErrorType Error
        {
            get => (GuildCreationErrorType)this.data[4];
            set => this.data[4] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildCreationResult"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildCreationResult(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildCreationResult"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildCreationResult packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A player left a guild. This message is sent to the player and all surrounding players.
    /// Causes reaction on client side: The player is not longer shown as a guild member.
    /// </summary>
    public readonly ref struct GuildMemberLeftGuild
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildMemberLeftGuild"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildMemberLeftGuild(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildMemberLeftGuild"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildMemberLeftGuild(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x5D;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the is guild master.
        /// </summary>
        public bool IsGuildMaster
        {
            get => this.data[3..].GetBoolean(7);
            set => this.data[3..].SetBoolean(value, 7);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildMemberLeftGuild"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildMemberLeftGuild(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildMemberLeftGuild"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildMemberLeftGuild packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A guild master requested a guild war against another guild.
    /// Causes reaction on client side: The guild master of the other guild gets this request.
    /// </summary>
    public readonly ref struct GuildWarRequestResult
    {
        /// <summary>
        /// Describes the result of the guild war request.
        /// </summary>
        public enum RequestResult
        {
            /// <summary>
            /// Failed, guild not found.
            /// </summary>
            GuildNotFound = 0,

            /// <summary>
            /// Request has been sent to the guild master. Waiting for his answer.
            /// </summary>
            RequestSentToGuildMaster = 1,

            /// <summary>
            /// Failed, because the guild master is offline.
            /// </summary>
            GuildMasterOffline = 2,

            /// <summary>
            /// Failed, because player is not in a guild.
            /// </summary>
            NotInGuild = 3,

            /// <summary>
            /// The guild war couldn't be started, e.g. because the soccer arena is already in use.
            /// </summary>
            Failed = 4,

            /// <summary>
            /// Failed, because player is not the guild master.
            /// </summary>
            NotTheGuildMaster = 5,

            /// <summary>
            /// Failed, because the requested guild is already in a war.
            /// </summary>
            AlreadyInWar = 6,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildWarRequestResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildWarRequestResult(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildWarRequestResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildWarRequestResult(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x60;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public GuildWarRequestResult.RequestResult Result
        {
            get => (RequestResult)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildWarRequestResult"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildWarRequestResult(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildWarRequestResult"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildWarRequestResult packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A guild master requested a guild war against another guild.
    /// Causes reaction on client side: The guild master of the other guild gets this request.
    /// </summary>
    public readonly ref struct GuildWarRequest
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildWarRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildWarRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildWarRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildWarRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x61;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the guild name.
        /// </summary>
        public string GuildName
        {
            get => this.data.ExtractString(3, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public GuildWarType Type
        {
            get => (GuildWarType)this.data[11];
            set => this.data[11] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildWarRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildWarRequest(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildWarRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildWarRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A guild master requested a guild war against another guild.
    /// Causes reaction on client side: The guild master of the other guild gets this request.
    /// </summary>
    public readonly ref struct GuildWarDeclared
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildWarDeclared"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildWarDeclared(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildWarDeclared"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildWarDeclared(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x62;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 13;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the guild name.
        /// </summary>
        public string GuildName
        {
            get => this.data.ExtractString(3, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public GuildWarType Type
        {
            get => (GuildWarType)this.data[11];
            set => this.data[11] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the team code.
        /// </summary>
        public byte TeamCode
        {
            get => this.data[12];
            set => this.data[12] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildWarDeclared"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildWarDeclared(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildWarDeclared"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildWarDeclared packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The guild war ended.
    /// Causes reaction on client side: The guild war is shown as ended on the client side.
    /// </summary>
    public readonly ref struct GuildWarEnded
    {
        /// <summary>
        /// Describes the result of the guild war.
        /// </summary>
        public enum GuildWarResult
        {
            /// <summary>
            /// The war was lost.
            /// </summary>
            Lost = 0,

            /// <summary>
            /// The war was won.
            /// </summary>
            Won = 1,

            /// <summary>
            /// The war was cancelled by the other guild master.
            /// </summary>
            OtherGuildMasterCancelledWar = 2,

            /// <summary>
            /// The war was cancelled by the own guild master.
            /// </summary>
            CancelledWar = 3,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildWarEnded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildWarEnded(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildWarEnded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildWarEnded(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x63;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public GuildWarEnded.GuildWarResult Result
        {
            get => (GuildWarResult)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the guild name.
        /// </summary>
        public string GuildName
        {
            get => this.data.ExtractString(4, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildWarEnded"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildWarEnded(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildWarEnded"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildWarEnded packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The guild war score changed.
    /// Causes reaction on client side: The guild score is updated on the client side.
    /// </summary>
    public readonly ref struct GuildWarScoreUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildWarScoreUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildWarScoreUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildWarScoreUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildWarScoreUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                this.Type = 0;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x64;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the score of own guild.
        /// </summary>
        public byte ScoreOfOwnGuild
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the score of enemy guild.
        /// </summary>
        public byte ScoreOfEnemyGuild
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public byte Type
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildWarScoreUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildWarScoreUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildWarScoreUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildWarScoreUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The server wants to visibly assign a player to a guild, e.g. when two players met each other and one of them is a guild member.
    /// Causes reaction on client side: The players which belong to the guild are shown as guild players. If the game client doesn't met a player of this guild yet, it will send another request to get the guild information.
    /// </summary>
    public readonly ref struct AssignCharacterToGuild
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AssignCharacterToGuild"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AssignCharacterToGuild(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AssignCharacterToGuild"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AssignCharacterToGuild(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x65;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the player count.
        /// </summary>
        public byte PlayerCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="GuildMemberRelation"/> of the specified index.
        /// </summary>
        public GuildMemberRelation this[int index] => new (this.data[(5 + index * GuildMemberRelation.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AssignCharacterToGuild"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AssignCharacterToGuild(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AssignCharacterToGuild"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AssignCharacterToGuild packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="GuildMemberRelation"/>.
        /// </summary>
        /// <param name="membersCount">The count of <see cref="GuildMemberRelation"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int membersCount) => membersCount * GuildMemberRelation.Length + 5;


    /// <summary>
    /// Relation between a guild and a member..
    /// </summary>
    public readonly ref struct GuildMemberRelation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildMemberRelation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildMemberRelation(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets or sets the guild id.
        /// </summary>
        public uint GuildId
        {
            get => ReadUInt32LittleEndian(this.data);
            set => WriteUInt32LittleEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the role.
        /// </summary>
        public GuildMemberRole Role
        {
            get => (GuildMemberRole)this.data[4];
            set => this.data[4] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the is player appearing new.
        /// </summary>
        public bool IsPlayerAppearingNew
        {
            get => this.data[7..].GetBoolean(7);
            set => this.data[7..].SetBoolean(value, 7);
        }

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[7..]);
            set => WriteUInt16BigEndian(this.data[7..], value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: The server wants to visibly assign a player to a guild, e.g. when two players met each other and one of them is a guild member.
    /// Causes reaction on client side: The players which belong to the guild are shown as guild players. If the game client doesn't met a player of this guild yet, it will send another request to get the guild information.
    /// </summary>
    public readonly ref struct AssignCharacterToGuild075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AssignCharacterToGuild075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AssignCharacterToGuild075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AssignCharacterToGuild075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AssignCharacterToGuild075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x5B;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the player count.
        /// </summary>
        public byte PlayerCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="GuildMemberRelation"/> of the specified index.
        /// </summary>
        public GuildMemberRelation this[int index] => new (this.data[(5 + index * GuildMemberRelation.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AssignCharacterToGuild075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AssignCharacterToGuild075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AssignCharacterToGuild075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AssignCharacterToGuild075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="GuildMemberRelation"/>.
        /// </summary>
        /// <param name="membersCount">The count of <see cref="GuildMemberRelation"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int membersCount) => membersCount * GuildMemberRelation.Length + 5;


    /// <summary>
    /// Relation between a guild and a member..
    /// </summary>
    public readonly ref struct GuildMemberRelation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildMemberRelation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildMemberRelation(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the guild id.
        /// </summary>
        public ushort GuildId
        {
            get => ReadUInt16BigEndian(this.data[2..]);
            set => WriteUInt16BigEndian(this.data[2..], value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: A game client requested the (public) info of a guild, e.g. when it met a player of previously unknown guild.
    /// Causes reaction on client side: The players which belong to the guild are shown as guild players.
    /// </summary>
    public readonly ref struct GuildInformation
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildInformation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildInformation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x66;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 60;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the guild id.
        /// </summary>
        public uint GuildId
        {
            get => ReadUInt32LittleEndian(this.data[4..]);
            set => WriteUInt32LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the guild type.
        /// </summary>
        public byte GuildType
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the alliance guild name.
        /// </summary>
        public string AllianceGuildName
        {
            get => this.data.ExtractString(9, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(9, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the guild name.
        /// </summary>
        public string GuildName
        {
            get => this.data.ExtractString(17, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(17, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the logo.
        /// </summary>
        public Span<byte> Logo
        {
            get => this.data.Slice(25, 32);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildInformation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildInformation(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildInformation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildInformation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: A player went into the scope of one or more guild members.
    /// Causes reaction on client side: The players which belong to the guild are shown as guild players.
    /// </summary>
    public readonly ref struct GuildInformations075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildInformations075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildInformations075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildInformations075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private GuildInformations075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x5A;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the guild count.
        /// </summary>
        public byte GuildCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="GuildInfo"/> of the specified index.
        /// </summary>
        public GuildInfo this[int index] => new (this.data[(5 + index * GuildInfo.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="GuildInformations075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator GuildInformations075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="GuildInformations075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(GuildInformations075 packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="GuildInfo"/>.
        /// </summary>
        /// <param name="guildsCount">The count of <see cref="GuildInfo"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int guildsCount) => guildsCount * GuildInfo.Length + 5;


    /// <summary>
    /// Information about one guild..
    /// </summary>
    public readonly ref struct GuildInfo
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="GuildInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public GuildInfo(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 42;

        /// <summary>
        /// Gets or sets the guild id.
        /// </summary>
        public ushort GuildId
        {
            get => ReadUInt16BigEndian(this.data);
            set => WriteUInt16BigEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the guild name.
        /// </summary>
        public string GuildName
        {
            get => this.data.ExtractString(2, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(2, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the logo.
        /// </summary>
        public Span<byte> Logo
        {
            get => this.data.Slice(10, 32);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After a guild has been created. However, in OpenMU, we just send the GuildInformations075 message, because it works just the same.
    /// Causes reaction on client side: The players which belong to the guild are shown as guild players.
    /// </summary>
    public readonly ref struct SingleGuildInformation075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="SingleGuildInformation075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public SingleGuildInformation075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SingleGuildInformation075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private SingleGuildInformation075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x5C;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 45;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the guild id.
        /// </summary>
        public ushort GuildId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the guild name.
        /// </summary>
        public string GuildName
        {
            get => this.data.ExtractString(5, 8, System.Text.Encoding.UTF8);
            set => this.data.Slice(5, 8).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the logo.
        /// </summary>
        public Span<byte> Logo
        {
            get => this.data.Slice(13, 32);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="SingleGuildInformation075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator SingleGuildInformation075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="SingleGuildInformation075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(SingleGuildInformation075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to move money between the vault and inventory.
    /// Causes reaction on client side: The game client updates the money values of vault and inventory.
    /// </summary>
    public readonly ref struct VaultMoneyUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultMoneyUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public VaultMoneyUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultMoneyUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private VaultMoneyUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x81;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[3..].GetBoolean();
            set => this.data[3..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the vault money.
        /// </summary>
        public uint VaultMoney
        {
            get => ReadUInt32LittleEndian(this.data[4..]);
            set => WriteUInt32LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the inventory money.
        /// </summary>
        public uint InventoryMoney
        {
            get => ReadUInt32LittleEndian(this.data[8..]);
            set => WriteUInt32LittleEndian(this.data[8..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="VaultMoneyUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator VaultMoneyUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="VaultMoneyUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(VaultMoneyUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to close the vault, this confirmation is sent back to the client.
    /// Causes reaction on client side: The game client closes the vault dialog.
    /// </summary>
    public readonly ref struct VaultClosed
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultClosed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public VaultClosed(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultClosed"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private VaultClosed(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x82;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 3;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="VaultClosed"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator VaultClosed(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="VaultClosed"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(VaultClosed packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to open the vault.
    /// Causes reaction on client side: The game client updates the UI to show the current vault protection state.
    /// </summary>
    public readonly ref struct VaultProtectionInformation
    {
        /// <summary>
        /// Defines the vault protection state.
        /// </summary>
        public enum VaultProtectionState
        {
            /// <summary>
            /// The vault is unprotected.
            /// </summary>
            Unprotected = 0,

            /// <summary>
            /// The vault is protected and locked. To move items or money, the player needs to unlock it.
            /// </summary>
            Locked = 1,

            /// <summary>
            /// The vault is protected and locked. The user-requested unlock failed by a wrong pin.
            /// </summary>
            UnlockFailedByWrongPin = 10,

            /// <summary>
            /// The vault is protected and locked and the player-requested pin setting failed because of the lock.
            /// </summary>
            SetPinFailedBecauseLock = 11,

            /// <summary>
            /// The vault is protected, but was unlocked by the player.
            /// </summary>
            Unlocked = 12,

            /// <summary>
            /// The vault is protected and the player-requested pin removal failed by using the wrong password.
            /// </summary>
            RemovePinFailedByWrongPassword = 13,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultProtectionInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public VaultProtectionInformation(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="VaultProtectionInformation"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private VaultProtectionInformation(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x83;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the protection state.
        /// </summary>
        public VaultProtectionInformation.VaultProtectionState ProtectionState
        {
            get => (VaultProtectionState)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="VaultProtectionInformation"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator VaultProtectionInformation(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="VaultProtectionInformation"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(VaultProtectionInformation packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to execute an item crafting, e.g. at the chaos machine.
    /// Causes reaction on client side: The game client updates the UI to show the resulting item.
    /// </summary>
    public readonly ref struct ItemCraftingResult
    {
        /// <summary>
        /// Defines the crafting result.
        /// </summary>
        public enum CraftingResult
        {
            /// <summary>
            /// The crafting failed.
            /// </summary>
            Failed = 0,

            /// <summary>
            /// The crafting succeeded.
            /// </summary>
            Success = 1,

            /// <summary>
            /// The crafting wasn't executed because of missing money.
            /// </summary>
            NotEnoughMoney = 2,

            /// <summary>
            /// The crafting wasn't executed because of too many items.
            /// </summary>
            TooManyItems = 3,

            /// <summary>
            /// The crafting wasn't executed because the character level is too low.
            /// </summary>
            CharacterLevelTooLow = 4,

            /// <summary>
            /// The crafting wasn't executed because of missing items.
            /// </summary>
            LackingMixItems = 6,

            /// <summary>
            /// The crafting wasn't executed because of incorrect items.
            /// </summary>
            IncorrectMixItems = 7,

            /// <summary>
            /// The crafting wasn't executed because of an invalid item level.
            /// </summary>
            InvalidItemLevel = 8,

            /// <summary>
            /// The crafting wasn't executed because the character class is too low.
            /// </summary>
            CharacterClassTooLow = 9,

            /// <summary>
            /// The blood castle ticket crafting wasn't executed because the BloodCastle items are not correct.
            /// </summary>
            IncorrectBloodCastleItems = 10,

            /// <summary>
            /// The crafting wasn't executed because the player has not enough money for the blood castle ticket crafting.
            /// </summary>
            NotEnoughMoneyForBloodCastle = 11,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemCraftingResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ItemCraftingResult(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemCraftingResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ItemCraftingResult(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x86;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public ItemCraftingResult.CraftingResult Result
        {
            get => (CraftingResult)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the item data.
        /// </summary>
        public Span<byte> ItemData
        {
            get => this.data.Slice(4);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ItemCraftingResult"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ItemCraftingResult(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ItemCraftingResult"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ItemCraftingResult packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
        /// </summary>
        /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to close the crafting dialog, this confirmation is sent back to the client.
    /// Causes reaction on client side: The game client closes the crafting dialog.
    /// </summary>
    public readonly ref struct CraftingDialogClosed075
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="CraftingDialogClosed075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public CraftingDialogClosed075(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CraftingDialogClosed075"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private CraftingDialogClosed075(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x87;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 3;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="CraftingDialogClosed075"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator CraftingDialogClosed075(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="CraftingDialogClosed075"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(CraftingDialogClosed075 packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player entered the game with his character.
    /// Causes reaction on client side: The game client updates the quest state for the quest dialog accordingly.
    /// </summary>
    public readonly ref partial struct LegacyQuestStateList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LegacyQuestStateList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LegacyQuestStateList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LegacyQuestStateList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LegacyQuestStateList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                this.QuestCount = 6;
                this.ScrollOfEmperorState = LegacyQuestState.Inactive;
                this.ThreeTreasuresOfMuState = LegacyQuestState.Inactive;
                this.GainHeroStatusState = LegacyQuestState.Inactive;
                this.SecretOfDarkStoneState = LegacyQuestState.Inactive;
                this.CertificateOfStrengthState = LegacyQuestState.Inactive;
                this.InfiltrationOfBarrackState = LegacyQuestState.Inactive;
                this.InfiltrationOfRefugeState = LegacyQuestState.Inactive;
                this.UnusedQuestState = LegacyQuestState.Undefined;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xA0;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the quest count.
        /// </summary>
        public byte QuestCount
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the scroll of emperor state.
        /// </summary>
        public LegacyQuestState ScrollOfEmperorState
        {
            get => (LegacyQuestState)this.data[4..].GetByteValue(2, 0);
            set => this.data[4..].SetByteValue((byte)value, 2, 0);
        }

        /// <summary>
        /// Gets or sets the three treasures of mu state.
        /// </summary>
        public LegacyQuestState ThreeTreasuresOfMuState
        {
            get => (LegacyQuestState)this.data[4..].GetByteValue(2, 2);
            set => this.data[4..].SetByteValue((byte)value, 2, 2);
        }

        /// <summary>
        /// Gets or sets the gain hero status state.
        /// </summary>
        public LegacyQuestState GainHeroStatusState
        {
            get => (LegacyQuestState)this.data[4..].GetByteValue(2, 4);
            set => this.data[4..].SetByteValue((byte)value, 2, 4);
        }

        /// <summary>
        /// Gets or sets the secret of dark stone state.
        /// </summary>
        public LegacyQuestState SecretOfDarkStoneState
        {
            get => (LegacyQuestState)this.data[4..].GetByteValue(2, 6);
            set => this.data[4..].SetByteValue((byte)value, 2, 6);
        }

        /// <summary>
        /// Gets or sets the certificate of strength state.
        /// </summary>
        public LegacyQuestState CertificateOfStrengthState
        {
            get => (LegacyQuestState)this.data[5..].GetByteValue(2, 0);
            set => this.data[5..].SetByteValue((byte)value, 2, 0);
        }

        /// <summary>
        /// Gets or sets the infiltration of barrack state.
        /// </summary>
        public LegacyQuestState InfiltrationOfBarrackState
        {
            get => (LegacyQuestState)this.data[5..].GetByteValue(2, 2);
            set => this.data[5..].SetByteValue((byte)value, 2, 2);
        }

        /// <summary>
        /// Gets or sets the infiltration of refuge state.
        /// </summary>
        public LegacyQuestState InfiltrationOfRefugeState
        {
            get => (LegacyQuestState)this.data[5..].GetByteValue(2, 4);
            set => this.data[5..].SetByteValue((byte)value, 2, 4);
        }

        /// <summary>
        /// Gets or sets the unused quest state.
        /// </summary>
        public LegacyQuestState UnusedQuestState
        {
            get => (LegacyQuestState)this.data[5..].GetByteValue(2, 6);
            set => this.data[5..].SetByteValue((byte)value, 2, 6);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LegacyQuestStateList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LegacyQuestStateList(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LegacyQuestStateList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LegacyQuestStateList packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: When the player clicks on the quest npc.
    /// Causes reaction on client side: The game client shows the next steps in the quest dialog.
    /// </summary>
    public readonly ref struct LegacyQuestStateDialog
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LegacyQuestStateDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LegacyQuestStateDialog(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LegacyQuestStateDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LegacyQuestStateDialog(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xA1;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 5;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the quest index.
        /// </summary>
        public byte QuestIndex
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets this is the complete byte with the state of four quests within the same byte.
        /// </summary>
        public byte State
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LegacyQuestStateDialog"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LegacyQuestStateDialog(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LegacyQuestStateDialog"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LegacyQuestStateDialog packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: As response to the set state request (C1A2).
    /// Causes reaction on client side: The game client shows the new quest state.
    /// </summary>
    public readonly ref struct LegacySetQuestStateResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LegacySetQuestStateResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LegacySetQuestStateResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LegacySetQuestStateResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LegacySetQuestStateResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xA2;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the quest index.
        /// </summary>
        public byte QuestIndex
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets this value is 0 if successful. Otherwise, 0xFF or even other magic values.
        /// </summary>
        public byte Result
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets this is the complete byte with the state of four quests within the same byte.
        /// </summary>
        public byte NewState
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LegacySetQuestStateResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LegacySetQuestStateResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LegacySetQuestStateResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LegacySetQuestStateResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: As response to the completed quest of a player in scope.
    /// Causes reaction on client side: The game client shows the reward accordingly.
    /// </summary>
    public readonly ref struct LegacyQuestReward
    {
        /// <summary>
        /// Defines the reward type in the quest reward message.
        /// </summary>
        public enum QuestRewardType
        {
            /// <summary>
            /// The character receives additional points.
            /// </summary>
            LevelUpPoints = 200,

            /// <summary>
            /// The character class changes from the first to the second class.
            /// </summary>
            CharacterEvolutionFirstToSecond = 201,

            /// <summary>
            /// The character receives additional points per level.
            /// </summary>
            LevelUpPointsPerLevelIncrease = 202,

            /// <summary>
            /// The character receives the ability to perform skill combinations.
            /// </summary>
            ComboSkill = 203,

            /// <summary>
            /// The character class changes from the second to the third class.
            /// </summary>
            CharacterEvolutionSecondToThird = 204,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LegacyQuestReward"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LegacyQuestReward(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LegacyQuestReward"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LegacyQuestReward(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xA3;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the player id.
        /// </summary>
        public ushort PlayerId
        {
            get => ReadUInt16BigEndian(this.data[3..]);
            set => WriteUInt16BigEndian(this.data[3..], value);
        }

        /// <summary>
        /// Gets or sets the reward.
        /// </summary>
        public LegacyQuestReward.QuestRewardType Reward
        {
            get => (QuestRewardType)this.data[5];
            set => this.data[5] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the count.
        /// </summary>
        public byte Count
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LegacyQuestReward"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LegacyQuestReward(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LegacyQuestReward"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LegacyQuestReward packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: As response when a player opens the quest npc with a running quest which requires monster kills.
    /// Causes reaction on client side: The game client shows the current state.
    /// </summary>
    public readonly ref struct LegacyQuestMonsterKillInfo
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LegacyQuestMonsterKillInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LegacyQuestMonsterKillInfo(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LegacyQuestMonsterKillInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LegacyQuestMonsterKillInfo(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.Result = 1;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xA4;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x00;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 48;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public byte Result
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the quest index.
        /// </summary>
        public byte QuestIndex
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets the <see cref="MonsterKillInfo"/> of the specified index.
        /// </summary>
        public MonsterKillInfo this[int index] => new (this.data[(8 + index * MonsterKillInfo.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LegacyQuestMonsterKillInfo"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LegacyQuestMonsterKillInfo(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LegacyQuestMonsterKillInfo"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LegacyQuestMonsterKillInfo packet) => packet.data; 


    /// <summary>
    /// A pair of Monster number and the current kill count..
    /// </summary>
    public readonly ref struct MonsterKillInfo
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MonsterKillInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MonsterKillInfo(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets or sets the monster number.
        /// </summary>
        public uint MonsterNumber
        {
            get => ReadUInt32LittleEndian(this.data);
            set => WriteUInt32LittleEndian(this.data, value);
        }

        /// <summary>
        /// Gets or sets the kill count.
        /// </summary>
        public uint KillCount
        {
            get => ReadUInt32LittleEndian(this.data[4..]);
            set => WriteUInt32LittleEndian(this.data[4..], value);
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After the client sent a PetAttackCommand (as confirmation), or when the previous command finished and the pet is reset to Normal-mode.
    /// Causes reaction on client side: The client updates the pet mode in its user interface.
    /// </summary>
    public readonly ref struct PetMode
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PetMode"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PetMode(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PetMode"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PetMode(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                this.Pet = ClientToServer.PetType.DarkRaven;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xA7;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the pet.
        /// </summary>
        public ClientToServer.PetType Pet
        {
            get => (ClientToServer.PetType)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the pet command mode.
        /// </summary>
        public ClientToServer.PetCommandMode PetCommandMode
        {
            get => (ClientToServer.PetCommandMode)this.data[4];
            set => this.data[4] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => ReadUInt16LittleEndian(this.data[5..]);
            set => WriteUInt16LittleEndian(this.data[5..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PetMode"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PetMode(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PetMode"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PetMode packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the client sent a PetAttackCommand, the pet attacks automatically. For each attack, the player and all observing players get this message.
    /// Causes reaction on client side: The client shows the pet attacking the target.
    /// </summary>
    public readonly ref struct PetAttack
    {
        /// <summary>
        /// Describes the type of the pet attack.
        /// </summary>
        public enum PetSkillType
        {
            /// <summary>
            /// A single target attack, used for critical and excellent hits.
            /// </summary>
            SingleTarget = 0,

            /// <summary>
            /// A range attack for multiple targets, usually up to 3 additional targets which all get their own PetAttack messages with 'SingleTarget' right after the first 'Range' message.
            /// </summary>
            Range = 1,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PetAttack"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PetAttack(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PetAttack"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PetAttack(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                this.Pet = ClientToServer.PetType.DarkRaven;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xA8;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the pet.
        /// </summary>
        public ClientToServer.PetType Pet
        {
            get => (ClientToServer.PetType)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the skill type.
        /// </summary>
        public PetAttack.PetSkillType SkillType
        {
            get => (PetSkillType)this.data[4];
            set => this.data[4] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the owner id.
        /// </summary>
        public ushort OwnerId
        {
            get => ReadUInt16LittleEndian(this.data[5..]);
            set => WriteUInt16LittleEndian(this.data[5..], value);
        }

        /// <summary>
        /// Gets or sets the target id.
        /// </summary>
        public ushort TargetId
        {
            get => ReadUInt16LittleEndian(this.data[7..]);
            set => WriteUInt16LittleEndian(this.data[7..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PetAttack"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PetAttack(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PetAttack"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PetAttack packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the client sent a PetInfoRequest for a pet (dark raven, horse).
    /// Causes reaction on client side: The client shows the information about the pet.
    /// </summary>
    public readonly ref struct PetInfoResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PetInfoResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PetInfoResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PetInfoResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PetInfoResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xA9;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the pet.
        /// </summary>
        public ClientToServer.PetType Pet
        {
            get => (ClientToServer.PetType)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the storage.
        /// </summary>
        public ClientToServer.StorageType Storage
        {
            get => (ClientToServer.StorageType)this.data[4];
            set => this.data[4] = (byte)value;
        }

        /// <summary>
        /// Gets or sets the item slot.
        /// </summary>
        public byte ItemSlot
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the level.
        /// </summary>
        public byte Level
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets or sets the experience.
        /// </summary>
        public uint Experience
        {
            get => ReadUInt32LittleEndian(this.data[7..]);
            set => WriteUInt32LittleEndian(this.data[7..], value);
        }

        /// <summary>
        /// Gets or sets the health.
        /// </summary>
        public byte Health
        {
            get => this.data[11];
            set => this.data[11] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PetInfoResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PetInfoResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PetInfoResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PetInfoResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After entering the game with a character.
    /// Causes reaction on client side: 
    /// </summary>
    public readonly ref struct MessengerInitialization
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="MessengerInitialization"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public MessengerInitialization(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MessengerInitialization"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private MessengerInitialization(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC0;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the letter count.
        /// </summary>
        public byte LetterCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the maximum letter count.
        /// </summary>
        public byte MaximumLetterCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets or sets the friend count.
        /// </summary>
        public byte FriendCount
        {
            get => this.data[6];
            set => this.data[6] = value;
        }

        /// <summary>
        /// Gets the <see cref="Friend"/> of the specified index.
        /// </summary>
        public Friend this[int index] => new (this.data[(7 + index * Friend.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="MessengerInitialization"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator MessengerInitialization(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="MessengerInitialization"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(MessengerInitialization packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="Friend"/>.
        /// </summary>
        /// <param name="friendsCount">The count of <see cref="Friend"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int friendsCount) => friendsCount * Friend.Length + 7;


    /// <summary>
    /// The structure which contains the friend name and online state..
    /// </summary>
    public readonly ref struct Friend
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="Friend"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public Friend(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 11;

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name
        {
            get => this.data.ExtractString(0, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(0, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the server id on which the player currently is online. 0xFF means offline.
        /// </summary>
        public byte ServerId
        {
            get => this.data[1];
            set => this.data[1] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: After a friend has been added to the friend list.
    /// Causes reaction on client side: The friend appears in the friend list.
    /// </summary>
    public readonly ref struct FriendAdded
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendAdded(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendAdded"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendAdded(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
                this.ServerId = 0xFF;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC1;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 15;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the friend name.
        /// </summary>
        public string FriendName
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the server id on which the player currently is online. 0xFF means offline.
        /// </summary>
        public byte ServerId
        {
            get => this.data[14];
            set => this.data[14] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendAdded"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendAdded(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendAdded"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendAdded packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a player has requested to add another player as friend. This other player gets this message.
    /// Causes reaction on client side: The friend request appears on the user interface.
    /// </summary>
    public readonly ref struct FriendRequest
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC2;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 13;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the requester.
        /// </summary>
        public string Requester
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendRequest(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a friend has been removed from the friend list.
    /// Causes reaction on client side: The friend is removed from the friend list.
    /// </summary>
    public readonly ref struct FriendDeleted
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendDeleted"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendDeleted(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendDeleted"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendDeleted(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC3;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 14;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the friend name.
        /// </summary>
        public string FriendName
        {
            get => this.data.ExtractString(4, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendDeleted"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendDeleted(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendDeleted"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendDeleted packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a friend has been added to the friend list.
    /// Causes reaction on client side: The friend appears in the friend list.
    /// </summary>
    public readonly ref struct FriendOnlineStateUpdate
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendOnlineStateUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendOnlineStateUpdate(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendOnlineStateUpdate"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendOnlineStateUpdate(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC4;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 14;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the friend name.
        /// </summary>
        public string FriendName
        {
            get => this.data.ExtractString(3, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the server id on which the player currently is online. 0xFF means offline.
        /// </summary>
        public byte ServerId
        {
            get => this.data[13];
            set => this.data[13] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendOnlineStateUpdate"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendOnlineStateUpdate(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendOnlineStateUpdate"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendOnlineStateUpdate packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to send a letter to another player.
    /// Causes reaction on client side: Depending on the result, the letter send dialog closes or an error message appears.
    /// </summary>
    public readonly ref struct LetterSendResponse
    {
        /// <summary>
        /// Describes the result of a letter send request.
        /// </summary>
        public enum LetterSendRequestResult
        {
            /// <summary>
            /// The letter wasn't sent because there was an internal problem. The user should try again.
            /// </summary>
            TryAgain = 0,

            /// <summary>
            /// The letter was sent.
            /// </summary>
            Success = 1,

            /// <summary>
            /// The mailbox of the recipient is full.
            /// </summary>
            MailboxFull = 2,

            /// <summary>
            /// The receiver does not exist.
            /// </summary>
            ReceiverNotExists = 3,

            /// <summary>
            /// A letter can't be sent to yourself.
            /// </summary>
            CantSendToYourself = 4,

            /// <summary>
            /// The sender doesn't have enough money to send a letter.
            /// </summary>
            NotEnoughMoney = 7,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="LetterSendResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public LetterSendResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LetterSendResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private LetterSendResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC5;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the letter id.
        /// </summary>
        public uint LetterId
        {
            get => ReadUInt32LittleEndian(this.data[4..]);
            set => WriteUInt32LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the result.
        /// </summary>
        public LetterSendResponse.LetterSendRequestResult Result
        {
            get => (LetterSendRequestResult)this.data[3];
            set => this.data[3] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="LetterSendResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator LetterSendResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="LetterSendResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(LetterSendResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After a letter has been received or after the player entered the game with a character.
    /// Causes reaction on client side: The letter appears in the letter list.
    /// </summary>
    public readonly ref struct AddLetter
    {
        /// <summary>
        /// Describes the state of a letter.
        /// </summary>
        public enum LetterState
        {
            /// <summary>
            /// The letter was read before.
            /// </summary>
            Read = 0,

            /// <summary>
            /// The letter wasn't read yet.
            /// </summary>
            Unread = 1,

            /// <summary>
            /// The letter is new (= was just sent by the sender) and wasn't read yet. It will notify the user about the received letter.
            /// </summary>
            New = 2,
        }

        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AddLetter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AddLetter(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddLetter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AddLetter(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC6;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 79;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the letter index.
        /// </summary>
        public ushort LetterIndex
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the sender name.
        /// </summary>
        public string SenderName
        {
            get => this.data.ExtractString(6, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(6, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the timestamp.
        /// </summary>
        public string Timestamp
        {
            get => this.data.ExtractString(16, 30, System.Text.Encoding.UTF8);
            set => this.data.Slice(16, 30).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the subject.
        /// </summary>
        public string Subject
        {
            get => this.data.ExtractString(46, 32, System.Text.Encoding.UTF8);
            set => this.data.Slice(46, 32).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the state.
        /// </summary>
        public AddLetter.LetterState State
        {
            get => (LetterState)this.data[78];
            set => this.data[78] = (byte)value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AddLetter"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AddLetter(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AddLetter"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AddLetter packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the player requested to read a letter.
    /// Causes reaction on client side: The letter is opened in a new dialog.
    /// </summary>
    public readonly ref struct OpenLetter
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="OpenLetter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public OpenLetter(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="OpenLetter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private OpenLetter(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC4;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC7;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C4Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the letter index.
        /// </summary>
        public ushort LetterIndex
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the message size.
        /// </summary>
        public ushort MessageSize
        {
            get => ReadUInt16LittleEndian(this.data[6..]);
            set => WriteUInt16LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets the sender appearance.
        /// </summary>
        public Span<byte> SenderAppearance
        {
            get => this.data.Slice(8, 18);
        }

        /// <summary>
        /// Gets or sets the rotation.
        /// </summary>
        public byte Rotation
        {
            get => this.data[26];
            set => this.data[26] = value;
        }

        /// <summary>
        /// Gets or sets the animation.
        /// </summary>
        public byte Animation
        {
            get => this.data[27];
            set => this.data[27] = value;
        }

        /// <summary>
        /// Gets or sets the message.
        /// </summary>
        public string Message
        {
            get => this.data.ExtractString(28, this.data.Length - 28, System.Text.Encoding.UTF8);
            set => this.data.Slice(28).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="OpenLetter"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator OpenLetter(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="OpenLetter"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(OpenLetter packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 28;
    }


    /// <summary>
    /// Is sent by the server when: After a letter has been deleted by the request of the player.
    /// Causes reaction on client side: The letter is removed from the letter list.
    /// </summary>
    public readonly ref struct RemoveLetter
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="RemoveLetter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public RemoveLetter(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RemoveLetter"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private RemoveLetter(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                this.RequestSuccessful = true;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xC8;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the request successful.
        /// </summary>
        public bool RequestSuccessful
        {
            get => this.data[3..].GetBoolean();
            set => this.data[3..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the letter index.
        /// </summary>
        public ushort LetterIndex
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="RemoveLetter"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator RemoveLetter(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="RemoveLetter"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(RemoveLetter packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player is invited to join a chat room on the chat server.
    /// Causes reaction on client side: The game client connects to the chat server and joins the chat room with the specified authentication data.
    /// </summary>
    public readonly ref struct ChatRoomConnectionInfo
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatRoomConnectionInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ChatRoomConnectionInfo(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ChatRoomConnectionInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ChatRoomConnectionInfo(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                this.Type = 1;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xCA;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 36;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the chat server ip.
        /// </summary>
        public string ChatServerIp
        {
            get => this.data.ExtractString(3, 15, System.Text.Encoding.UTF8);
            set => this.data.Slice(3, 15).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the chat room id.
        /// </summary>
        public ushort ChatRoomId
        {
            get => ReadUInt16LittleEndian(this.data[18..]);
            set => WriteUInt16LittleEndian(this.data[18..], value);
        }

        /// <summary>
        /// Gets or sets the authentication token.
        /// </summary>
        public uint AuthenticationToken
        {
            get => ReadUInt32LittleEndian(this.data[20..]);
            set => WriteUInt32LittleEndian(this.data[20..], value);
        }

        /// <summary>
        /// Gets or sets the type.
        /// </summary>
        public byte Type
        {
            get => this.data[24];
            set => this.data[24] = value;
        }

        /// <summary>
        /// Gets or sets the friend name.
        /// </summary>
        public string FriendName
        {
            get => this.data.ExtractString(25, 10, System.Text.Encoding.UTF8);
            set => this.data.Slice(25, 10).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[35..].GetBoolean();
            set => this.data[35..].SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ChatRoomConnectionInfo"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ChatRoomConnectionInfo(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ChatRoomConnectionInfo"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ChatRoomConnectionInfo packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The player requested to add another player to his friend list and the server processed this request.
    /// Causes reaction on client side: The game client knows if the invitation could be sent to the other player.
    /// </summary>
    public readonly ref struct FriendInvitationResult
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendInvitationResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public FriendInvitationResult(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FriendInvitationResult"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private FriendInvitationResult(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xCB;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3Header Header => new (this.data);

        /// <summary>
        /// Gets or sets the success.
        /// </summary>
        public bool Success
        {
            get => this.data[3..].GetBoolean();
            set => this.data[3..].SetBoolean(value);
        }

        /// <summary>
        /// Gets or sets the request id.
        /// </summary>
        public uint RequestId
        {
            get => ReadUInt32BigEndian(this.data[4..]);
            set => WriteUInt32BigEndian(this.data[4..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="FriendInvitationResult"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator FriendInvitationResult(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="FriendInvitationResult"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(FriendInvitationResult packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the game client requested the list of event quests after entering the game. It seems to be sent only if the character is not a member of a Gen.
    /// Causes reaction on client side: Unknown.
    /// </summary>
    public readonly ref struct QuestEventResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestEventResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public QuestEventResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestEventResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private QuestEventResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF6;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x03;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets the <see cref="QuestIdentification"/> of the specified index.
        /// </summary>
        public QuestIdentification this[int index] => new (this.data[(4 + index * QuestIdentification.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestEventResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator QuestEventResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="QuestEventResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(QuestEventResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the game client requested the list of available quests through an NPC dialog.
    /// Causes reaction on client side: The client shows the available quests for the currently interacting NPC.
    /// </summary>
    public readonly ref struct AvailableQuests
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="AvailableQuests"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public AvailableQuests(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="AvailableQuests"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private AvailableQuests(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF6;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x0A;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the quest npc number.
        /// </summary>
        public ushort QuestNpcNumber
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the quest count.
        /// </summary>
        public ushort QuestCount
        {
            get => ReadUInt16LittleEndian(this.data[6..]);
            set => WriteUInt16LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets the <see cref="QuestIdentification"/> of the specified index.
        /// </summary>
        public QuestIdentification this[int index] => new (this.data[(8 + index * QuestIdentification.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="AvailableQuests"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator AvailableQuests(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="AvailableQuests"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(AvailableQuests packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="QuestIdentification"/>.
        /// </summary>
        /// <param name="questsCount">The count of <see cref="QuestIdentification"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int questsCount) => questsCount * QuestIdentification.Length + 8;
    }


    /// <summary>
    /// Is sent by the server when: After the game client clicked on a quest in the quest list, proceeded with a quest or refused to start a quest.
    /// Causes reaction on client side: The client shows the corresponding description about the current quest step.
    /// </summary>
    public readonly ref struct QuestStepInfo
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestStepInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public QuestStepInfo(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestStepInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private QuestStepInfo(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF6;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x0B;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 11;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets a number specifying the description: A) when selecting a quest in the quest list, it's the "StartingNumber"; B) when a quest has been started it's the quest number; C) when the starting number has been sent previously and the player refused to start the quest, it sends a "RefuseNumber".
        /// </summary>
        public ushort QuestStepNumber
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the quest group.
        /// </summary>
        public ushort QuestGroup
        {
            get => ReadUInt16LittleEndian(this.data[6..]);
            set => WriteUInt16LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestStepInfo"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator QuestStepInfo(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="QuestStepInfo"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(QuestStepInfo packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: First, after the game client requested to initialize a quest and the quest is already active. Second, after the game client requested the next quest step.
    /// Causes reaction on client side: The client shows the quest progress accordingly.
    /// </summary>
    public readonly ref struct QuestProgress
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestProgress"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public QuestProgress(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestProgress"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private QuestProgress(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF6;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x0C;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 251;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the quest number.
        /// </summary>
        public ushort QuestNumber
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the quest group.
        /// </summary>
        public ushort QuestGroup
        {
            get => ReadUInt16LittleEndian(this.data[6..]);
            set => WriteUInt16LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets the condition count.
        /// </summary>
        public byte ConditionCount
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the reward count.
        /// </summary>
        public byte RewardCount
        {
            get => this.data[9];
            set => this.data[9] = value;
        }

        /// <summary>
        /// Gets the <see cref="QuestCondition"/> of the specified index.
        /// </summary>
        public QuestCondition GetQuestCondition(int index) => new (this.data[(11 + index * QuestCondition.Length)..]);

        /// <summary>
        /// Gets the <see cref="QuestReward"/> of the specified index.
        /// </summary>
        public QuestReward GetQuestReward(int index) => new (this.data[(141 + index * QuestReward.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestProgress"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator QuestProgress(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="QuestProgress"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(QuestProgress packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="QuestCondition"/>.
        /// </summary>
        /// <param name="conditionsCount">The count of <see cref="QuestCondition"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int conditionsCount) => conditionsCount * QuestCondition.Length + 11;
    }


    /// <summary>
    /// Is sent by the server when: The server acknowledges the completion of a quest.
    /// Causes reaction on client side: The client shows the success and possibly requests for the next available quests.
    /// </summary>
    public readonly ref struct QuestCompletionResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestCompletionResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public QuestCompletionResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestCompletionResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private QuestCompletionResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF6;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x0D;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 9;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the quest number.
        /// </summary>
        public ushort QuestNumber
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the quest group.
        /// </summary>
        public ushort QuestGroup
        {
            get => ReadUInt16LittleEndian(this.data[6..]);
            set => WriteUInt16LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets the is quest completed.
        /// </summary>
        public bool IsQuestCompleted
        {
            get => this.data[8..].GetBoolean();
            set => this.data[8..].SetBoolean(value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestCompletionResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator QuestCompletionResponse(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="QuestCompletionResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(QuestCompletionResponse packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: The server acknowledges the requested cancellation of a quest.
    /// Causes reaction on client side: The client resets the state of the quest and can request a new list of available quests again. This list would then probably contain the cancelled quest again.
    /// </summary>
    public readonly ref struct QuestCancelled
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestCancelled"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public QuestCancelled(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestCancelled"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private QuestCancelled(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF6;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x0F;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 8;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the current quest number. In this message, it's always 0, because the group is relevant for the client.
        /// </summary>
        public ushort QuestNumber
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the quest group.
        /// </summary>
        public ushort QuestGroup
        {
            get => ReadUInt16LittleEndian(this.data[6..]);
            set => WriteUInt16LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestCancelled"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator QuestCancelled(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="QuestCancelled"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(QuestCancelled packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: After the game client requested the list of all quests which are currently in progress or accepted.
    /// Causes reaction on client side: Unknown.
    /// </summary>
    public readonly ref struct QuestStateList
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestStateList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public QuestStateList(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestStateList"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private QuestStateList(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF6;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x1A;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the quest count.
        /// </summary>
        public byte QuestCount
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets the <see cref="QuestIdentification"/> of the specified index.
        /// </summary>
        public QuestIdentification this[int index] => new (this.data[(5 + index * QuestIdentification.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestStateList"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator QuestStateList(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="QuestStateList"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(QuestStateList packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="QuestIdentification"/>.
        /// </summary>
        /// <param name="questsCount">The count of <see cref="QuestIdentification"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int questsCount) => questsCount * QuestIdentification.Length + 5;
    }


    /// <summary>
    /// Is sent by the server when: After the game client requested it, when the player opened the quest menu and clicked on a quest.
    /// Causes reaction on client side: The client shows the quest progress accordingly.
    /// </summary>
    public readonly ref struct QuestState
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestState"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public QuestState(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="QuestState"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private QuestState(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF6;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x1B;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 251;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the quest number.
        /// </summary>
        public ushort QuestNumber
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the quest group.
        /// </summary>
        public ushort QuestGroup
        {
            get => ReadUInt16LittleEndian(this.data[6..]);
            set => WriteUInt16LittleEndian(this.data[6..], value);
        }

        /// <summary>
        /// Gets or sets the condition count.
        /// </summary>
        public byte ConditionCount
        {
            get => this.data[8];
            set => this.data[8] = value;
        }

        /// <summary>
        /// Gets or sets the reward count.
        /// </summary>
        public byte RewardCount
        {
            get => this.data[9];
            set => this.data[9] = value;
        }

        /// <summary>
        /// Gets or sets the random reward count.
        /// </summary>
        public byte RandomRewardCount
        {
            get => this.data[10];
            set => this.data[10] = value;
        }

        /// <summary>
        /// Gets the <see cref="QuestCondition"/> of the specified index.
        /// </summary>
        public QuestCondition GetQuestCondition(int index) => new (this.data[(11 + index * QuestCondition.Length)..]);

        /// <summary>
        /// Gets the <see cref="QuestReward"/> of the specified index.
        /// </summary>
        public QuestReward GetQuestReward(int index) => new (this.data[(141 + index * QuestReward.Length)..]);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="QuestState"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator QuestState(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="QuestState"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(QuestState packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="QuestCondition"/>.
        /// </summary>
        /// <param name="conditionsCount">The count of <see cref="QuestCondition"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int conditionsCount) => conditionsCount * QuestCondition.Length + 11;
    }


    /// <summary>
    /// Is sent by the server when: The server acknowledges the requested opening of an npc dialog.
    /// Causes reaction on client side: The client opens the dialog of the specified npc.
    /// </summary>
    public readonly ref struct OpenNpcDialog
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="OpenNpcDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public OpenNpcDialog(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="OpenNpcDialog"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private OpenNpcDialog(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC3;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF9;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 12;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C3HeaderWithSubCode Header => new (this.data);

        /// <summary>
        /// Gets or sets the npc number.
        /// </summary>
        public ushort NpcNumber
        {
            get => ReadUInt16LittleEndian(this.data[4..]);
            set => WriteUInt16LittleEndian(this.data[4..], value);
        }

        /// <summary>
        /// Gets or sets the gens contribution points.
        /// </summary>
        public uint GensContributionPoints
        {
            get => ReadUInt32LittleEndian(this.data[8..]);
            set => WriteUInt32LittleEndian(this.data[8..], value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="OpenNpcDialog"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator OpenNpcDialog(Span<byte> packet) => new (packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="OpenNpcDialog"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(OpenNpcDialog packet) => packet.data; 
    }
        /// <summary>
        /// Defines the role of a guild member.
        /// </summary>
        public enum GuildMemberRole
        {
            /// <summary>
            /// The member is a normal member without special rights.
            /// </summary>
            NormalMember = 0,

            /// <summary>
            /// The member is a battle master.
            /// </summary>
            BattleMaster = 32,

            /// <summary>
            /// The member is the guild master.
            /// </summary>
            GuildMaster = 128,

            /// <summary>
            /// The character is not a member, therefore the role is undefined.
            /// </summary>
            Undefined = 255,
        }

        /// <summary>
        /// Describes the type of the guild war.
        /// </summary>
        public enum GuildWarType
        {
            /// <summary>
            /// A normal guild war.
            /// </summary>
            Normal = 0,

            /// <summary>
            /// A guild soccer match.
            /// </summary>
            Soccer = 1,
        }

        /// <summary>
        /// The status of a character.
        /// </summary>
        public enum CharacterStatus
        {
            /// <summary>
            /// The state of the character is normal.
            /// </summary>
            Normal = 0,

            /// <summary>
            /// The character is banned from the game.
            /// </summary>
            Banned = 1,

            /// <summary>
            /// The character is a game master.
            /// </summary>
            GameMaster = 32,
        }

        /// <summary>
        /// Defines the type of the condition.
        /// </summary>
        public enum ConditionType
        {
            /// <summary>
            /// No condition is defined.
            /// </summary>
            None = 0,

            /// <summary>
            /// The condition is to kill a specified amount of specified monsters.
            /// </summary>
            MonsterKills = 1,

            /// <summary>
            /// The condition is to learn a specified skill.
            /// </summary>
            Skill = 2,

            /// <summary>
            /// The condition is to find a specified item and to have it in the inventory.
            /// </summary>
            Item = 4,

            /// <summary>
            /// The condition is to reach the specified character level.
            /// </summary>
            Level = 8,

            /// <summary>
            /// The condition is a client action. For example, this may be the completion of a tutorial.
            /// </summary>
            ClientAction = 16,

            /// <summary>
            /// The condition is to request a buff from an NPC.
            /// </summary>
            RequestBuff = 32,
        }

        /// <summary>
        /// Defines the reward which is given when the quest is completed.
        /// </summary>
        public enum RewardType
        {
            /// <summary>
            /// No reward is defined.
            /// </summary>
            None = 0,

            /// <summary>
            /// The reward is added experience to the character.
            /// </summary>
            Experience = 1,

            /// <summary>
            /// The reward is added money to the inventory.
            /// </summary>
            Money = 2,

            /// <summary>
            /// The reward is an item which is added to the inventory.
            /// </summary>
            Item = 4,

            /// <summary>
            /// The reward is added gens contribution points.
            /// </summary>
            GensContribution = 16,
        }

}