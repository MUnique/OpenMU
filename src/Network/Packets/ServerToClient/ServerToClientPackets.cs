// <copyright file="ServerToClientPackets.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Network.Packets.ServerToClient;

using System;
using static System.Buffers.Binary.BinaryPrimitives;

/// <summary>
/// The structure for a stored item, e.g. in the inventory or vault..
/// </summary>
public readonly struct StoredItem
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="StoredItem"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public StoredItem(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(1).Span;
    }

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 1;
}


/// <summary>
/// Data of an item in a player shop..
/// </summary>
public readonly struct PlayerShopItem
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItem"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopItem(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 20;

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(1, 12).Span;
    }

    /// <summary>
    /// Gets or sets the price.
    /// </summary>
    public uint Price
    {
        get => ReadUInt32LittleEndian(this._data.Span[16..]);
        set => WriteUInt32LittleEndian(this._data.Span[16..], value);
    }
}


/// <summary>
/// Data of an item in a player shop, which allows for dynamic item sizes and trades for specific kind of items (e.g. jewels), too..
/// </summary>
public readonly struct PlayerShopItemExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopItemExtended(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the money price.
    /// </summary>
    public uint MoneyPrice
    {
        get => ReadUInt32LittleEndian(this._data.Span);
        set => WriteUInt32LittleEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets contains the item group in the highest 4 bits, and the item number in the remaining ones.
    /// </summary>
    public ushort PriceItemType
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the required item amount.
    /// </summary>
    public ushort RequiredItemAmount
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(9).Span;
    }

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 9;
}


/// <summary>
/// Defines the information which identifies a quest..
/// </summary>
public readonly struct QuestIdentification
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestIdentification"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestIdentification(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets or sets the number.
    /// </summary>
    public ushort Number
    {
        get => ReadUInt16LittleEndian(this._data.Span);
        set => WriteUInt16LittleEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the group.
    /// </summary>
    public ushort Group
    {
        get => ReadUInt16LittleEndian(this._data.Span[2..]);
        set => WriteUInt16LittleEndian(this._data.Span[2..], value);
    }
}


/// <summary>
/// Defines a condition which must be fulfilled to complete the quest..
/// </summary>
public readonly struct QuestCondition
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCondition"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestCondition(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 26;

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public ConditionType Type
    {
        get => (ConditionType)this._data.Span[0];
        set => this._data.Span[0] = (byte)value;
    }

    /// <summary>
    /// Gets or sets depending on the condition type, this field contains the identifier of the required thing, e.g. Monster Number, Item Id, Level.
    /// </summary>
    public ushort RequirementId
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the required count.
    /// </summary>
    public uint RequiredCount
    {
        get => ReadUInt32LittleEndian(this._data.Span[6..]);
        set => WriteUInt32LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the current count.
    /// </summary>
    public uint CurrentCount
    {
        get => ReadUInt32LittleEndian(this._data.Span[10..]);
        set => WriteUInt32LittleEndian(this._data.Span[10..], value);
    }

    /// <summary>
    /// Gets or sets if the condition type is 'Item', this field contains the item data, excluding the item id. The item id can be found in the RequirementId field.
    /// </summary>
    public Span<byte> RequiredItemData
    {
        get => this._data.Slice(14, 12).Span;
    }
}


/// <summary>
/// Defines a reward which is given when the quest is completed..
/// </summary>
public readonly struct QuestReward
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestReward"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestReward(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 22;

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public RewardType Type
    {
        get => (RewardType)this._data.Span[0];
        set => this._data.Span[0] = (byte)value;
    }

    /// <summary>
    /// Gets or sets depending on the condition type, this field contains the identifier of the required thing, e.g. Monster Number, Item Id, Level.
    /// </summary>
    public ushort RewardId
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the reward count.
    /// </summary>
    public uint RewardCount
    {
        get => ReadUInt32LittleEndian(this._data.Span[6..]);
        set => WriteUInt32LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets if the reward type is 'Item', this field contains its item data.
    /// </summary>
    public Span<byte> RewardedItemData
    {
        get => this._data.Slice(10, 12).Span;
    }
}


/// <summary>
/// Defines a condition which must be fulfilled to complete the quest..
/// </summary>
public readonly struct QuestConditionExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestConditionExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestConditionExtended(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 28;

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public ConditionType Type
    {
        get => (ConditionType)this._data.Span[0];
        set => this._data.Span[0] = (byte)value;
    }

    /// <summary>
    /// Gets or sets depending on the condition type, this field contains the identifier of the required thing, e.g. Monster Number, Item Id, Level.
    /// </summary>
    public ushort RequirementId
    {
        get => ReadUInt16LittleEndian(this._data.Span[2..]);
        set => WriteUInt16LittleEndian(this._data.Span[2..], value);
    }

    /// <summary>
    /// Gets or sets the required count.
    /// </summary>
    public uint RequiredCount
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the current count.
    /// </summary>
    public uint CurrentCount
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets if the condition type is 'Item', this field contains the item data, excluding the item id. The item id can be found in the RequirementId field.
    /// </summary>
    public Span<byte> RequiredItemData
    {
        get => this._data.Slice(12, 15).Span;
    }
}


/// <summary>
/// Defines a reward which is given when the quest is completed..
/// </summary>
public readonly struct QuestRewardExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestRewardExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestRewardExtended(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public RewardType Type
    {
        get => (RewardType)this._data.Span[0];
        set => this._data.Span[0] = (byte)value;
    }

    /// <summary>
    /// Gets or sets depending on the condition type, this field contains the identifier of the required thing, e.g. Monster Number, Item Id, Level.
    /// </summary>
    public ushort RewardId
    {
        get => ReadUInt16LittleEndian(this._data.Span[2..]);
        set => WriteUInt16LittleEndian(this._data.Span[2..], value);
    }

    /// <summary>
    /// Gets or sets the reward count.
    /// </summary>
    public uint RewardCount
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets if the reward type is 'Item', this field contains its item data.
    /// </summary>
    public Span<byte> RewardedItemData
    {
        get => this._data.Slice(8, 15).Span;
    }
}


/// <summary>
/// Is sent by the server when: After a game client has connected to the game.
/// Causes reaction on client side: It shows the login dialog.
/// </summary>
public readonly struct GameServerEntered
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GameServerEntered"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GameServerEntered(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GameServerEntered"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GameServerEntered(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Success = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[4..].GetBoolean();
        set => this._data.Span[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the version string.
    /// </summary>
    public string VersionString
    {
        get => this._data.Span.ExtractString(7, 5, System.Text.Encoding.UTF8);
        set => this._data.Slice(7, 5).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the version.
    /// </summary>
    public Span<byte> Version
    {
        get => this._data.Slice(7, 5).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GameServerEntered"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GameServerEntered(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GameServerEntered"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GameServerEntered packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A magic effect was added or removed to the own or another player.
/// Causes reaction on client side: The user interface updates itself. If it's the effect of the own player, it's shown as icon at the top of the interface.
/// </summary>
public readonly struct MagicEffectStatus
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectStatus"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MagicEffectStatus(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectStatus"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MagicEffectStatus(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the is active.
    /// </summary>
    public bool IsActive
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the effect id.
    /// </summary>
    public byte EffectId
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MagicEffectStatus"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MagicEffectStatus(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MagicEffectStatus"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MagicEffectStatus packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The weather on the current map has been changed or the player entered the map.
/// Causes reaction on client side: The game client updates the weather effects.
/// </summary>
public readonly struct WeatherStatusUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="WeatherStatusUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public WeatherStatusUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="WeatherStatusUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private WeatherStatusUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x0F;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets a random value between 0 and 2 (inclusive).
    /// </summary>
    public byte Weather
    {
        get => this._data.Span[3..].GetByteValue(4, 4);
        set => this._data.Span[3..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets a random value between 0 and 9 (inclusive).
    /// </summary>
    public byte Variation
    {
        get => this._data.Span[3..].GetByteValue(4, 0);
        set => this._data.Span[3..].SetByteValue(value, 4, 0);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="WeatherStatusUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator WeatherStatusUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="WeatherStatusUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(WeatherStatusUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: One or more character got into the observed scope of the player.
/// Causes reaction on client side: The client adds the character to the shown map.
/// </summary>
public readonly struct AddCharacterToScopeExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharacterToScopeExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddCharacterToScopeExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharacterToScopeExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddCharacterToScopeExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[10..].GetByteValue(4, 4);
        set => this._data.Span[10..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data.Span[10..].GetByteValue(4, 0);
        set => this._data.Span[10..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the attack speed.
    /// </summary>
    public ushort AttackSpeed
    {
        get => ReadUInt16LittleEndian(this._data.Span[12..]);
        set => WriteUInt16LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the magic speed.
    /// </summary>
    public ushort MagicSpeed
    {
        get => ReadUInt16LittleEndian(this._data.Span[14..]);
        set => WriteUInt16LittleEndian(this._data.Span[14..], value);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(16, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(16, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the appearance and effects.
    /// </summary>
    public Span<byte> AppearanceAndEffects
    {
        get => this._data.Slice(26).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddCharacterToScopeExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddCharacterToScopeExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddCharacterToScopeExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddCharacterToScopeExtended packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="AppearanceAndEffects"/>.
    /// </summary>
    /// <param name="appearanceAndEffectsLength">The length in bytes of <see cref="AppearanceAndEffects"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int appearanceAndEffectsLength) => appearanceAndEffectsLength + 26;
}


/// <summary>
/// Is sent by the server when: One or more character got into the observed scope of the player.
/// Causes reaction on client side: The client adds the character to the shown map.
/// </summary>
public readonly partial struct AddCharactersToScope
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharactersToScope"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddCharactersToScope(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharactersToScope"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddCharactersToScope(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddCharactersToScope"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddCharactersToScope(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddCharactersToScope"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddCharactersToScope packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/> and it's size.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="CharacterData"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int charactersCount, int structLength) => charactersCount * structLength + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly struct CharacterData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(4, 18).Span;
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(22, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(22, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data.Span[32];
        set => this._data.Span[32] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data.Span[33];
        set => this._data.Span[33] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[34..].GetByteValue(4, 4);
        set => this._data.Span[34..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data.Span[34..].GetByteValue(4, 0);
        set => this._data.Span[34..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets defines the number of effects which would be sent after this field.
    /// </summary>
    public byte EffectCount
    {
        get => this._data.Span[35];
        set => this._data.Span[35] = value;
    }

    /// <summary>
    /// Gets the <see cref="EffectId"/> of the specified index.
    /// </summary>
        public EffectId this[int index] => new (this._data.Slice(36 + index * EffectId.Length));

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="EffectId"/>.
    /// </summary>
    /// <param name="effectsCount">The count of <see cref="EffectId"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int effectsCount) => effectsCount * EffectId.Length + 36;
}


/// <summary>
/// Contains the id of a magic effect..
/// </summary>
public readonly struct EffectId
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EffectId"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EffectId(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 1;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public byte Id
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: One or more character got into the observed scope of the player.
/// Causes reaction on client side: The client adds the character to the shown map.
/// </summary>
public readonly struct AddCharactersToScope075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharactersToScope075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddCharactersToScope075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharactersToScope075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddCharactersToScope075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="CharacterData"/> of the specified index.
    /// </summary>
        public CharacterData this[int index] => new (this._data.Slice(5 + index * CharacterData.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddCharactersToScope075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddCharactersToScope075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddCharactersToScope075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddCharactersToScope075 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly struct CharacterData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 27;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(4, 9).Span;
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data.Span[13..].GetBoolean(0);
        set => this._data.Span[13..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data.Span[13..].GetBoolean(1);
        set => this._data.Span[13..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data.Span[13..].GetBoolean(2);
        set => this._data.Span[13..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data.Span[13..].GetBoolean(3);
        set => this._data.Span[13..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(14, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(14, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data.Span[24];
        set => this._data.Span[24] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data.Span[25];
        set => this._data.Span[25] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[26..].GetByteValue(4, 4);
        set => this._data.Span[26..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data.Span[26..].GetByteValue(4, 0);
        set => this._data.Span[26..].SetByteValue((byte)value, 4, 0);
    }
}
}


/// <summary>
/// Is sent by the server when: One or more character got into the observed scope of the player.
/// Causes reaction on client side: The client adds the character to the shown map.
/// </summary>
public readonly struct AddCharactersToScope095
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharactersToScope095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddCharactersToScope095(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddCharactersToScope095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddCharactersToScope095(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="CharacterData"/> of the specified index.
    /// </summary>
        public CharacterData this[int index] => new (this._data.Slice(5 + index * CharacterData.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddCharactersToScope095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddCharactersToScope095(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddCharactersToScope095"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddCharactersToScope095 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly struct CharacterData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 31;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(4, 13).Span;
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data.Span[17..].GetBoolean(0);
        set => this._data.Span[17..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data.Span[17..].GetBoolean(1);
        set => this._data.Span[17..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data.Span[17..].GetBoolean(2);
        set => this._data.Span[17..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data.Span[17..].GetBoolean(3);
        set => this._data.Span[17..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(18, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(18, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data.Span[28];
        set => this._data.Span[28] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data.Span[29];
        set => this._data.Span[29] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[30..].GetByteValue(4, 4);
        set => this._data.Span[30..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data.Span[30..].GetByteValue(4, 0);
        set => this._data.Span[30..].SetByteValue((byte)value, 4, 0);
    }
}
}


/// <summary>
/// Is sent by the server when: One or more NPCs got into the observed scope of the player.
/// Causes reaction on client side: The client adds the NPCs to the shown map.
/// </summary>
public readonly struct AddNpcsToScope
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddNpcsToScope"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddNpcsToScope(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddNpcsToScope"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddNpcsToScope(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the npc count.
    /// </summary>
    public byte NpcCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="NpcData"/> of the specified index.
    /// </summary>
        public NpcData this[int index] => new (this._data.Slice(5 + index * NpcData.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddNpcsToScope"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddNpcsToScope(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddNpcsToScope"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddNpcsToScope packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="NpcData"/>.
    /// </summary>
    /// <param name="nPCsCount">The count of <see cref="NpcData"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int nPCsCount) => nPCsCount * NpcData.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly struct NpcData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the type number.
    /// </summary>
    public ushort TypeNumber
    {
        get => ReadUInt16BigEndian(this._data.Span[2..]);
        set => WriteUInt16BigEndian(this._data.Span[2..], value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[8..].GetByteValue(4, 4);
        set => this._data.Span[8..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets defines the number of effects which would be sent after this field. This is currently not supported.
    /// </summary>
    public byte EffectCount
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: One or more NPCs got into the observed scope of the player.
/// Causes reaction on client side: The client adds the NPCs to the shown map.
/// </summary>
public readonly struct AddNpcsToScope075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddNpcsToScope075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddNpcsToScope075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddNpcsToScope075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddNpcsToScope075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the npc count.
    /// </summary>
    public byte NpcCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="NpcData"/> of the specified index.
    /// </summary>
        public NpcData this[int index] => new (this._data.Slice(5 + index * NpcData.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddNpcsToScope075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddNpcsToScope075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddNpcsToScope075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddNpcsToScope075 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="NpcData"/>.
    /// </summary>
    /// <param name="nPCsCount">The count of <see cref="NpcData"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int nPCsCount) => nPCsCount * NpcData.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly struct NpcData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the type number.
    /// </summary>
    public byte TypeNumber
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data.Span[3..].GetBoolean(0);
        set => this._data.Span[3..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data.Span[3..].GetBoolean(1);
        set => this._data.Span[3..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data.Span[3..].GetBoolean(2);
        set => this._data.Span[3..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data.Span[3..].GetBoolean(3);
        set => this._data.Span[3..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[8..].GetByteValue(4, 4);
        set => this._data.Span[8..].SetByteValue(value, 4, 4);
    }
}
}


/// <summary>
/// Is sent by the server when: One or more NPCs got into the observed scope of the player.
/// Causes reaction on client side: The client adds the NPCs to the shown map.
/// </summary>
public readonly struct AddNpcsToScope095
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddNpcsToScope095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddNpcsToScope095(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddNpcsToScope095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddNpcsToScope095(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the npc count.
    /// </summary>
    public byte NpcCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="NpcData"/> of the specified index.
    /// </summary>
        public NpcData this[int index] => new (this._data.Slice(5 + index * NpcData.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddNpcsToScope095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddNpcsToScope095(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddNpcsToScope095"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddNpcsToScope095 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="NpcData"/>.
    /// </summary>
    /// <param name="nPCsCount">The count of <see cref="NpcData"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int nPCsCount) => nPCsCount * NpcData.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly struct NpcData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the type number.
    /// </summary>
    public byte TypeNumber
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data.Span[4..].GetBoolean(0);
        set => this._data.Span[4..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data.Span[4..].GetBoolean(1);
        set => this._data.Span[4..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data.Span[4..].GetBoolean(2);
        set => this._data.Span[4..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data.Span[4..].GetBoolean(3);
        set => this._data.Span[4..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[10..].GetByteValue(4, 4);
        set => this._data.Span[10..].SetByteValue(value, 4, 4);
    }
}
}


/// <summary>
/// Is sent by the server when: One or more summoned monsters got into the observed scope of the player.
/// Causes reaction on client side: The client adds the monsters to the shown map.
/// </summary>
public readonly partial struct AddSummonedMonstersToScope
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddSummonedMonstersToScope(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddSummonedMonstersToScope(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1F;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the monster count.
    /// </summary>
    public byte MonsterCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddSummonedMonstersToScope"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddSummonedMonstersToScope(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddSummonedMonstersToScope"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddSummonedMonstersToScope packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="SummonedMonsterData"/> and it's size.
    /// </summary>
    /// <param name="summonedMonstersCount">The count of <see cref="SummonedMonsterData"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="SummonedMonsterData"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int summonedMonstersCount, int structLength) => summonedMonstersCount * structLength + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly struct SummonedMonsterData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SummonedMonsterData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SummonedMonsterData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the type number.
    /// </summary>
    public ushort TypeNumber
    {
        get => ReadUInt16BigEndian(this._data.Span[2..]);
        set => WriteUInt16BigEndian(this._data.Span[2..], value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[8..].GetByteValue(4, 4);
        set => this._data.Span[8..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the owner character name.
    /// </summary>
    public string OwnerCharacterName
    {
        get => this._data.Span.ExtractString(9, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(9, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets defines the number of effects which would be sent after this field. This is currently not supported.
    /// </summary>
    public byte EffectCount
    {
        get => this._data.Span[19];
        set => this._data.Span[19] = value;
    }

    /// <summary>
    /// Gets the <see cref="EffectId"/> of the specified index.
    /// </summary>
        public EffectId this[int index] => new (this._data.Slice(20 + index * EffectId.Length));

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="EffectId"/>.
    /// </summary>
    /// <param name="effectsCount">The count of <see cref="EffectId"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int effectsCount) => effectsCount * EffectId.Length + 20;
}


/// <summary>
/// Contains the id of a magic effect..
/// </summary>
public readonly struct EffectId
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EffectId"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EffectId(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 1;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public byte Id
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: One or more summoned monsters got into the observed scope of the player.
/// Causes reaction on client side: The client adds the monsters to the shown map.
/// </summary>
public readonly struct AddSummonedMonstersToScope075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddSummonedMonstersToScope075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddSummonedMonstersToScope075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1F;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the monster count.
    /// </summary>
    public byte MonsterCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="SummonedMonsterData"/> of the specified index.
    /// </summary>
        public SummonedMonsterData this[int index] => new (this._data.Slice(5 + index * SummonedMonsterData.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddSummonedMonstersToScope075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddSummonedMonstersToScope075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddSummonedMonstersToScope075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddSummonedMonstersToScope075 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="SummonedMonsterData"/>.
    /// </summary>
    /// <param name="summonedMonstersCount">The count of <see cref="SummonedMonsterData"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int summonedMonstersCount) => summonedMonstersCount * SummonedMonsterData.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly struct SummonedMonsterData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SummonedMonsterData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SummonedMonsterData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 19;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the type number.
    /// </summary>
    public byte TypeNumber
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data.Span[3..].GetBoolean(0);
        set => this._data.Span[3..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data.Span[3..].GetBoolean(1);
        set => this._data.Span[3..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data.Span[3..].GetBoolean(2);
        set => this._data.Span[3..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data.Span[3..].GetBoolean(3);
        set => this._data.Span[3..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[8..].GetByteValue(4, 4);
        set => this._data.Span[8..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the owner character name.
    /// </summary>
    public string OwnerCharacterName
    {
        get => this._data.Span.ExtractString(9, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(9, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }
}
}


/// <summary>
/// Is sent by the server when: One or more summoned monsters got into the observed scope of the player.
/// Causes reaction on client side: The client adds the monsters to the shown map.
/// </summary>
public readonly struct AddSummonedMonstersToScope095
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddSummonedMonstersToScope095(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddSummonedMonstersToScope095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddSummonedMonstersToScope095(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1F;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the monster count.
    /// </summary>
    public byte MonsterCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="SummonedMonsterData"/> of the specified index.
    /// </summary>
        public SummonedMonsterData this[int index] => new (this._data.Slice(5 + index * SummonedMonsterData.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddSummonedMonstersToScope095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddSummonedMonstersToScope095(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddSummonedMonstersToScope095"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddSummonedMonstersToScope095 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="SummonedMonsterData"/>.
    /// </summary>
    /// <param name="summonedMonstersCount">The count of <see cref="SummonedMonsterData"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int summonedMonstersCount) => summonedMonstersCount * SummonedMonsterData.Length + 5;


/// <summary>
/// Contains the data of an NPC..
/// </summary>
public readonly struct SummonedMonsterData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SummonedMonsterData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SummonedMonsterData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 20;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the type number.
    /// </summary>
    public byte TypeNumber
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data.Span[4..].GetBoolean(0);
        set => this._data.Span[4..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data.Span[4..].GetBoolean(1);
        set => this._data.Span[4..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data.Span[4..].GetBoolean(2);
        set => this._data.Span[4..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data.Span[4..].GetBoolean(3);
        set => this._data.Span[4..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[9..].GetByteValue(4, 4);
        set => this._data.Span[9..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the owner character name.
    /// </summary>
    public string OwnerCharacterName
    {
        get => this._data.Span.ExtractString(10, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(10, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }
}
}


/// <summary>
/// Is sent by the server when: One or more objects (player, npc, etc.) on the map got out of scope, e.g. when the own player moved away from it/them or the object itself moved.
/// Causes reaction on client side: The game client removes the objects from the game map.
/// </summary>
public readonly struct MapObjectOutOfScope
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MapObjectOutOfScope"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MapObjectOutOfScope(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MapObjectOutOfScope"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MapObjectOutOfScope(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the object count.
    /// </summary>
    public byte ObjectCount
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets the <see cref="ObjectId"/> of the specified index.
    /// </summary>
        public ObjectId this[int index] => new (this._data.Slice(4 + index * ObjectId.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MapObjectOutOfScope"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MapObjectOutOfScope(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MapObjectOutOfScope"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MapObjectOutOfScope packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="ObjectId"/>.
    /// </summary>
    /// <param name="objectsCount">The count of <see cref="ObjectId"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int objectsCount) => objectsCount * ObjectId.Length + 4;


/// <summary>
/// Contains the id of a object..
/// </summary>
public readonly struct ObjectId
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectId"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectId(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 2;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }
}
}


/// <summary>
/// Is sent by the server when: An observed object was killed.
/// Causes reaction on client side: The object is shown as dead.
/// </summary>
public readonly struct ObjectGotKilled
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectGotKilled"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectGotKilled(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectGotKilled"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectGotKilled(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x17;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the killed id.
    /// </summary>
    public ushort KilledId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the killer id.
    /// </summary>
    public ushort KillerId
    {
        get => ReadUInt16BigEndian(this._data.Span[7..]);
        set => WriteUInt16BigEndian(this._data.Span[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ObjectGotKilled"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectGotKilled(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectGotKilled"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ObjectGotKilled packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs an animation.
/// Causes reaction on client side: The animation is shown for the specified object.
/// </summary>
public readonly struct ObjectAnimation
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectAnimation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectAnimation(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectAnimation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectAnimation(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x18;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the direction.
    /// </summary>
    public byte Direction
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the animation.
    /// </summary>
    public byte Animation
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data.Span[7..]);
        set => WriteUInt16BigEndian(this._data.Span[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ObjectAnimation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectAnimation(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectAnimation"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ObjectAnimation packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs a skill which has effect on an area.
/// Causes reaction on client side: The animation is shown on the user interface.
/// </summary>
public readonly struct AreaSkillAnimation
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillAnimation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AreaSkillAnimation(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillAnimation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AreaSkillAnimation(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1E;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the point x.
    /// </summary>
    public byte PointX
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the point y.
    /// </summary>
    public byte PointY
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AreaSkillAnimation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AreaSkillAnimation(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AreaSkillAnimation"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AreaSkillAnimation packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs a skill which is directly targeted to another object.
/// Causes reaction on client side: The animation is shown on the user interface.
/// </summary>
public readonly struct SkillAnimation
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAnimation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillAnimation(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAnimation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillAnimation(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x19;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data.Span[7..]);
        set => WriteUInt16BigEndian(this._data.Span[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SkillAnimation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillAnimation(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillAnimation"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SkillAnimation packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs a skill which has effect on an area.
/// Causes reaction on client side: The animation is shown on the user interface.
/// </summary>
public readonly struct AreaSkillAnimation075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillAnimation075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AreaSkillAnimation075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillAnimation075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AreaSkillAnimation075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1E;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public byte SkillId
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the point x.
    /// </summary>
    public byte PointX
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the point y.
    /// </summary>
    public byte PointY
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AreaSkillAnimation075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AreaSkillAnimation075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AreaSkillAnimation075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AreaSkillAnimation075 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs a skill which has effect on an area.
/// Causes reaction on client side: The animation is shown on the user interface.
/// </summary>
public readonly struct AreaSkillAnimation095
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillAnimation095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AreaSkillAnimation095(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AreaSkillAnimation095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AreaSkillAnimation095(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1E;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public byte SkillId
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the point x.
    /// </summary>
    public byte PointX
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the point y.
    /// </summary>
    public byte PointY
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AreaSkillAnimation095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AreaSkillAnimation095(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AreaSkillAnimation095"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AreaSkillAnimation095 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs a skill which is directly targeted to another object.
/// Causes reaction on client side: The animation is shown on the user interface.
/// </summary>
public readonly struct SkillAnimation075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAnimation075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillAnimation075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAnimation075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillAnimation075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x19;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public byte SkillId
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the effect applied.
    /// </summary>
    public bool EffectApplied
    {
        get => this._data.Span[6..].GetBoolean(7);
        set => this._data.Span[6..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SkillAnimation075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillAnimation075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillAnimation075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SkillAnimation075 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object performs a skill which is directly targeted to another object.
/// Causes reaction on client side: The animation is shown on the user interface.
/// </summary>
public readonly struct SkillAnimation095
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAnimation095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillAnimation095(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAnimation095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillAnimation095(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x19;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public byte SkillId
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the effect applied.
    /// </summary>
    public bool EffectApplied
    {
        get => this._data.Span[6..].GetBoolean(7);
        set => this._data.Span[6..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SkillAnimation095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillAnimation095(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillAnimation095"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SkillAnimation095 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player cancelled a specific magic effect of a skill (Infinity Arrow, Wizardry Enhance), or an effect was removed due a timeout (Ice, Poison) or antidote.
/// Causes reaction on client side: The effect is removed from the target object.
/// </summary>
public readonly struct MagicEffectCancelled
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectCancelled"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MagicEffectCancelled(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectCancelled"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MagicEffectCancelled(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MagicEffectCancelled"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MagicEffectCancelled(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MagicEffectCancelled"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MagicEffectCancelled packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player cancelled a specific magic effect of a skill (Infinity Arrow, Wizardry Enhance), or an effect was removed due a timeout (Ice, Poison) or antidote.
/// Causes reaction on client side: The effect is removed from the target object.
/// </summary>
public readonly struct MagicEffectCancelled075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectCancelled075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MagicEffectCancelled075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MagicEffectCancelled075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MagicEffectCancelled075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public byte SkillId
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MagicEffectCancelled075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MagicEffectCancelled075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MagicEffectCancelled075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MagicEffectCancelled075 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player (rage fighter) performs the dark side skill on a target and sent a RageAttackRangeRequest.
/// Causes reaction on client side: The targets are attacked with visual effects.
/// </summary>
public readonly struct RageAttack
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RageAttack"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RageAttack(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RageAttack"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RageAttack(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x4A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the source id.
    /// </summary>
    public ushort SourceId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data.Span[7..]);
        set => WriteUInt16BigEndian(this._data.Span[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="RageAttack"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RageAttack(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RageAttack"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(RageAttack packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player (rage fighter) performs the dark side skill on a target and sent a RageAttackRangeRequest.
/// Causes reaction on client side: The targets are attacked with visual effects.
/// </summary>
public readonly struct RageAttackRangeResponse
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RageAttackRangeResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RageAttackRangeResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RageAttackRangeResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RageAttackRangeResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x4B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill id.
    /// </summary>
    public ushort SkillId
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets the <see cref="RageTarget"/> of the specified index.
    /// </summary>
        public RageTarget this[int index] => new (this._data.Slice(6 + index * RageTarget.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="RageAttackRangeResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RageAttackRangeResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RageAttackRangeResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(RageAttackRangeResponse packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="RageTarget"/>.
    /// </summary>
    /// <param name="targetsCount">The count of <see cref="RageTarget"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int targetsCount) => targetsCount * RageTarget.Length + 6;


/// <summary>
/// Contains the target identifier..
/// </summary>
public readonly struct RageTarget
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RageTarget"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RageTarget(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 2;

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16LittleEndian(this._data.Span);
        set => WriteUInt16LittleEndian(this._data.Span, value);
    }
}
}


/// <summary>
/// Is sent by the server when: The appearance of a player changed, all surrounding players are informed about it.
/// Causes reaction on client side: The appearance of the player is updated.
/// </summary>
public readonly struct AppearanceChanged
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AppearanceChanged"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AppearanceChanged(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AppearanceChanged"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AppearanceChanged(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x25;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the changed player id.
    /// </summary>
    public ushort ChangedPlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(5).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AppearanceChanged"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AppearanceChanged(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AppearanceChanged"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AppearanceChanged packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
}


/// <summary>
/// Is sent by the server when: The appearance of a player changed, all surrounding players are informed about it.
/// Causes reaction on client side: The appearance of the player is updated.
/// </summary>
public readonly struct AppearanceChangedExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AppearanceChangedExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AppearanceChangedExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AppearanceChangedExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AppearanceChangedExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x25;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the changed player id.
    /// </summary>
    public ushort ChangedPlayerId
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the item group.
    /// </summary>
    public byte ItemGroup
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the item number.
    /// </summary>
    public ushort ItemNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[8..]);
        set => WriteUInt16LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the item level.
    /// </summary>
    public byte ItemLevel
    {
        get => this._data.Span[10];
        set => this._data.Span[10] = value;
    }

    /// <summary>
    /// Gets or sets the excellent flags.
    /// </summary>
    public byte ExcellentFlags
    {
        get => this._data.Span[11];
        set => this._data.Span[11] = value;
    }

    /// <summary>
    /// Gets or sets the ancient discriminator.
    /// </summary>
    public byte AncientDiscriminator
    {
        get => this._data.Span[12];
        set => this._data.Span[12] = value;
    }

    /// <summary>
    /// Gets or sets the is ancient set complete.
    /// </summary>
    public bool IsAncientSetComplete
    {
        get => this._data.Span[13..].GetBoolean();
        set => this._data.Span[13..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AppearanceChangedExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AppearanceChangedExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AppearanceChangedExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AppearanceChangedExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The server wants to show a message above any kind of character, even NPCs.
/// Causes reaction on client side: The message is shown above the character.
/// </summary>
public readonly struct ObjectMessage
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectMessage"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectMessage(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectMessage"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectMessage(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x01;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the message.
    /// </summary>
    public string Message
    {
        get => this._data.Span.ExtractString(5, this._data.Length - 5, System.Text.Encoding.UTF8);
        set => this._data.Slice(5).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ObjectMessage"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectMessage(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectMessage"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ObjectMessage packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 5;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 5;
}


/// <summary>
/// Is sent by the server when: Another player requests party from the receiver of this message.
/// Causes reaction on client side: The party request is shown.
/// </summary>
public readonly struct PartyRequest
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyRequest"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyRequest(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyRequest"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PartyRequest(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the requester id.
    /// </summary>
    public ushort RequesterId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PartyRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PartyRequest(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PartyRequest"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PartyRequest packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player joined a party or requested the current party list by opening the party dialog.
/// Causes reaction on client side: The party list is updated.
/// </summary>
public readonly struct PartyList
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyList(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PartyList(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x42;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the count.
    /// </summary>
    public byte Count
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="PartyMember"/> of the specified index.
    /// </summary>
        public PartyMember this[int index] => new (this._data.Slice(5 + index * PartyMember.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PartyList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PartyList(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PartyList"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PartyList packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PartyMember"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="PartyMember"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * PartyMember.Length + 5;


/// <summary>
/// Data about a party member..
/// </summary>
public readonly struct PartyMember
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyMember"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyMember(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the index.
    /// </summary>
    public byte Index
    {
        get => this._data.Span[10];
        set => this._data.Span[10] = value;
    }

    /// <summary>
    /// Gets or sets the map id.
    /// </summary>
    public byte MapId
    {
        get => this._data.Span[11];
        set => this._data.Span[11] = value;
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[12];
        set => this._data.Span[12] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[13];
        set => this._data.Span[13] = value;
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public uint CurrentHealth
    {
        get => ReadUInt32LittleEndian(this._data.Span[16..]);
        set => WriteUInt32LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public uint MaximumHealth
    {
        get => ReadUInt32LittleEndian(this._data.Span[20..]);
        set => WriteUInt32LittleEndian(this._data.Span[20..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: A player joined a party or requested the current party list by opening the party dialog.
/// Causes reaction on client side: The party list is updated.
/// </summary>
public readonly struct PartyList075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyList075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyList075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyList075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PartyList075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x42;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the count.
    /// </summary>
    public byte Count
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="PartyMember"/> of the specified index.
    /// </summary>
        public PartyMember this[int index] => new (this._data.Slice(5 + index * PartyMember.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PartyList075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PartyList075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PartyList075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PartyList075 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PartyMember"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="PartyMember"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * PartyMember.Length + 5;


/// <summary>
/// Data about a party member..
/// </summary>
public readonly struct PartyMember
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyMember"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyMember(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the index.
    /// </summary>
    public byte Index
    {
        get => this._data.Span[10];
        set => this._data.Span[10] = value;
    }

    /// <summary>
    /// Gets or sets the map id.
    /// </summary>
    public byte MapId
    {
        get => this._data.Span[11];
        set => this._data.Span[11] = value;
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[12];
        set => this._data.Span[12] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[13];
        set => this._data.Span[13] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: A party member got removed from a party in which the player is in.
/// Causes reaction on client side: The party member with the specified index is removed from the party list on the user interface.
/// </summary>
public readonly struct RemovePartyMember
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RemovePartyMember"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RemovePartyMember(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RemovePartyMember"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RemovePartyMember(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x43;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the index.
    /// </summary>
    public byte Index
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="RemovePartyMember"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RemovePartyMember(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RemovePartyMember"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(RemovePartyMember packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Periodically, when the health state of the party changed.
/// Causes reaction on client side: The party health list is updated.
/// </summary>
public readonly struct PartyHealthUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyHealthUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyHealthUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyHealthUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PartyHealthUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x44;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the count.
    /// </summary>
    public byte Count
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets the <see cref="PartyMemberHealth"/> of the specified index.
    /// </summary>
        public PartyMemberHealth this[int index] => new (this._data.Slice(4 + index * PartyMemberHealth.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PartyHealthUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PartyHealthUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PartyHealthUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PartyHealthUpdate packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PartyMemberHealth"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="PartyMemberHealth"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * PartyMemberHealth.Length + 4;


/// <summary>
/// Health of a party member.
/// </summary>
public readonly struct PartyMemberHealth
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PartyMemberHealth"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PartyMemberHealth(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 1;

    /// <summary>
    /// Gets or sets the index.
    /// </summary>
    public byte Index
    {
        get => this._data.Span.GetByteValue(4, 4);
        set => this._data.Span.SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets a value from 0 to 10 about the health of a player. 10 means the current health is 100% of the maximum health.
    /// </summary>
    public byte Value
    {
        get => this._data.Span.GetByteValue(4, 0);
        set => this._data.Span.SetByteValue(value, 4, 0);
    }
}
}


/// <summary>
/// Is sent by the server when: After the player requested to open his shop and this request was successful.
/// Causes reaction on client side: The own player shop is shown as open.
/// </summary>
public readonly struct PlayerShopOpenSuccessful
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopOpenSuccessful"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopOpenSuccessful(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopOpenSuccessful"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopOpenSuccessful(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Success = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x2;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[4..].GetBoolean();
        set => this._data.Span[4..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PlayerShopOpenSuccessful"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopOpenSuccessful(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopOpenSuccessful"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PlayerShopOpenSuccessful packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the trading partner checked or unchecked the trade accept button.
/// Causes reaction on client side: The game client updates the trade button state accordingly.
/// </summary>
public readonly struct TradeButtonStateChanged
{
    /// <summary>
    /// Defines the state of the trade button.
    /// </summary>
    public enum TradeButtonState
    {
        /// <summary>
        /// Trade button is not pressed. It means that the trade is not yet accepted by the trader.
        /// </summary>
            Unchecked = 0,

        /// <summary>
        /// Trade Button is pressed. It means that the trade is accepted by the trader.
        /// </summary>
            Checked = 1,

        /// <summary>
        /// This state is only sent to the client. After some seconds the client is changing back to normal Unchecked.
        /// </summary>
            Red = 2,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeButtonStateChanged"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeButtonStateChanged(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeButtonStateChanged"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeButtonStateChanged(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the state.
    /// </summary>
    public TradeButtonStateChanged.TradeButtonState State
    {
        get => (TradeButtonState)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="TradeButtonStateChanged"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeButtonStateChanged(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeButtonStateChanged"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(TradeButtonStateChanged packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The trade money has been set by a previous request of the player.
/// Causes reaction on client side: The money which was set into the trade by the player is updated on the UI.
/// </summary>
public readonly struct TradeMoneySetResponse
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeMoneySetResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeMoneySetResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeMoneySetResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeMoneySetResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3A;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="TradeMoneySetResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeMoneySetResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeMoneySetResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(TradeMoneySetResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: This message is sent when the trading partner put a certain amount of money (also 0) into the trade.
/// Causes reaction on client side: It overrides all previous sent money values.
/// </summary>
public readonly struct TradeMoneyUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeMoneyUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeMoneyUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeMoneyUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeMoneyUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the money amount.
    /// </summary>
    public uint MoneyAmount
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="TradeMoneyUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeMoneyUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeMoneyUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(TradeMoneyUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player which receives this message, sent a trade request to another player. This message is sent when the other player responded to this request.
/// Causes reaction on client side: If the trade was accepted, a trade dialog is opened. Otherwise, a message is shown.
/// </summary>
public readonly struct TradeRequestAnswer
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeRequestAnswer"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeRequestAnswer(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeRequestAnswer"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeRequestAnswer(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x37;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 20;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the accepted.
    /// </summary>
    public bool Accepted
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the trade partner level.
    /// </summary>
    public ushort TradePartnerLevel
    {
        get => ReadUInt16BigEndian(this._data.Span[14..]);
        set => WriteUInt16BigEndian(this._data.Span[14..], value);
    }

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public uint GuildId
    {
        get => ReadUInt32LittleEndian(this._data.Span[16..]);
        set => WriteUInt32LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="TradeRequestAnswer"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeRequestAnswer(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeRequestAnswer"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(TradeRequestAnswer packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A trade was requested by another player.
/// Causes reaction on client side: A trade request dialog is shown.
/// </summary>
public readonly struct TradeRequest
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeRequest"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeRequest(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeRequest"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeRequest(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x36;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="TradeRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeRequest(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeRequest"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(TradeRequest packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A trade was finished.
/// Causes reaction on client side: The trade dialog is closed. Depending on the result, a message is shown.
/// </summary>
public readonly struct TradeFinished
{
    /// <summary>
    /// Defines the result of a finished trade.
    /// </summary>
    public enum TradeResult
    {
        /// <summary>
        /// The trade was cancelled.
        /// </summary>
            Cancelled = 0,

        /// <summary>
        /// The trade was successful.
        /// </summary>
            Success = 1,

        /// <summary>
        /// The trade failed because of a full inventory.
        /// </summary>
            FailedByFullInventory = 2,

        /// <summary>
        /// The trade failed because the request timed out.
        /// </summary>
            TimedOut = 3,

        /// <summary>
        /// The trade failed because one or more items were not allowed to trade.
        /// </summary>
            FailedByItemsNotAllowedToTrade = 4,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeFinished"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeFinished(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeFinished"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeFinished(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public TradeFinished.TradeResult Result
    {
        get => (TradeResult)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="TradeFinished"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeFinished(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeFinished"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(TradeFinished packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The trading partner added an item to the trade.
/// Causes reaction on client side: The item is added in the trade dialog.
/// </summary>
public readonly struct TradeItemAdded
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeItemAdded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeItemAdded(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeItemAdded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeItemAdded(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x39;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the to slot.
    /// </summary>
    public byte ToSlot
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(4).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="TradeItemAdded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeItemAdded(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeItemAdded"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(TradeItemAdded packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
}


/// <summary>
/// Is sent by the server when: The trading partner removed an item from the trade.
/// Causes reaction on client side: The item is removed from the trade dialog.
/// </summary>
public readonly struct TradeItemRemoved
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeItemRemoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TradeItemRemoved(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TradeItemRemoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private TradeItemRemoved(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x38;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the slot.
    /// </summary>
    public byte Slot
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="TradeItemRemoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator TradeItemRemoved(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="TradeItemRemoved"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(TradeItemRemoved packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the login request has been processed by the server.
/// Causes reaction on client side: Shows the result. When it was successful, the client proceeds by sending a character list request.
/// </summary>
public readonly struct LoginResponse
{
    /// <summary>
    /// The result of a login request.
    /// </summary>
    public enum LoginResult
    {
        /// <summary>
        /// The password was wrong.
        /// </summary>
            InvalidPassword = 0,

        /// <summary>
        /// The login succeeded.
        /// </summary>
            Okay = 1,

        /// <summary>
        /// The account is invalid.
        /// </summary>
            AccountInvalid = 2,

        /// <summary>
        /// The account is already connected.
        /// </summary>
            AccountAlreadyConnected = 3,

        /// <summary>
        /// The server is full.
        /// </summary>
            ServerIsFull = 4,

        /// <summary>
        /// The account is blocked.
        /// </summary>
            AccountBlocked = 5,

        /// <summary>
        /// The game client has the wrong version.
        /// </summary>
            WrongVersion = 6,

        /// <summary>
        /// An internal error occured during connection.
        /// </summary>
            ConnectionError = 7,

        /// <summary>
        /// Connection closed because of three failed login requests.
        /// </summary>
            ConnectionClosed3Fails = 8,

        /// <summary>
        /// There is no payment information.
        /// </summary>
            NoChargeInfo = 9,

        /// <summary>
        /// The subscription term is over.
        /// </summary>
            SubscriptionTermOver = 10,

        /// <summary>
        /// The subscription time is over.
        /// </summary>
            SubscriptionTimeOver = 11,

        /// <summary>
        /// The account is temporarily blocked.
        /// </summary>
            TemporaryBlocked = 14,

        /// <summary>
        /// Only players over 15 years are allowed to connect.
        /// </summary>
            OnlyPlayersOver15Yrs = 17,

        /// <summary>
        /// The client connected from a blocked country.
        /// </summary>
            BadCountry = 210,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LoginResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LoginResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LoginResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LoginResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public LoginResponse.LoginResult Success
    {
        get => (LoginResult)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="LoginResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LoginResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LoginResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(LoginResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the logout request has been processed by the server.
/// Causes reaction on client side: Depending on the result, the game client closes the game or changes to another selection screen.
/// </summary>
public readonly struct LogoutResponse
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LogoutResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LogoutResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LogoutResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LogoutResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public LogOutType Type
    {
        get => (LogOutType)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="LogoutResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LogoutResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LogoutResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(LogoutResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player sends a chat message.
/// Causes reaction on client side: The message is shown in the chat box and above the character of the sender.
/// </summary>
public readonly struct ChatMessage
{
    /// <summary>
    /// Defines the type of a chat message.
    /// </summary>
    public enum ChatMessageType
    {
        /// <summary>
        /// The message is a normal chat message, e.g. public, within a party or guild.
        /// </summary>
            Normal = 0,

        /// <summary>
        /// The message is sent privately to the receiving player.
        /// </summary>
            Whisper = 2,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatMessage"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChatMessage(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatMessage"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChatMessage(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x00;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public ChatMessage.ChatMessageType Type
    {
        get => (ChatMessageType)this._data.Span[2];
        set => this._data.Span[2] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the sender.
    /// </summary>
    public string Sender
    {
        get => this._data.Span.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the message.
    /// </summary>
    public string Message
    {
        get => this._data.Span.ExtractString(13, this._data.Length - 13, System.Text.Encoding.UTF8);
        set => this._data.Slice(13).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ChatMessage"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChatMessage(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChatMessage"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ChatMessage packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 13;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 13;
}


/// <summary>
/// Is sent by the server when: An object got hit in two cases: 1. When the own player is hit; 2. When the own player attacked some other object which got hit.
/// Causes reaction on client side: The damage is shown at the object which received the hit.
/// </summary>
public readonly struct ObjectHit
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectHit"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectHit(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectHit"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectHit(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the header code.
    /// </summary>
    public byte HeaderCode
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the health damage.
    /// </summary>
    public ushort HealthDamage
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the kind.
    /// </summary>
    public DamageKind Kind
    {
        get => (DamageKind)this._data.Span[7..].GetByteValue(4, 0);
        set => this._data.Span[7..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the is double damage.
    /// </summary>
    public bool IsDoubleDamage
    {
        get => this._data.Span[7..].GetBoolean(6);
        set => this._data.Span[7..].SetBoolean(value, 6);
    }

    /// <summary>
    /// Gets or sets the is triple damage.
    /// </summary>
    public bool IsTripleDamage
    {
        get => this._data.Span[7..].GetBoolean(7);
        set => this._data.Span[7..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Gets or sets the shield damage.
    /// </summary>
    public ushort ShieldDamage
    {
        get => ReadUInt16BigEndian(this._data.Span[8..]);
        set => WriteUInt16BigEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ObjectHit"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectHit(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectHit"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ObjectHit packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object got hit in two cases: 1. When the own player is hit; 2. When the own player attacked some other object which got hit.
/// Causes reaction on client side: The damage is shown at the object which received the hit.
/// </summary>
public readonly struct ObjectHitExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectHitExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectHitExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectHitExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectHitExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the kind.
    /// </summary>
    public DamageKind Kind
    {
        get => (DamageKind)this._data.Span[3..].GetByteValue(4, 0);
        set => this._data.Span[3..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the is double damage.
    /// </summary>
    public bool IsDoubleDamage
    {
        get => this._data.Span[3..].GetBoolean(6);
        set => this._data.Span[3..].SetBoolean(value, 6);
    }

    /// <summary>
    /// Gets or sets the is triple damage.
    /// </summary>
    public bool IsTripleDamage
    {
        get => this._data.Span[3..].GetBoolean(7);
        set => this._data.Span[3..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets gets or sets the status of the remaining health in fractions of 1/250.
    /// </summary>
    public byte HealthStatus
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets gets or sets the status of the remaining shield in fractions of 1/250.
    /// </summary>
    public byte ShieldStatus
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the health damage.
    /// </summary>
    public uint HealthDamage
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the shield damage.
    /// </summary>
    public uint ShieldDamage
    {
        get => ReadUInt32LittleEndian(this._data.Span[12..]);
        set => WriteUInt32LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ObjectHitExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectHitExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectHitExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ObjectHitExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object in the observed scope (including the own player) moved instantly.
/// Causes reaction on client side: The position of the object is updated on client side.
/// </summary>
public readonly struct ObjectMoved
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectMoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectMoved(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectMoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectMoved(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x15;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the header code.
    /// </summary>
    public byte HeaderCode
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ObjectMoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectMoved(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectMoved"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ObjectMoved packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An object in the observed scope (including the own player) walked to another position.
/// Causes reaction on client side: The object is animated to walk to the new position.
/// </summary>
public readonly struct ObjectWalked
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectWalked"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectWalked(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectWalked"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectWalked(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the header code.
    /// </summary>
    public byte HeaderCode
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the target rotation.
    /// </summary>
    public byte TargetRotation
    {
        get => this._data.Span[7..].GetByteValue(4, 4);
        set => this._data.Span[7..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the step count.
    /// </summary>
    public byte StepCount
    {
        get => this._data.Span[7..].GetByteValue(4, 0);
        set => this._data.Span[7..].SetByteValue(value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the step data.
    /// </summary>
    public Span<byte> StepData
    {
        get => this._data.Slice(8).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ObjectWalked"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectWalked(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectWalked"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ObjectWalked packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="StepData"/>.
    /// </summary>
    /// <param name="stepDataLength">The length in bytes of <see cref="StepData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int stepDataLength) => stepDataLength + 8;
}


/// <summary>
/// Is sent by the server when: An object in the observed scope (including the own player) walked to another position.
/// Causes reaction on client side: The object is animated to walk to the new position.
/// </summary>
public readonly struct ObjectWalkedExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectWalkedExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectWalkedExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectWalkedExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectWalkedExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xD4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the header code.
    /// </summary>
    public byte HeaderCode
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the source x.
    /// </summary>
    public byte SourceX
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the source y.
    /// </summary>
    public byte SourceY
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the target rotation.
    /// </summary>
    public byte TargetRotation
    {
        get => this._data.Span[9..].GetByteValue(4, 4);
        set => this._data.Span[9..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the step count.
    /// </summary>
    public byte StepCount
    {
        get => this._data.Span[9..].GetByteValue(4, 0);
        set => this._data.Span[9..].SetByteValue(value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the step data.
    /// </summary>
    public Span<byte> StepData
    {
        get => this._data.Slice(10).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ObjectWalkedExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectWalkedExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectWalkedExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ObjectWalkedExtended packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="StepData"/>.
    /// </summary>
    /// <param name="stepDataLength">The length in bytes of <see cref="StepData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int stepDataLength) => stepDataLength + 10;
}


/// <summary>
/// Is sent by the server when: An object in the observed scope (including the own player) walked to another position.
/// Causes reaction on client side: The object is animated to walk to the new position.
/// </summary>
public readonly struct ObjectWalked075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectWalked075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ObjectWalked075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ObjectWalked075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ObjectWalked075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x10;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the target x.
    /// </summary>
    public byte TargetX
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the target y.
    /// </summary>
    public byte TargetY
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the target rotation.
    /// </summary>
    public byte TargetRotation
    {
        get => this._data.Span[7..].GetByteValue(4, 4);
        set => this._data.Span[7..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ObjectWalked075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ObjectWalked075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ObjectWalked075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ObjectWalked075 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player gained experience.
/// Causes reaction on client side: The experience is added to the experience counter and bar.
/// </summary>
public readonly struct ExperienceGained
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ExperienceGained"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ExperienceGained(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ExperienceGained"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ExperienceGained(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x16;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the killed object id.
    /// </summary>
    public ushort KilledObjectId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the added experience.
    /// </summary>
    public ushort AddedExperience
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the damage of last hit.
    /// </summary>
    public ushort DamageOfLastHit
    {
        get => ReadUInt16BigEndian(this._data.Span[7..]);
        set => WriteUInt16BigEndian(this._data.Span[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ExperienceGained"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ExperienceGained(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ExperienceGained"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ExperienceGained packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player gained experience.
/// Causes reaction on client side: The experience is added to the experience counter and bar.
/// </summary>
public readonly struct ExperienceGainedExtended
{
    /// <summary>
    /// Defines the result and type of experience which is added.
    /// </summary>
    public enum AddResult
    {
        /// <summary>
        /// Undefined, no experience is added.
        /// </summary>
            Undefined = 0,

        /// <summary>
        /// The normal experience is added.
        /// </summary>
            Normal = 1,

        /// <summary>
        /// The master experience is added.
        /// </summary>
            Master = 2,

        /// <summary>
        /// The maximum level has been reached, no experience is added.
        /// </summary>
            MaxLevelReached = 16,

        /// <summary>
        /// The maximum master level has been reached, no master experience is added.
        /// </summary>
            MaxMasterLevelReached = 32,

        /// <summary>
        /// The monster level is too low for master experience, no master experience is added.
        /// </summary>
            MonsterLevelTooLowForMasterExperience = 33,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ExperienceGainedExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ExperienceGainedExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ExperienceGainedExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ExperienceGainedExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x16;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public ExperienceGainedExtended.AddResult Type
    {
        get => (AddResult)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the added experience.
    /// </summary>
    public uint AddedExperience
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the damage of last hit.
    /// </summary>
    public uint DamageOfLastHit
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the killed object id.
    /// </summary>
    public ushort KilledObjectId
    {
        get => ReadUInt16LittleEndian(this._data.Span[12..]);
        set => WriteUInt16LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the killer object id.
    /// </summary>
    public ushort KillerObjectId
    {
        get => ReadUInt16LittleEndian(this._data.Span[14..]);
        set => WriteUInt16LittleEndian(this._data.Span[14..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ExperienceGainedExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ExperienceGainedExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ExperienceGainedExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ExperienceGainedExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The map was changed on the server side.
/// Causes reaction on client side: The game client changes to the specified map and coordinates.
/// </summary>
public readonly struct MapChanged
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MapChanged"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MapChanged(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MapChanged"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MapChanged(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.IsMapChange = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1C;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0F;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 15;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets if false, it shows the teleport animation (white bubbles), and the client doesn't remove all of the objects in its scope.
    /// </summary>
    public bool IsMapChange
    {
        get => this._data.Span[4..].GetBoolean();
        set => this._data.Span[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public ushort MapNumber
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MapChanged"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MapChanged(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MapChanged"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MapChanged packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The map was changed on the server side.
/// Causes reaction on client side: The game client changes to the specified map and coordinates.
/// </summary>
public readonly struct MapChanged075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MapChanged075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MapChanged075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MapChanged075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MapChanged075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.IsMapChange = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x1C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets if false, it shows the teleport animation (white bubbles), and the client doesn't remove all of the objects in its scope.
    /// </summary>
    public bool IsMapChange
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public byte MapNumber
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MapChanged075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MapChanged075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MapChanged075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MapChanged075 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When entering the game world with a character.
/// Causes reaction on client side: The client restores this configuration in its user interface.
/// </summary>
public readonly struct ApplyKeyConfiguration
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ApplyKeyConfiguration"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ApplyKeyConfiguration(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ApplyKeyConfiguration"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ApplyKeyConfiguration(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x30;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the binary data of the key configuration
    /// </summary>
    public Span<byte> Configuration
    {
        get => this._data.Slice(4).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ApplyKeyConfiguration"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ApplyKeyConfiguration(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ApplyKeyConfiguration"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ApplyKeyConfiguration packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="Configuration"/>.
    /// </summary>
    /// <param name="configurationLength">The length in bytes of <see cref="Configuration"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int configurationLength) => configurationLength + 4;
}


/// <summary>
/// Is sent by the server when: The items dropped on the ground.
/// Causes reaction on client side: The client adds the items to the ground.
/// </summary>
public readonly struct ItemsDropped
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemsDropped"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemsDropped(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemsDropped"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemsDropped(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x20;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="DroppedItem"/> of the specified index.
    /// </summary>
        public DroppedItem this[int index, int droppedItemLength] => new (this._data.Slice(5 + index * droppedItemLength));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemsDropped"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemsDropped(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemsDropped"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemsDropped packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="DroppedItem"/> and it's size.
    /// </summary>
    /// <param name="itemsCount">The count of <see cref="DroppedItem"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="DroppedItem"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 5;


/// <summary>
/// Contains the data about a dropped item..
/// </summary>
public readonly struct DroppedItem
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DroppedItem"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DroppedItem(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets if this flag is set, the item is added to the map with an animation and sound. Otherwise it's just added like it was already on the ground before.
    /// </summary>
    public bool IsFreshDrop
    {
        get => this._data.Span.GetBoolean(7);
        set => this._data.Span.SetBoolean(value, 7);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(4).Span;
    }

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
}
}


/// <summary>
/// Is sent by the server when: Money dropped on the ground.
/// Causes reaction on client side: The client adds the money to the ground.
/// </summary>
public readonly partial struct MoneyDropped
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MoneyDropped"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MoneyDropped(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MoneyDropped"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MoneyDropped(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)Math.Min(data.Length, Length);
            this.ItemCount = 1;
            this.MoneyNumber = 15;
            this.MoneyGroup = 14;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x20;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 21;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets if this flag is set, the money is added to the map with an animation and sound. Otherwise it's just added like it was already on the ground before.
    /// </summary>
    public bool IsFreshDrop
    {
        get => this._data.Span[5..].GetBoolean(7);
        set => this._data.Span[5..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the money number.
    /// </summary>
    public byte MoneyNumber
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }

    /// <summary>
    /// Gets or sets the money group.
    /// </summary>
    public byte MoneyGroup
    {
        get => this._data.Span[14..].GetByteValue(8, 4);
        set => this._data.Span[14..].SetByteValue(value, 8, 4);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MoneyDropped"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MoneyDropped(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MoneyDropped"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MoneyDropped packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Money dropped on the ground.
/// Causes reaction on client side: The client adds the money to the ground.
/// </summary>
public readonly struct MoneyDroppedExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MoneyDroppedExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MoneyDroppedExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MoneyDroppedExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MoneyDroppedExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x2F;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets if this flag is set, the money is added to the map with an animation and sound. Otherwise, it's just added like it was already on the ground before.
    /// </summary>
    public bool IsFreshDrop
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the amount.
    /// </summary>
    public uint Amount
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MoneyDroppedExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MoneyDroppedExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MoneyDroppedExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MoneyDroppedExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Money dropped on the ground.
/// Causes reaction on client side: The client adds the money to the ground.
/// </summary>
public readonly partial struct MoneyDropped075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MoneyDropped075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MoneyDropped075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MoneyDropped075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MoneyDropped075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)Math.Min(data.Length, Length);
            this.ItemCount = 1;
            this.MoneyNumber = 15;
            this.MoneyGroup = 14;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x20;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets if this flag is set, the money is added to the map with an animation and sound. Otherwise it's just added like it was already on the ground before.
    /// </summary>
    public bool IsFreshDrop
    {
        get => this._data.Span[5..].GetBoolean(7);
        set => this._data.Span[5..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the money number.
    /// </summary>
    public byte MoneyNumber
    {
        get => this._data.Span[9..].GetByteValue(4, 0);
        set => this._data.Span[9..].SetByteValue(value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the money group.
    /// </summary>
    public byte MoneyGroup
    {
        get => this._data.Span[9..].GetByteValue(4, 4);
        set => this._data.Span[9..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MoneyDropped075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MoneyDropped075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MoneyDropped075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MoneyDropped075 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A dropped item was removed from the ground of the map, e.g. when it timed out or was picked up.
/// Causes reaction on client side: The client removes the item from the ground of the map.
/// </summary>
public readonly struct ItemDropRemoved
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemDropRemoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemDropRemoved(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemDropRemoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemDropRemoved(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x21;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="DroppedItemId"/> of the specified index.
    /// </summary>
        public DroppedItemId this[int index] => new (this._data.Slice(5 + index * DroppedItemId.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemDropRemoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemDropRemoved(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemDropRemoved"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemDropRemoved packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="DroppedItemId"/>.
    /// </summary>
    /// <param name="itemDataCount">The count of <see cref="DroppedItemId"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int itemDataCount) => itemDataCount * DroppedItemId.Length + 5;


/// <summary>
/// Contains the id of a dropped item..
/// </summary>
public readonly struct DroppedItemId
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DroppedItemId"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DroppedItemId(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 2;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }
}
}


/// <summary>
/// Is sent by the server when: A new item was added to the inventory.
/// Causes reaction on client side: The client adds the item to the inventory user interface.
/// </summary>
public readonly struct ItemAddedToInventory
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemAddedToInventory"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemAddedToInventory(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemAddedToInventory"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemAddedToInventory(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x22;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(4).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemAddedToInventory"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemAddedToInventory(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemAddedToInventory"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemAddedToInventory packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
}


/// <summary>
/// Is sent by the server when: The player requested to drop an item of his inventory. This message is the response about the success of the request.
/// Causes reaction on client side: If successful, the client removes the item from the inventory user interface.
/// </summary>
public readonly struct ItemDropResponse
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemDropResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemDropResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemDropResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemDropResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x23;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemDropResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemDropResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemDropResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemDropResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to pick up an item from to ground to add it to his inventory, but it failed.
/// Causes reaction on client side: Depending on the reason, the game client shows a message.
/// </summary>
public readonly struct ItemPickUpRequestFailed
{
    /// <summary>
    /// Defines the possible fail reasons
    /// </summary>
    public enum ItemPickUpFailReason
    {
        /// <summary>
        /// The picked up item was combined into an existing item of the players inventory. A separate durability update will be sent to the client.
        /// </summary>
            ItemStacked = 253,

        /// <summary>
        /// The maximum inventory money has been reached, so the money wasn't picked up. Should not be used, because it's used in the InventoryMoneyUpdate message.
        /// </summary>
            __MaximumInventoryMoneyReached = 254,

        /// <summary>
        /// The general, non-specific reason. It just failed.
        /// </summary>
            General = 255,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemPickUpRequestFailed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemPickUpRequestFailed(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemPickUpRequestFailed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemPickUpRequestFailed(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x22;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the fail reason.
    /// </summary>
    public ItemPickUpRequestFailed.ItemPickUpFailReason FailReason
    {
        get => (ItemPickUpFailReason)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemPickUpRequestFailed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemPickUpRequestFailed(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemPickUpRequestFailed"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemPickUpRequestFailed packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The players money amount of the inventory has been changed and needs an update.
/// Causes reaction on client side: The money is updated in the inventory user interface.
/// </summary>
public readonly struct InventoryMoneyUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="InventoryMoneyUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public InventoryMoneyUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="InventoryMoneyUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private InventoryMoneyUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x22;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFE;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32BigEndian(this._data.Span[4..]);
        set => WriteUInt32BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="InventoryMoneyUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator InventoryMoneyUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="InventoryMoneyUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(InventoryMoneyUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An item in the inventory or vault of the player has been moved.
/// Causes reaction on client side: The client updates the position of item in the user interface.
/// </summary>
public readonly struct ItemMoved
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemMoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemMoved(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemMoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemMoved(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x24;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the target storage type.
    /// </summary>
    public ItemStorageKind TargetStorageType
    {
        get => (ItemStorageKind)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the target slot.
    /// </summary>
    public byte TargetSlot
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(5).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemMoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemMoved(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemMoved"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemMoved packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
}


/// <summary>
/// Is sent by the server when: An item in the inventory or vault of the player could not be moved as requested by the player.
/// Causes reaction on client side: The client restores the position of item in the user interface.
/// </summary>
public readonly struct ItemMoveRequestFailed
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemMoveRequestFailed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemMoveRequestFailed(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemMoveRequestFailed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemMoveRequestFailed(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x24;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFF;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(5).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemMoveRequestFailed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemMoveRequestFailed(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemMoveRequestFailed"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemMoveRequestFailed packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
}


/// <summary>
/// Is sent by the server when: Periodically, or if the current health or shield changed on the server side, e.g. by hits.
/// Causes reaction on client side: The health and shield bar is updated on the game client user interface.
/// </summary>
public readonly struct CurrentHealthAndShield
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CurrentHealthAndShield"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CurrentHealthAndShield(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CurrentHealthAndShield"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CurrentHealthAndShield(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x26;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFF;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the health.
    /// </summary>
    public ushort Health
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the shield.
    /// </summary>
    public ushort Shield
    {
        get => ReadUInt16BigEndian(this._data.Span[7..]);
        set => WriteUInt16BigEndian(this._data.Span[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CurrentHealthAndShield"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CurrentHealthAndShield(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CurrentHealthAndShield"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CurrentHealthAndShield packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the maximum health changed, e.g. by adding stat points or changed items.
/// Causes reaction on client side: The health and shield bar is updated on the game client user interface.
/// </summary>
public readonly struct MaximumHealthAndShield
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MaximumHealthAndShield"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MaximumHealthAndShield(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MaximumHealthAndShield"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MaximumHealthAndShield(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x26;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFE;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the health.
    /// </summary>
    public ushort Health
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the shield.
    /// </summary>
    public ushort Shield
    {
        get => ReadUInt16BigEndian(this._data.Span[7..]);
        set => WriteUInt16BigEndian(this._data.Span[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MaximumHealthAndShield"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MaximumHealthAndShield(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MaximumHealthAndShield"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MaximumHealthAndShield packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Periodically, or if the current stats, like health, shield, mana or attack speed changed on the server side, e.g. by hits.
/// Causes reaction on client side: The values are updated on the game client user interface.
/// </summary>
public readonly struct CurrentStatsExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CurrentStatsExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CurrentStatsExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CurrentStatsExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CurrentStatsExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x26;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFF;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the health.
    /// </summary>
    public uint Health
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the shield.
    /// </summary>
    public uint Shield
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the mana.
    /// </summary>
    public uint Mana
    {
        get => ReadUInt32LittleEndian(this._data.Span[12..]);
        set => WriteUInt32LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the ability.
    /// </summary>
    public uint Ability
    {
        get => ReadUInt32LittleEndian(this._data.Span[16..]);
        set => WriteUInt32LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the attack speed.
    /// </summary>
    public ushort AttackSpeed
    {
        get => ReadUInt16LittleEndian(this._data.Span[20..]);
        set => WriteUInt16LittleEndian(this._data.Span[20..], value);
    }

    /// <summary>
    /// Gets or sets the magic speed.
    /// </summary>
    public ushort MagicSpeed
    {
        get => ReadUInt16LittleEndian(this._data.Span[22..]);
        set => WriteUInt16LittleEndian(this._data.Span[22..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CurrentStatsExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CurrentStatsExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CurrentStatsExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CurrentStatsExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the maximum stats, like health, shield, mana or attack speed changed on the server side, e.g. by adding stat points or changed items.
/// Causes reaction on client side: The values are updated on the game client user interface.
/// </summary>
public readonly struct MaximumStatsExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MaximumStatsExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MaximumStatsExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MaximumStatsExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MaximumStatsExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x26;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFE;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 20;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the health.
    /// </summary>
    public uint Health
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the shield.
    /// </summary>
    public uint Shield
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the mana.
    /// </summary>
    public uint Mana
    {
        get => ReadUInt32LittleEndian(this._data.Span[12..]);
        set => WriteUInt32LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the ability.
    /// </summary>
    public uint Ability
    {
        get => ReadUInt32LittleEndian(this._data.Span[16..]);
        set => WriteUInt32LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MaximumStatsExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MaximumStatsExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MaximumStatsExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MaximumStatsExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the consumption of an item failed.
/// Causes reaction on client side: The game client gets a feedback about a failed consumption, and allows for do further consumption requests.
/// </summary>
public readonly struct ItemConsumptionFailed
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemConsumptionFailed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemConsumptionFailed(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemConsumptionFailed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemConsumptionFailed(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x26;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFD;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the health.
    /// </summary>
    public ushort Health
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the shield.
    /// </summary>
    public ushort Shield
    {
        get => ReadUInt16BigEndian(this._data.Span[7..]);
        set => WriteUInt16BigEndian(this._data.Span[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemConsumptionFailed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemConsumptionFailed(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemConsumptionFailed"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemConsumptionFailed packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the consumption of an item failed.
/// Causes reaction on client side: The game client gets a feedback about a failed consumption, and allows for do further consumption requests.
/// </summary>
public readonly struct ItemConsumptionFailedExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemConsumptionFailedExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemConsumptionFailedExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemConsumptionFailedExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemConsumptionFailedExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x26;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFD;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the health.
    /// </summary>
    public uint Health
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the shield.
    /// </summary>
    public uint Shield
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemConsumptionFailedExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemConsumptionFailedExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemConsumptionFailedExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemConsumptionFailedExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Setting the base stats of a character, e.g. set stats command or after a reset.
/// Causes reaction on client side: The values are updated on the game client user interface.
/// </summary>
public readonly struct BaseStatsExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="BaseStatsExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public BaseStatsExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BaseStatsExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private BaseStatsExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x32;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the strength.
    /// </summary>
    public uint Strength
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the agility.
    /// </summary>
    public uint Agility
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the vitality.
    /// </summary>
    public uint Vitality
    {
        get => ReadUInt32LittleEndian(this._data.Span[12..]);
        set => WriteUInt32LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the energy.
    /// </summary>
    public uint Energy
    {
        get => ReadUInt32LittleEndian(this._data.Span[16..]);
        set => WriteUInt32LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the command.
    /// </summary>
    public uint Command
    {
        get => ReadUInt32LittleEndian(this._data.Span[20..]);
        set => WriteUInt32LittleEndian(this._data.Span[20..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="BaseStatsExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator BaseStatsExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="BaseStatsExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(BaseStatsExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The currently available mana or ability has changed, e.g. by using a skill.
/// Causes reaction on client side: The mana and ability bar is updated on the game client user interface.
/// </summary>
public readonly struct CurrentManaAndAbility
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CurrentManaAndAbility"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CurrentManaAndAbility(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CurrentManaAndAbility"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CurrentManaAndAbility(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x27;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFF;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the mana.
    /// </summary>
    public ushort Mana
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the ability.
    /// </summary>
    public ushort Ability
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CurrentManaAndAbility"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CurrentManaAndAbility(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CurrentManaAndAbility"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CurrentManaAndAbility packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The maximum available mana or ability has changed, e.g. by adding stat points.
/// Causes reaction on client side: The mana and ability bar is updated on the game client user interface.
/// </summary>
public readonly struct MaximumManaAndAbility
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MaximumManaAndAbility"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MaximumManaAndAbility(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MaximumManaAndAbility"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MaximumManaAndAbility(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x27;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFE;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the mana.
    /// </summary>
    public ushort Mana
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the ability.
    /// </summary>
    public ushort Ability
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MaximumManaAndAbility"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MaximumManaAndAbility(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MaximumManaAndAbility"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MaximumManaAndAbility packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The item has been removed from the inventory of the player.
/// Causes reaction on client side: The client removes the item in the inventory user interface.
/// </summary>
public readonly struct ItemRemoved
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemRemoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemRemoved(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemRemoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemRemoved(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.TrueFlag = 1;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x28;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the affected slot of the item in the inventory.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the true flag.
    /// </summary>
    public byte TrueFlag
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemRemoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemRemoved(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemRemoved"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemRemoved packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The client requested to consume a special item, e.g. a bottle of Ale.
/// Causes reaction on client side: The player is shown in a red color and has increased attack speed.
/// </summary>
public readonly struct ConsumeItemWithEffect
{
    /// <summary>
    /// Defines a consumed item.
    /// </summary>
    public enum ConsumedItemType
    {
        /// <summary>
        /// The player consumes a bottle of ale, usually 80 seconds effect time.
        /// </summary>
            Ale = 0,

        /// <summary>
        /// The player consumes a redemy of love, usually 90 seconds effect time.
        /// </summary>
            RedemyOfLove = 1,

        /// <summary>
        /// The player consumes a potion of soul, usually 60 seconds effect time.
        /// </summary>
            PotionOfSoul = 77,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ConsumeItemWithEffect"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ConsumeItemWithEffect(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ConsumeItemWithEffect"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ConsumeItemWithEffect(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x29;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the item type.
    /// </summary>
    public ConsumeItemWithEffect.ConsumedItemType ItemType
    {
        get => (ConsumedItemType)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the effect time in seconds.
    /// </summary>
    public ushort EffectTimeInSeconds
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ConsumeItemWithEffect"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ConsumeItemWithEffect(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ConsumeItemWithEffect"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ConsumeItemWithEffect packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The durability of an item in the inventory of the player has been changed.
/// Causes reaction on client side: The client updates the item in the inventory user interface.
/// </summary>
public readonly struct ItemDurabilityChanged
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemDurabilityChanged"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemDurabilityChanged(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemDurabilityChanged"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemDurabilityChanged(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x2A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the durability.
    /// </summary>
    public byte Durability
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets true, if the change resulted from an item consumption; otherwise, false
    /// </summary>
    public bool ByConsumption
    {
        get => this._data.Span[5..].GetBoolean();
        set => this._data.Span[5..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemDurabilityChanged"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemDurabilityChanged(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemDurabilityChanged"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemDurabilityChanged packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to consume a fruit.
/// Causes reaction on client side: The client updates the user interface, by changing the added stat points and used fruit points.
/// </summary>
public readonly struct FruitConsumptionResponse
{
    /// <summary>
    /// Defines the result of the fruit consumption request.
    /// </summary>
    public enum FruitConsumptionResult
    {
        /// <summary>
        /// Consumption to add points was successful.
        /// </summary>
            PlusSuccess = 0,

        /// <summary>
        /// Consumption to add points failed.
        /// </summary>
            PlusFailed = 1,

        /// <summary>
        /// Consumption to add points was prevented because some conditions were not correct.
        /// </summary>
            PlusPrevented = 2,

        /// <summary>
        /// Consumption to remove points was successful.
        /// </summary>
            MinusSuccess = 3,

        /// <summary>
        /// Consumption to remove points failed.
        /// </summary>
            MinusFailed = 4,

        /// <summary>
        /// Consumption to remove points was prevented because some conditions were not correct.
        /// </summary>
            MinusPrevented = 5,

        /// <summary>
        /// Consumption to remove points was successful, removed by a fruit acquired through the cash shop.
        /// </summary>
            MinusSuccessCashShopFruit = 6,

        /// <summary>
        /// Consumption was prevented because an item was equipped.
        /// </summary>
            PreventedByEquippedItems = 16,

        /// <summary>
        /// Consumption to add points was prevented because the maximum amount of points have been added.
        /// </summary>
            PlusPreventedByMaximum = 33,

        /// <summary>
        /// Consumption to remove points was prevented because the maximum amount of points have been removed.
        /// </summary>
            MinusPreventedByMaximum = 37,

        /// <summary>
        /// Consumption to remove points was prevented because the base amount of stat points of the character class cannot be undercut.
        /// </summary>
            MinusPreventedByDefault = 38,
    }

    /// <summary>
    /// Defines the type of stat which the fruit modifies.
    /// </summary>
    public enum FruitStatType
    {
        /// <summary>
        /// Fruit which modifies the energy stat.
        /// </summary>
            Energy = 0,

        /// <summary>
        /// Fruit which modifies the vitality stat.
        /// </summary>
            Vitality = 1,

        /// <summary>
        /// Fruit which modifies the agility stat.
        /// </summary>
            Agility = 2,

        /// <summary>
        /// Fruit which modifies the strength stat.
        /// </summary>
            Strength = 3,

        /// <summary>
        /// Fruit which modifies the leadership stat.
        /// </summary>
            Leadership = 4,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FruitConsumptionResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FruitConsumptionResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FruitConsumptionResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FruitConsumptionResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x2C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public FruitConsumptionResponse.FruitConsumptionResult Result
    {
        get => (FruitConsumptionResult)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the stat points.
    /// </summary>
    public ushort StatPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the stat type.
    /// </summary>
    public FruitConsumptionResponse.FruitStatType StatType
    {
        get => (FruitStatType)this._data.Span[6];
        set => this._data.Span[6] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="FruitConsumptionResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FruitConsumptionResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FruitConsumptionResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(FruitConsumptionResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to consume an item which gives a magic effect.
/// Causes reaction on client side: The client updates the user interface, it shows the remaining time at the effect icon.
/// </summary>
public readonly struct EffectItemConsumption
{
    /// <summary>
    /// Defines the origin of the effect.
    /// </summary>
    public enum EffectOrigin
    {
        /// <summary>
        /// Not defined.
        /// </summary>
            Undefined = 0,

        /// <summary>
        /// Options of Halloween and Cherry Blossom Event items.
        /// </summary>
            HalloweenAndCherryBlossomEvent = 1,

        /// <summary>
        /// Options of cash shop items, like Seals.
        /// </summary>
            CashShopItem = 2,
    }

    /// <summary>
    /// Defines the effect option.
    /// </summary>
    public enum EffectAction
    {
        /// <summary>
        /// Effect is added.
        /// </summary>
            Add = 0,

        /// <summary>
        /// Effect is removed.
        /// </summary>
            Remove = 1,

        /// <summary>
        /// Effect is removed, because its getting replaced.
        /// </summary>
            Replace = 2,
    }

    /// <summary>
    /// Defines the kind of effect which was applied.
    /// </summary>
    public enum EffectType
    {
        /// <summary>
        /// Attack speed increase.
        /// </summary>
            AttackSpeed = 1,

        /// <summary>
        /// Damage increase.
        /// </summary>
            Damage = 2,

        /// <summary>
        /// Defense increase.
        /// </summary>
            Defense = 3,

        /// <summary>
        /// Maximum Health increase.
        /// </summary>
            MaximumHealth = 4,

        /// <summary>
        /// Maximum Mana increase.
        /// </summary>
            MaximumMana = 5,

        /// <summary>
        /// Experience rate increase.
        /// </summary>
            ExperienceRate = 6,

        /// <summary>
        /// Drop rate increase.
        /// </summary>
            DropRate = 7,

        /// <summary>
        /// Sustenance effect, means no experience is gained during this effect.
        /// </summary>
            Sustenance = 8,

        /// <summary>
        /// Strength stat increase.
        /// </summary>
            Strength = 9,

        /// <summary>
        /// Agility stat increase.
        /// </summary>
            Agility = 10,

        /// <summary>
        /// Vitality stat increase.
        /// </summary>
            Vitality = 11,

        /// <summary>
        /// Energy stat increase.
        /// </summary>
            Energy = 12,

        /// <summary>
        /// Leadership stat increase.
        /// </summary>
            Leadership = 13,

        /// <summary>
        /// Physical damage increase.
        /// </summary>
            PhysicalDamage = 14,

        /// <summary>
        /// Wizardry damage increase.
        /// </summary>
            WizardryDamage = 15,

        /// <summary>
        /// Mobility increase.
        /// </summary>
            Mobility = 16,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EffectItemConsumption"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EffectItemConsumption(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="EffectItemConsumption"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private EffectItemConsumption(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x2D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 17;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the origin.
    /// </summary>
    public EffectItemConsumption.EffectOrigin Origin
    {
        get => (EffectOrigin)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public EffectItemConsumption.EffectType Type
    {
        get => (EffectType)this._data.Span[6];
        set => this._data.Span[6] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the action.
    /// </summary>
    public EffectItemConsumption.EffectAction Action
    {
        get => (EffectAction)this._data.Span[8];
        set => this._data.Span[8] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the remaining seconds.
    /// </summary>
    public uint RemainingSeconds
    {
        get => ReadUInt32LittleEndian(this._data.Span[12..]);
        set => WriteUInt32LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the magic effect number.
    /// </summary>
    public byte MagicEffectNumber
    {
        get => this._data.Span[16];
        set => this._data.Span[16] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="EffectItemConsumption"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator EffectItemConsumption(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="EffectItemConsumption"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(EffectItemConsumption packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the client talked to an NPC which should cause a dialog to open on the client side.
/// Causes reaction on client side: The client opens the specified dialog.
/// </summary>
public readonly struct NpcWindowResponse
{
    /// <summary>
    /// Defines the kind of npc window which should be shown on the client.
    /// </summary>
    public enum NpcWindow
    {
        /// <summary>
        /// A merchant window.
        /// </summary>
            Merchant = 0,

        /// <summary>
        /// Another merchant window.
        /// </summary>
            Merchant1 = 1,

        /// <summary>
        /// A vault storage.
        /// </summary>
            VaultStorage = 2,

        /// <summary>
        /// A chaos machine window.
        /// </summary>
            ChaosMachine = 3,

        /// <summary>
        /// A devil square window.
        /// </summary>
            DevilSquare = 4,

        /// <summary>
        /// A blood castle window.
        /// </summary>
            BloodCastle = 6,

        /// <summary>
        /// The pet trainer window.
        /// </summary>
            PetTrainer = 7,

        /// <summary>
        /// The lahap window.
        /// </summary>
            Lahap = 9,

        /// <summary>
        /// The castle senior window.
        /// </summary>
            CastleSeniorNPC = 12,

        /// <summary>
        /// The elphis refinery window.
        /// </summary>
            ElphisRefinery = 17,

        /// <summary>
        /// The refine stone making window.
        /// </summary>
            RefineStoneMaking = 18,

        /// <summary>
        /// The jewel of harmony option removal window.
        /// </summary>
            RemoveJohOption = 19,

        /// <summary>
        /// The illusion temple window.
        /// </summary>
            IllusionTemple = 20,

        /// <summary>
        /// The chaos card combination window.
        /// </summary>
            ChaosCardCombination = 21,

        /// <summary>
        /// The cherry blossom branches assembly window.
        /// </summary>
            CherryBlossomBranchesAssembly = 22,

        /// <summary>
        /// The seed master window.
        /// </summary>
            SeedMaster = 23,

        /// <summary>
        /// The seed researcher window.
        /// </summary>
            SeedResearcher = 24,

        /// <summary>
        /// The stat reinitializer window.
        /// </summary>
            StatReInitializer = 25,

        /// <summary>
        /// The delgado lucky coin registration window.
        /// </summary>
            DelgadoLuckyCoinRegistration = 32,

        /// <summary>
        /// The doorkeeper titus duel watch window.
        /// </summary>
            DoorkeeperTitusDuelWatch = 33,

        /// <summary>
        /// The lugard doppelganger entry window.
        /// </summary>
            LugardDoppelgangerEntry = 35,

        /// <summary>
        /// The jerint gaion event entry window.
        /// </summary>
            JerintGaionEvententry = 36,

        /// <summary>
        /// The julia warp market server window.
        /// </summary>
            JuliaWarpMarketServer = 37,

        /// <summary>
        /// The dialog window which allows to exchange or refine Lucky Item. Used by NPC "David".
        /// </summary>
            CombineLuckyItem = 38,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcWindowResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcWindowResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcWindowResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private NpcWindowResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x30;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 11;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the window.
    /// </summary>
    public NpcWindowResponse.NpcWindow Window
    {
        get => (NpcWindow)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="NpcWindowResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator NpcWindowResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="NpcWindowResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(NpcWindowResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player opens a merchant npc or the vault. It's sent after the dialog was opened by another message.
/// Causes reaction on client side: The client shows the items in the opened dialog.
/// </summary>
public readonly struct StoreItemList
{
    /// <summary>
    /// Defines the kind of npc window which should be shown on the client.
    /// </summary>
    public enum ItemWindow
    {
        /// <summary>
        /// A normal window.
        /// </summary>
            Normal = 0,

        /// <summary>
        /// A chaos machine window.
        /// </summary>
            ChaosMachine = 3,

        /// <summary>
        /// A failed resurrection (of Dark Horse or Dark Raven) storage dialog.
        /// </summary>
            ResurrectionFailed = 5,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="StoreItemList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public StoreItemList(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="StoreItemList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private StoreItemList(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x31;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public StoreItemList.ItemWindow Type
    {
        get => (ItemWindow)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets the <see cref="StoredItem"/> of the specified index.
    /// </summary>
        public StoredItem this[int index, int storedItemLength] => new (this._data.Slice(6 + index * storedItemLength));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="StoreItemList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator StoreItemList(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="StoreItemList"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(StoreItemList packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="StoredItem"/> and it's size.
    /// </summary>
    /// <param name="itemsCount">The count of <see cref="StoredItem"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="StoredItem"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 6;
}


/// <summary>
/// Is sent by the server when: The request of buying an item from a NPC failed.
/// Causes reaction on client side: The client is responsive again. Without this message, it may stuck.
/// </summary>
public readonly struct NpcItemBuyFailed
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcItemBuyFailed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcItemBuyFailed(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcItemBuyFailed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private NpcItemBuyFailed(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x32;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0xFF;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="NpcItemBuyFailed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator NpcItemBuyFailed(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="NpcItemBuyFailed"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(NpcItemBuyFailed packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The request of buying an item from a player or npc was successful.
/// Causes reaction on client side: The bought item is added to the inventory.
/// </summary>
public readonly struct ItemBought
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemBought"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemBought(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemBought"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemBought(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x32;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(4).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemBought"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemBought(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemBought"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemBought packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
}


/// <summary>
/// Is sent by the server when: The result of a previous item sell request.
/// Causes reaction on client side: The amount of specified money is set at the players inventory.
/// </summary>
public readonly struct NpcItemSellResult
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcItemSellResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public NpcItemSellResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="NpcItemSellResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private NpcItemSellResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x33;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="NpcItemSellResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator NpcItemSellResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="NpcItemSellResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(NpcItemSellResult packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to set a price for an item of the players shop.
/// Causes reaction on client side: The item gets a price on the user interface.
/// </summary>
public readonly struct PlayerShopSetItemPriceResponse
{
    /// <summary>
    /// Describes the possible results of setting an item price in a player shop.
    /// </summary>
    public enum ItemPriceSetResult
    {
        /// <summary>
        /// Failed, e.g. because the shop feature is deactivated
        /// </summary>
            Failed = 0,

        /// <summary>
        /// The price has been set successfully
        /// </summary>
            Success = 1,

        /// <summary>
        /// Failed because the item slot was out of range
        /// </summary>
            ItemSlotOutOfRange = 2,

        /// <summary>
        /// Failed because the item could not be found
        /// </summary>
            ItemNotFound = 3,

        /// <summary>
        /// Failed because the price was negative
        /// </summary>
            PriceNegative = 4,

        /// <summary>
        /// Failed because the item is blocked
        /// </summary>
            ItemIsBlocked = 5,

        /// <summary>
        /// Failed because the character level is too low (below level 6)
        /// </summary>
            CharacterLevelTooLow = 6,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopSetItemPriceResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopSetItemPriceResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopSetItemPriceResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopSetItemPriceResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public PlayerShopSetItemPriceResponse.ItemPriceSetResult Result
    {
        get => (ItemPriceSetResult)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PlayerShopSetItemPriceResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopSetItemPriceResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopSetItemPriceResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PlayerShopSetItemPriceResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a player in scope requested to close his shop or after all items has been sold.
/// Causes reaction on client side: The player shop not shown as open anymore.
/// </summary>
public readonly struct PlayerShopClosed
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopClosed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopClosed(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopClosed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopClosed(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Success = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x3;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[4..].GetBoolean();
        set => this._data.Span[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PlayerShopClosed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopClosed(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopClosed"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PlayerShopClosed packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: An item of the players shop was sold to another player.
/// Causes reaction on client side: The item is removed from the players inventory and a blue system message appears.
/// </summary>
public readonly struct PlayerShopItemSoldToPlayer
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemSoldToPlayer"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopItemSoldToPlayer(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemSoldToPlayer"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopItemSoldToPlayer(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x08;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 15;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the buyer name.
    /// </summary>
    public string BuyerName
    {
        get => this._data.Span.ExtractString(5, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(5, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PlayerShopItemSoldToPlayer"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopItemSoldToPlayer(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopItemSoldToPlayer"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PlayerShopItemSoldToPlayer packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to close his shop or after all items has been sold.
/// Causes reaction on client side: The player shop dialog is closed for the shop of the specified player.
/// </summary>
public readonly struct ClosePlayerShopDialog
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ClosePlayerShopDialog"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ClosePlayerShopDialog(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ClosePlayerShopDialog"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ClosePlayerShopDialog(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x12;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ClosePlayerShopDialog"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ClosePlayerShopDialog(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ClosePlayerShopDialog"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ClosePlayerShopDialog packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to open a shop of another player.
/// Causes reaction on client side: The player shop dialog is shown with the provided item data.
/// </summary>
public readonly struct PlayerShopItemList
{
    /// <summary>
    /// The kind of action which led to the list message.
    /// </summary>
    public enum ActionKind
    {
        /// <summary>
        /// The list was requested.
        /// </summary>
            ByRequest = 5,

        /// <summary>
        /// The list was changed, e.g. because an item was sold.
        /// </summary>
            UpdateAfterItemChange = 19,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopItemList(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopItemList(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
            header.SubCode = SubCode;
            this.Success = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the action.
    /// </summary>
    public PlayerShopItemList.ActionKind Action
    {
        get => (ActionKind)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[5..].GetBoolean();
        set => this._data.Span[5..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.Span.ExtractString(8, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(8, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the shop name.
    /// </summary>
    public string ShopName
    {
        get => this._data.Span.ExtractString(18, 36, System.Text.Encoding.UTF8);
        set => this._data.Slice(18, 36).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data.Span[54];
        set => this._data.Span[54] = value;
    }

    /// <summary>
    /// Gets the <see cref="PlayerShopItem"/> of the specified index.
    /// </summary>
        public PlayerShopItem this[int index] => new (this._data.Slice(55 + index * PlayerShopItem.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PlayerShopItemList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopItemList(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopItemList"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PlayerShopItemList packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PlayerShopItem"/>.
    /// </summary>
    /// <param name="itemsCount">The count of <see cref="PlayerShopItem"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int itemsCount) => itemsCount * PlayerShopItem.Length + 55;
}


/// <summary>
/// Is sent by the server when: After the player requested to buy an item of a shop of another player.
/// Causes reaction on client side: The result is shown to the player. If successful, the item is added to the inventory.
/// </summary>
public readonly struct PlayerShopBuyResult
{
    /// <summary>
    /// The kind of result.
    /// </summary>
    public enum ResultKind
    {
        /// <summary>
        /// Undefined result.
        /// </summary>
            Undefined = 0,

        /// <summary>
        /// The item has been bought successfully.
        /// </summary>
            Success = 1,

        /// <summary>
        /// The seller is not available.
        /// </summary>
            NotAvailable = 2,

        /// <summary>
        /// The requested player has no open shop.
        /// </summary>
            ShopNotOpened = 3,

        /// <summary>
        /// The requested player is already in a transaction with another player.
        /// </summary>
            InTransaction = 4,

        /// <summary>
        /// The requested item slot is invalid.
        /// </summary>
            InvalidShopSlot = 5,

        /// <summary>
        /// The requested player with the specified id has a different name or price is missing.
        /// </summary>
            NameMismatchOrPriceMissing = 6,

        /// <summary>
        /// The player has not enough money to buy the item from the seller.
        /// </summary>
            LackOfMoney = 7,

        /// <summary>
        /// The selling player cannot sell the item, because the sale would overflow his money amount in the inventory. Another possibility is that the inventory of the buyer cannot take the item.
        /// </summary>
            MoneyOverflowOrNotEnoughSpace = 8,

        /// <summary>
        /// The requested player has item block active.
        /// </summary>
            ItemBlock = 9,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopBuyResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopBuyResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopBuyResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopBuyResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x06;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 21;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public PlayerShopBuyResult.ResultKind Result
    {
        get => (ResultKind)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the seller id.
    /// </summary>
    public ushort SellerId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(7, 13).Span;
    }

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data.Span[20];
        set => this._data.Span[20] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PlayerShopBuyResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopBuyResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopBuyResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PlayerShopBuyResult packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to buy an item of a shop of another player.
/// Causes reaction on client side: The result is shown to the player. If successful, the item is added to the inventory.
/// </summary>
public readonly struct PlayerShopBuyResultExtended
{
    /// <summary>
    /// The kind of result.
    /// </summary>
    public enum ResultKind
    {
        /// <summary>
        /// Undefined result.
        /// </summary>
            Undefined = 0,

        /// <summary>
        /// The item has been bought successfully.
        /// </summary>
            Success = 1,

        /// <summary>
        /// The seller is not available.
        /// </summary>
            NotAvailable = 2,

        /// <summary>
        /// The requested player has no open shop.
        /// </summary>
            ShopNotOpened = 3,

        /// <summary>
        /// The requested player is already in a transaction with another player.
        /// </summary>
            InTransaction = 4,

        /// <summary>
        /// The requested item slot is invalid.
        /// </summary>
            InvalidShopSlot = 5,

        /// <summary>
        /// The requested player with the specified id has a different name or price is missing.
        /// </summary>
            NameMismatchOrPriceMissing = 6,

        /// <summary>
        /// The player has not enough money to buy the item from the seller.
        /// </summary>
            LackOfMoney = 7,

        /// <summary>
        /// The selling player cannot sell the item, because the sale would overflow his money amount in the inventory. Another possibility is that the inventory of the buyer cannot take the item.
        /// </summary>
            MoneyOverflowOrNotEnoughSpace = 8,

        /// <summary>
        /// The requested player has item block active.
        /// </summary>
            ItemBlock = 9,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopBuyResultExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopBuyResultExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopBuyResultExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopBuyResultExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x06;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the seller id.
    /// </summary>
    public ushort SellerId
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public PlayerShopBuyResultExtended.ResultKind Result
    {
        get => (ResultKind)this._data.Span[6];
        set => this._data.Span[6] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(8).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PlayerShopBuyResultExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopBuyResultExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopBuyResultExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PlayerShopBuyResultExtended packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 8;
}


/// <summary>
/// Is sent by the server when: After the player requested to open a shop of another player.
/// Causes reaction on client side: The player shop dialog is shown with the provided item data.
/// </summary>
public readonly struct PlayerShopItemListExtended
{
    /// <summary>
    /// The kind of action which led to the list message.
    /// </summary>
    public enum ActionKind
    {
        /// <summary>
        /// The list was requested.
        /// </summary>
            ByRequest = 5,

        /// <summary>
        /// The list was changed, e.g. because an item was sold.
        /// </summary>
            UpdateAfterItemChange = 19,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemListExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShopItemListExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShopItemListExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShopItemListExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
            header.SubCode = SubCode;
            this.Success = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the action.
    /// </summary>
    public PlayerShopItemListExtended.ActionKind Action
    {
        get => (ActionKind)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[5..].GetBoolean();
        set => this._data.Span[5..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.Span.ExtractString(8, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(8, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the shop name.
    /// </summary>
    public string ShopName
    {
        get => this._data.Span.ExtractString(18, 36, System.Text.Encoding.UTF8);
        set => this._data.Slice(18, 36).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data.Span[54];
        set => this._data.Span[54] = value;
    }

    /// <summary>
    /// Gets the <see cref="PlayerShopItemExtended"/> of the specified index.
    /// </summary>
        public PlayerShopItemExtended this[int index, int playerShopItemExtendedLength] => new (this._data.Slice(55 + index * playerShopItemExtendedLength));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PlayerShopItemListExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShopItemListExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShopItemListExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PlayerShopItemListExtended packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PlayerShopItemExtended"/> and it's size.
    /// </summary>
    /// <param name="itemsCount">The count of <see cref="PlayerShopItemExtended"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="PlayerShopItemExtended"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 55;
}


/// <summary>
/// Is sent by the server when: After the player gets into scope of a player with an opened shop.
/// Causes reaction on client side: The player shop title is shown at the specified players.
/// </summary>
public readonly struct PlayerShops
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShops"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShops(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShops"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayerShops(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x3F;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the shop count.
    /// </summary>
    public byte ShopCount
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets the <see cref="PlayerShop"/> of the specified index.
    /// </summary>
        public PlayerShop this[int index] => new (this._data.Slice(6 + index * PlayerShop.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PlayerShops"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayerShops(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayerShops"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PlayerShops packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PlayerShop"/>.
    /// </summary>
    /// <param name="shopsCount">The count of <see cref="PlayerShop"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int shopsCount) => shopsCount * PlayerShop.Length + 6;


/// <summary>
/// Data of the shop of a player..
/// </summary>
public readonly struct PlayerShop
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerShop"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerShop(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 38;

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the store name.
    /// </summary>
    public string StoreName
    {
        get => this._data.Span.ExtractString(2, 36, System.Text.Encoding.UTF8);
        set => this._data.Slice(2, 36).Span.WriteString(value, System.Text.Encoding.UTF8);
    }
}
}


/// <summary>
/// Is sent by the server when: The player wears a monster transformation ring.
/// Causes reaction on client side: The character appears as monster, defined by the Skin property.
/// </summary>
public readonly struct AddTransformedCharactersToScope075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddTransformedCharactersToScope075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddTransformedCharactersToScope075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddTransformedCharactersToScope075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddTransformedCharactersToScope075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x45;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="CharacterData"/> of the specified index.
    /// </summary>
        public CharacterData this[int index] => new (this._data.Slice(5 + index * CharacterData.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddTransformedCharactersToScope075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddTransformedCharactersToScope075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddTransformedCharactersToScope075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddTransformedCharactersToScope075 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 5;


/// <summary>
/// Contains the data of an transformed character..
/// </summary>
public readonly struct CharacterData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 19;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the skin.
    /// </summary>
    public byte Skin
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the is poisoned.
    /// </summary>
    public bool IsPoisoned
    {
        get => this._data.Span[5..].GetBoolean(0);
        set => this._data.Span[5..].SetBoolean(value, 0);
    }

    /// <summary>
    /// Gets or sets the is iced.
    /// </summary>
    public bool IsIced
    {
        get => this._data.Span[5..].GetBoolean(1);
        set => this._data.Span[5..].SetBoolean(value, 1);
    }

    /// <summary>
    /// Gets or sets the is damage buffed.
    /// </summary>
    public bool IsDamageBuffed
    {
        get => this._data.Span[5..].GetBoolean(2);
        set => this._data.Span[5..].SetBoolean(value, 2);
    }

    /// <summary>
    /// Gets or sets the is defense buffed.
    /// </summary>
    public bool IsDefenseBuffed
    {
        get => this._data.Span[5..].GetBoolean(3);
        set => this._data.Span[5..].SetBoolean(value, 3);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data.Span[16];
        set => this._data.Span[16] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data.Span[17];
        set => this._data.Span[17] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[18..].GetByteValue(4, 4);
        set => this._data.Span[18..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data.Span[18..].GetByteValue(4, 0);
        set => this._data.Span[18..].SetByteValue((byte)value, 4, 0);
    }
}
}


/// <summary>
/// Is sent by the server when: The player wears a monster transformation ring.
/// Causes reaction on client side: The character appears as monster, defined by the Skin property.
/// </summary>
public readonly partial struct AddTransformedCharactersToScope
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddTransformedCharactersToScope"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddTransformedCharactersToScope(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddTransformedCharactersToScope"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddTransformedCharactersToScope(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x45;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddTransformedCharactersToScope"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddTransformedCharactersToScope(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddTransformedCharactersToScope"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddTransformedCharactersToScope packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/> and it's size.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="CharacterData"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int charactersCount, int structLength) => charactersCount * structLength + 5;


/// <summary>
/// Contains the data of an transformed character..
/// </summary>
public readonly struct CharacterData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public ushort Id
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the current position x.
    /// </summary>
    public byte CurrentPositionX
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the current position y.
    /// </summary>
    public byte CurrentPositionY
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the skin.
    /// </summary>
    public ushort Skin
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the target position x.
    /// </summary>
    public byte TargetPositionX
    {
        get => this._data.Span[16];
        set => this._data.Span[16] = value;
    }

    /// <summary>
    /// Gets or sets the target position y.
    /// </summary>
    public byte TargetPositionY
    {
        get => this._data.Span[17];
        set => this._data.Span[17] = value;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[18..].GetByteValue(4, 4);
        set => this._data.Span[18..].SetByteValue(value, 4, 4);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data.Span[18..].GetByteValue(4, 0);
        set => this._data.Span[18..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(19, 18).Span;
    }

    /// <summary>
    /// Gets or sets defines the number of effects which would be sent after this field.
    /// </summary>
    public byte EffectCount
    {
        get => this._data.Span[37];
        set => this._data.Span[37] = value;
    }

    /// <summary>
    /// Gets the <see cref="EffectId"/> of the specified index.
    /// </summary>
        public EffectId this[int index] => new (this._data.Slice(38 + index * EffectId.Length));

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="EffectId"/>.
    /// </summary>
    /// <param name="effectsCount">The count of <see cref="EffectId"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int effectsCount) => effectsCount * EffectId.Length + 38;
}


/// <summary>
/// Contains the id of a magic effect..
/// </summary>
public readonly struct EffectId
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="EffectId"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public EffectId(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 1;

    /// <summary>
    /// Gets or sets the id.
    /// </summary>
    public byte Id
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: The server wants to alter the terrain attributes of a map at runtime.
/// Causes reaction on client side: The client updates the terrain attributes on its side.
/// </summary>
public readonly struct ChangeTerrainAttributes
{
    /// <summary>
    /// Defines the attribute which should be set/unset. It's a Flags enumeration.
    /// </summary>
    public enum TerrainAttributeType
    {
        /// <summary>
        /// The coordinate is a safezone.
        /// </summary>
            Safezone = 1,

        /// <summary>
        /// The coordinate is occupied by a character.
        /// </summary>
            Character = 2,

        /// <summary>
        /// The coordinate is blocked and can't be passed by a character.
        /// </summary>
            Blocked = 4,

        /// <summary>
        /// The coordinate is blocked, because there is no ground and can't be passed by a character.
        /// </summary>
            NoGround = 8,

        /// <summary>
        /// The coordinate is blocked by water and can't be passed by a character.
        /// </summary>
            Water = 16,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChangeTerrainAttributes"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChangeTerrainAttributes(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChangeTerrainAttributes"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChangeTerrainAttributes(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            this.Type = false;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x46;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public bool Type
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the attribute.
    /// </summary>
    public ChangeTerrainAttributes.TerrainAttributeType Attribute
    {
        get => (TerrainAttributeType)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets when this is true, the attribute is removed on the client side. If it's false, then the attribute is added.
    /// </summary>
    public bool RemoveAttribute
    {
        get => this._data.Span[5..].GetBoolean();
        set => this._data.Span[5..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the area count.
    /// </summary>
    public byte AreaCount
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets the <see cref="TerrainArea"/> of the specified index.
    /// </summary>
        public TerrainArea this[int index] => new (this._data.Slice(7 + index * TerrainArea.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ChangeTerrainAttributes"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChangeTerrainAttributes(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChangeTerrainAttributes"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ChangeTerrainAttributes packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="TerrainArea"/>.
    /// </summary>
    /// <param name="areasCount">The count of <see cref="TerrainArea"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int areasCount) => areasCount * TerrainArea.Length + 7;


/// <summary>
/// Defines the area which should be changed..
/// </summary>
public readonly struct TerrainArea
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="TerrainArea"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public TerrainArea(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets or sets the start x.
    /// </summary>
    public byte StartX
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the start y.
    /// </summary>
    public byte StartY
    {
        get => this._data.Span[1];
        set => this._data.Span[1] = value;
    }

    /// <summary>
    /// Gets or sets the end x.
    /// </summary>
    public byte EndX
    {
        get => this._data.Span[2];
        set => this._data.Span[2] = value;
    }

    /// <summary>
    /// Gets or sets the end y.
    /// </summary>
    public byte EndY
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: After a player achieved or lost something.
/// Causes reaction on client side: An effect is shown for the affected player.
/// </summary>
public readonly struct ShowEffect
{
    /// <summary>
    /// Defines the effect which is shown for the player.
    /// </summary>
    public enum EffectType
    {
        /// <summary>
        /// The player gained shield by drinking a potion.
        /// </summary>
            ShieldPotion = 3,

        /// <summary>
        /// A level up effect is shown for the player.
        /// </summary>
            LevelUp = 16,

        /// <summary>
        /// The players shield depleted.
        /// </summary>
            ShieldLost = 17,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowEffect"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ShowEffect(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowEffect"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ShowEffect(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x48;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the effect.
    /// </summary>
    public ShowEffect.EffectType Effect
    {
        get => (EffectType)this._data.Span[5];
        set => this._data.Span[5] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ShowEffect"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ShowEffect(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ShowEffect"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ShowEffect packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the game client requested it, usually after a successful login.
/// Causes reaction on client side: The game client shows the available characters of the account.
/// </summary>
public readonly struct CharacterList
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterList(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterList(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the unlock flags.
    /// </summary>
    public CharacterCreationUnlockFlags UnlockFlags
    {
        get => (CharacterCreationUnlockFlags)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the move cnt.
    /// </summary>
    public byte MoveCnt
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the is vault extended.
    /// </summary>
    public bool IsVaultExtended
    {
        get => this._data.Span[7..].GetBoolean();
        set => this._data.Span[7..].SetBoolean(value);
    }

    /// <summary>
    /// Gets the <see cref="CharacterData"/> of the specified index.
    /// </summary>
        public CharacterData this[int index] => new (this._data.Slice(8 + index * CharacterData.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterList(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterList"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterList packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 8;


/// <summary>
/// Data of one character in the list..
/// </summary>
public readonly struct CharacterData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 34;

    /// <summary>
    /// Gets or sets the slot index.
    /// </summary>
    public byte SlotIndex
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(1, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(1, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public ushort Level
    {
        get => ReadUInt16LittleEndian(this._data.Span[12..]);
        set => WriteUInt16LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data.Span[14..].GetByteValue(4, 0);
        set => this._data.Span[14..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the is item block active.
    /// </summary>
    public bool IsItemBlockActive
    {
        get => this._data.Span[14..].GetBoolean(4);
        set => this._data.Span[14..].SetBoolean(value, 4);
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(15, 18).Span;
    }

    /// <summary>
    /// Gets or sets the guild position.
    /// </summary>
    public GuildMemberRole GuildPosition
    {
        get => (GuildMemberRole)this._data.Span[33];
        set => this._data.Span[33] = (byte)value;
    }
}
}


/// <summary>
/// Is sent by the server when: After the game client requested it, usually after a successful login.
/// Causes reaction on client side: The game client shows the available characters of the account.
/// </summary>
public readonly struct CharacterListExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterListExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterListExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterListExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterListExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the unlock flags.
    /// </summary>
    public CharacterCreationUnlockFlags UnlockFlags
    {
        get => (CharacterCreationUnlockFlags)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the move cnt.
    /// </summary>
    public byte MoveCnt
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the is vault extended.
    /// </summary>
    public bool IsVaultExtended
    {
        get => this._data.Span[7..].GetBoolean();
        set => this._data.Span[7..].SetBoolean(value);
    }

    /// <summary>
    /// Gets the <see cref="CharacterData"/> of the specified index.
    /// </summary>
        public CharacterData this[int index] => new (this._data.Slice(8 + index * CharacterData.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterListExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterListExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterListExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterListExtended packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 8;


/// <summary>
/// Data of one character in the list..
/// </summary>
public readonly struct CharacterData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 44;

    /// <summary>
    /// Gets or sets the slot index.
    /// </summary>
    public byte SlotIndex
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(1, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(1, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public ushort Level
    {
        get => ReadUInt16LittleEndian(this._data.Span[12..]);
        set => WriteUInt16LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data.Span[14..].GetByteValue(4, 0);
        set => this._data.Span[14..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the is item block active.
    /// </summary>
    public bool IsItemBlockActive
    {
        get => this._data.Span[14..].GetBoolean(4);
        set => this._data.Span[14..].SetBoolean(value, 4);
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(15, 27).Span;
    }

    /// <summary>
    /// Gets or sets the guild position.
    /// </summary>
    public GuildMemberRole GuildPosition
    {
        get => (GuildMemberRole)this._data.Span[42];
        set => this._data.Span[42] = (byte)value;
    }
}
}


/// <summary>
/// Is sent by the server when: It's send right after the CharacterList, in the character selection screen, if the account has any unlocked character classes.
/// Causes reaction on client side: The client unlocks the specified character classes, so they can be created.
/// </summary>
public readonly struct CharacterClassCreationUnlock
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterClassCreationUnlock"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterClassCreationUnlock(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterClassCreationUnlock"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterClassCreationUnlock(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xDE;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the unlock flags.
    /// </summary>
    public CharacterCreationUnlockFlags UnlockFlags
    {
        get => (CharacterCreationUnlockFlags)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterClassCreationUnlock"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterClassCreationUnlock(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterClassCreationUnlock"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterClassCreationUnlock packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the game client requested it, usually after a successful login.
/// Causes reaction on client side: The game client shows the available characters of the account.
/// </summary>
public readonly struct CharacterList075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterList075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterList075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterList075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterList075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="CharacterData"/> of the specified index.
    /// </summary>
        public CharacterData this[int index] => new (this._data.Slice(5 + index * CharacterData.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterList075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterList075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterList075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterList075 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 5;


/// <summary>
/// Data of one character in the list..
/// </summary>
public readonly struct CharacterData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets or sets the slot index.
    /// </summary>
    public byte SlotIndex
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(1, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(1, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public ushort Level
    {
        get => ReadUInt16BigEndian(this._data.Span[11..]);
        set => WriteUInt16BigEndian(this._data.Span[11..], value);
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data.Span[13..].GetByteValue(4, 0);
        set => this._data.Span[13..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the is item block active.
    /// </summary>
    public bool IsItemBlockActive
    {
        get => this._data.Span[13..].GetBoolean(4);
        set => this._data.Span[13..].SetBoolean(value, 4);
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(14, 9).Span;
    }
}
}


/// <summary>
/// Is sent by the server when: After the game client requested it, usually after a successful login.
/// Causes reaction on client side: The game client shows the available characters of the account.
/// </summary>
public readonly struct CharacterList095
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterList095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterList095(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterList095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterList095(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the character count.
    /// </summary>
    public byte CharacterCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="CharacterData"/> of the specified index.
    /// </summary>
        public CharacterData this[int index] => new (this._data.Slice(5 + index * CharacterData.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterList095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterList095(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterList095"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterList095 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="CharacterData"/>.
    /// </summary>
    /// <param name="charactersCount">The count of <see cref="CharacterData"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int charactersCount) => charactersCount * CharacterData.Length + 5;


/// <summary>
/// Data of one character in the list..
/// </summary>
public readonly struct CharacterData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterData(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 26;

    /// <summary>
    /// Gets or sets the slot index.
    /// </summary>
    public byte SlotIndex
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(1, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(1, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public ushort Level
    {
        get => ReadUInt16LittleEndian(this._data.Span[12..]);
        set => WriteUInt16LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data.Span[14..].GetByteValue(4, 0);
        set => this._data.Span[14..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the is item block active.
    /// </summary>
    public bool IsItemBlockActive
    {
        get => this._data.Span[14..].GetBoolean(4);
        set => this._data.Span[14..].SetBoolean(value, 4);
    }

    /// <summary>
    /// Gets or sets the appearance.
    /// </summary>
    public Span<byte> Appearance
    {
        get => this._data.Slice(15, 11).Span;
    }
}
}


/// <summary>
/// Is sent by the server when: After the server successfully processed a character creation request.
/// Causes reaction on client side: The new character is shown in the character list
/// </summary>
public readonly struct CharacterCreationSuccessful
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterCreationSuccessful"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterCreationSuccessful(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterCreationSuccessful"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterCreationSuccessful(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Success = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 42;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[4..].GetBoolean();
        set => this._data.Span[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the character name.
    /// </summary>
    public string CharacterName
    {
        get => this._data.Span.ExtractString(5, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(5, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the character slot.
    /// </summary>
    public byte CharacterSlot
    {
        get => this._data.Span[15];
        set => this._data.Span[15] = value;
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public ushort Level
    {
        get => ReadUInt16LittleEndian(this._data.Span[16..]);
        set => WriteUInt16LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the class.
    /// </summary>
    public CharacterClassNumber Class
    {
        get => (CharacterClassNumber)this._data.Span[18..].GetByteValue(8, 3);
        set => this._data.Span[18..].SetByteValue((byte)value, 8, 3);
    }

    /// <summary>
    /// Gets or sets the character status.
    /// </summary>
    public byte CharacterStatus
    {
        get => this._data.Span[19];
        set => this._data.Span[19] = value;
    }

    /// <summary>
    /// Gets or sets the preview data.
    /// </summary>
    public Span<byte> PreviewData
    {
        get => this._data.Slice(20).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterCreationSuccessful"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterCreationSuccessful(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterCreationSuccessful"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterCreationSuccessful packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="PreviewData"/>.
    /// </summary>
    /// <param name="previewDataLength">The length in bytes of <see cref="PreviewData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int previewDataLength) => previewDataLength + 20;
}


/// <summary>
/// Is sent by the server when: After the server processed a character creation request without success.
/// Causes reaction on client side: A message is shown that it failed. 
/// </summary>
public readonly struct CharacterCreationFailed
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterCreationFailed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterCreationFailed(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterCreationFailed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterCreationFailed(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterCreationFailed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterCreationFailed(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterCreationFailed"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterCreationFailed packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The character respawned after death.
/// Causes reaction on client side: The character respawns with the specified attributes at the specified map.
/// </summary>
public readonly struct RespawnAfterDeath075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RespawnAfterDeath075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RespawnAfterDeath075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RespawnAfterDeath075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RespawnAfterDeath075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x04;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 20;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public byte MapNumber
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the direction.
    /// </summary>
    public byte Direction
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public ushort CurrentHealth
    {
        get => ReadUInt16LittleEndian(this._data.Span[8..]);
        set => WriteUInt16LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the current mana.
    /// </summary>
    public ushort CurrentMana
    {
        get => ReadUInt16LittleEndian(this._data.Span[10..]);
        set => WriteUInt16LittleEndian(this._data.Span[10..], value);
    }

    /// <summary>
    /// Gets or sets the experience.
    /// </summary>
    public uint Experience
    {
        get => ReadUInt32LittleEndian(this._data.Span[12..]);
        set => WriteUInt32LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data.Span[16..]);
        set => WriteUInt32LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="RespawnAfterDeath075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RespawnAfterDeath075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RespawnAfterDeath075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(RespawnAfterDeath075 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The character respawned after death.
/// Causes reaction on client side: The character respawns with the specified attributes at the specified map.
/// </summary>
public readonly struct RespawnAfterDeath095
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RespawnAfterDeath095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RespawnAfterDeath095(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RespawnAfterDeath095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RespawnAfterDeath095(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x04;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 22;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public byte MapNumber
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the direction.
    /// </summary>
    public byte Direction
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public ushort CurrentHealth
    {
        get => ReadUInt16LittleEndian(this._data.Span[8..]);
        set => WriteUInt16LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the current mana.
    /// </summary>
    public ushort CurrentMana
    {
        get => ReadUInt16LittleEndian(this._data.Span[10..]);
        set => WriteUInt16LittleEndian(this._data.Span[10..], value);
    }

    /// <summary>
    /// Gets or sets the current ability.
    /// </summary>
    public ushort CurrentAbility
    {
        get => ReadUInt16LittleEndian(this._data.Span[12..]);
        set => WriteUInt16LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the experience.
    /// </summary>
    public uint Experience
    {
        get => ReadUInt32LittleEndian(this._data.Span[14..]);
        set => WriteUInt32LittleEndian(this._data.Span[14..], value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data.Span[18..]);
        set => WriteUInt32LittleEndian(this._data.Span[18..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="RespawnAfterDeath095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RespawnAfterDeath095(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RespawnAfterDeath095"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(RespawnAfterDeath095 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The character got damaged by being poisoned on old client versions.
/// Causes reaction on client side: Removes the damage from the health without showing a damage number.
/// </summary>
public readonly struct PoisonDamage
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PoisonDamage"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PoisonDamage(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PoisonDamage"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PoisonDamage(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the health damage.
    /// </summary>
    public ushort HealthDamage
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the current shield.
    /// </summary>
    public ushort CurrentShield
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PoisonDamage"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PoisonDamage(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PoisonDamage"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PoisonDamage packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a the hero state of an observed character changed.
/// Causes reaction on client side: The color of the name of the character is changed accordingly and a message is shown.
/// </summary>
public readonly struct HeroStateChanged
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="HeroStateChanged"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public HeroStateChanged(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="HeroStateChanged"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private HeroStateChanged(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x08;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the new state.
    /// </summary>
    public CharacterHeroState NewState
    {
        get => (CharacterHeroState)this._data.Span[6];
        set => this._data.Span[6] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="HeroStateChanged"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator HeroStateChanged(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="HeroStateChanged"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(HeroStateChanged packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
/// Causes reaction on client side: The skill is added to the skill list on client side.
/// </summary>
public readonly struct SkillAdded
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAdded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillAdded(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAdded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillAdded(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Flag = 0xFE;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag.
    /// </summary>
    public byte Flag
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[7..]);
        set => WriteUInt16LittleEndian(this._data.Span[7..], value);
    }

    /// <summary>
    /// Gets or sets the skill level.
    /// </summary>
    public byte SkillLevel
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SkillAdded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillAdded(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillAdded"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SkillAdded packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
/// Causes reaction on client side: The skill is added to the skill list on client side.
/// </summary>
public readonly struct SkillRemoved
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillRemoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillRemoved(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillRemoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillRemoved(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Flag = 0xFF;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag.
    /// </summary>
    public byte Flag
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[7..]);
        set => WriteUInt16LittleEndian(this._data.Span[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SkillRemoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillRemoved(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillRemoved"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SkillRemoved packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Usually, when the player entered the game with a character. When skills get added or removed, this message is sent as well, but with a misleading count.
/// Causes reaction on client side: The skill list gets initialized.
/// </summary>
public readonly struct SkillListUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillListUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillListUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillListUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillListUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets mixed usage: Skill list count (when list). 0xFE when adding a skill, 0xFF when removing a Skill.
    /// </summary>
    public byte Count
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="SkillEntry"/> of the specified index.
    /// </summary>
        public SkillEntry this[int index] => new (this._data.Slice(6 + index * SkillEntry.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SkillListUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillListUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillListUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SkillListUpdate packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="SkillEntry"/>.
    /// </summary>
    /// <param name="skillsCount">The count of <see cref="SkillEntry"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int skillsCount) => skillsCount * SkillEntry.Length + 6;


/// <summary>
/// Structure for a skill entry of the skill list..
/// </summary>
public readonly struct SkillEntry
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillEntry"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillEntry(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[1..]);
        set => WriteUInt16LittleEndian(this._data.Span[1..], value);
    }

    /// <summary>
    /// Gets or sets the skill level.
    /// </summary>
    public byte SkillLevel
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
/// Causes reaction on client side: The skill is added to the skill list on client side.
/// </summary>
public readonly struct SkillAdded075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAdded075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillAdded075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAdded075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillAdded075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Flag = 1;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag.
    /// </summary>
    public byte Flag
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the skill number and level.
    /// </summary>
    public ushort SkillNumberAndLevel
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SkillAdded075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillAdded075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillAdded075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SkillAdded075 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
/// Causes reaction on client side: The skill is added to the skill list on client side.
/// </summary>
public readonly struct SkillRemoved075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillRemoved075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillRemoved075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillRemoved075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillRemoved075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Flag = 0;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag.
    /// </summary>
    public byte Flag
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the skill number and level.
    /// </summary>
    public ushort SkillNumberAndLevel
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SkillRemoved075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillRemoved075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillRemoved075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SkillRemoved075 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
/// Causes reaction on client side: The skill is added to the skill list on client side.
/// </summary>
public readonly struct SkillAdded095
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAdded095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillAdded095(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillAdded095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillAdded095(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Flag = 0xFE;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag.
    /// </summary>
    public byte Flag
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the skill number and level.
    /// </summary>
    public ushort SkillNumberAndLevel
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SkillAdded095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillAdded095(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillAdded095"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SkillAdded095 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
/// Causes reaction on client side: The skill is added to the skill list on client side.
/// </summary>
public readonly struct SkillRemoved095
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillRemoved095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillRemoved095(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillRemoved095"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillRemoved095(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Flag = 0xFF;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag.
    /// </summary>
    public byte Flag
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the skill number and level.
    /// </summary>
    public ushort SkillNumberAndLevel
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SkillRemoved095"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillRemoved095(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillRemoved095"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SkillRemoved095 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Usually, when the player entered the game with a character. When skills get added or removed, this message is sent as well, but with a misleading count.
/// Causes reaction on client side: The skill list gets initialized.
/// </summary>
public readonly struct SkillListUpdate075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillListUpdate075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillListUpdate075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillListUpdate075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillListUpdate075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x11;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets mixed usage: Skill list count (when list). 0xFE when adding a skill, 0xFF when removing a Skill.
    /// </summary>
    public byte Count
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="SkillEntry"/> of the specified index.
    /// </summary>
        public SkillEntry this[int index] => new (this._data.Slice(5 + index * SkillEntry.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SkillListUpdate075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillListUpdate075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillListUpdate075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SkillListUpdate075 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="SkillEntry"/>.
    /// </summary>
    /// <param name="skillsCount">The count of <see cref="SkillEntry"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int skillsCount) => skillsCount * SkillEntry.Length + 5;


/// <summary>
/// Structure for a skill entry of the skill list..
/// </summary>
public readonly struct SkillEntry
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillEntry"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillEntry(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets or sets the skill index.
    /// </summary>
    public byte SkillIndex
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the skill number and level.
    /// </summary>
    public ushort SkillNumberAndLevel
    {
        get => ReadUInt16BigEndian(this._data.Span[1..]);
        set => WriteUInt16BigEndian(this._data.Span[1..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: After the client focused the character successfully on the server side.
/// Causes reaction on client side: The client highlights the focused character.
/// </summary>
public readonly struct CharacterFocused
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterFocused"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterFocused(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterFocused"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterFocused(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x15;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 15;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the character name.
    /// </summary>
    public string CharacterName
    {
        get => this._data.Span.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterFocused"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterFocused(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterFocused"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterFocused packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the server processed a character stat increase request packet.
/// Causes reaction on client side: If it was successful, adds a point to the requested stat type.
/// </summary>
public readonly struct CharacterStatIncreaseResponse
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterStatIncreaseResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterStatIncreaseResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x06;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[4..].GetBoolean(4);
        set => this._data.Span[4..].SetBoolean(value, 4);
    }

    /// <summary>
    /// Gets or sets the attribute.
    /// </summary>
    public CharacterStatAttribute Attribute
    {
        get => (CharacterStatAttribute)this._data.Span[4..].GetByteValue(4, 0);
        set => this._data.Span[4..].SetByteValue((byte)value, 4, 0);
    }

    /// <summary>
    /// Gets or sets the updated dependent maximum stat.
    /// </summary>
    public ushort UpdatedDependentMaximumStat
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the updated maximum shield.
    /// </summary>
    public ushort UpdatedMaximumShield
    {
        get => ReadUInt16LittleEndian(this._data.Span[8..]);
        set => WriteUInt16LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the updated maximum ability.
    /// </summary>
    public ushort UpdatedMaximumAbility
    {
        get => ReadUInt16LittleEndian(this._data.Span[10..]);
        set => WriteUInt16LittleEndian(this._data.Span[10..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterStatIncreaseResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterStatIncreaseResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterStatIncreaseResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterStatIncreaseResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the server processed a character stat increase request packet.
/// Causes reaction on client side: If it was successful, adds a point to the requested stat type.
/// </summary>
public readonly struct CharacterStatIncreaseResponseExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponseExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterStatIncreaseResponseExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterStatIncreaseResponseExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterStatIncreaseResponseExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x06;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the attribute.
    /// </summary>
    public CharacterStatAttribute Attribute
    {
        get => (CharacterStatAttribute)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the added amount.
    /// </summary>
    public ushort AddedAmount
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the updated maximum health.
    /// </summary>
    public uint UpdatedMaximumHealth
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the updated maximum mana.
    /// </summary>
    public uint UpdatedMaximumMana
    {
        get => ReadUInt32LittleEndian(this._data.Span[12..]);
        set => WriteUInt32LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the updated maximum shield.
    /// </summary>
    public uint UpdatedMaximumShield
    {
        get => ReadUInt32LittleEndian(this._data.Span[16..]);
        set => WriteUInt32LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the updated maximum ability.
    /// </summary>
    public uint UpdatedMaximumAbility
    {
        get => ReadUInt32LittleEndian(this._data.Span[20..]);
        set => WriteUInt32LittleEndian(this._data.Span[20..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterStatIncreaseResponseExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterStatIncreaseResponseExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterStatIncreaseResponseExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterStatIncreaseResponseExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the server processed a character delete response of the client.
/// Causes reaction on client side: If successful, the character is deleted from the character selection screen. Otherwise, a message is shown.
/// </summary>
public readonly struct CharacterDeleteResponse
{
    /// <summary>
    /// Result of a character delete request.
    /// </summary>
    public enum CharacterDeleteResult
    {
        /// <summary>
        /// Deleting was not successful
        /// </summary>
            Unsuccessful = 0,

        /// <summary>
        /// Deleting was successful
        /// </summary>
            Successful = 1,

        /// <summary>
        /// Deleting was not successful because a wrong security code was entered
        /// </summary>
            WrongSecurityCode = 2,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterDeleteResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterDeleteResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterDeleteResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterDeleteResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public CharacterDeleteResponse.CharacterDeleteResult Result
    {
        get => (CharacterDeleteResult)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterDeleteResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterDeleteResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterDeleteResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterDeleteResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a character leveled up.
/// Causes reaction on client side: Updates the level (and other related stats) in the game client and shows an effect.
/// </summary>
public readonly struct CharacterLevelUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterLevelUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterLevelUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterLevelUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterLevelUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public ushort Level
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the level up points.
    /// </summary>
    public ushort LevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public ushort MaximumHealth
    {
        get => ReadUInt16LittleEndian(this._data.Span[8..]);
        set => WriteUInt16LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public ushort MaximumMana
    {
        get => ReadUInt16LittleEndian(this._data.Span[10..]);
        set => WriteUInt16LittleEndian(this._data.Span[10..], value);
    }

    /// <summary>
    /// Gets or sets the maximum shield.
    /// </summary>
    public ushort MaximumShield
    {
        get => ReadUInt16LittleEndian(this._data.Span[12..]);
        set => WriteUInt16LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public ushort MaximumAbility
    {
        get => ReadUInt16LittleEndian(this._data.Span[14..]);
        set => WriteUInt16LittleEndian(this._data.Span[14..], value);
    }

    /// <summary>
    /// Gets or sets the fruit points.
    /// </summary>
    public ushort FruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[16..]);
        set => WriteUInt16LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the maximum fruit points.
    /// </summary>
    public ushort MaximumFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[18..]);
        set => WriteUInt16LittleEndian(this._data.Span[18..], value);
    }

    /// <summary>
    /// Gets or sets the negative fruit points.
    /// </summary>
    public ushort NegativeFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[20..]);
        set => WriteUInt16LittleEndian(this._data.Span[20..], value);
    }

    /// <summary>
    /// Gets or sets the maximum negative fruit points.
    /// </summary>
    public ushort MaximumNegativeFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[22..]);
        set => WriteUInt16LittleEndian(this._data.Span[22..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterLevelUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterLevelUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterLevelUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterLevelUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the character was selected by the player and entered the game.
/// Causes reaction on client side: The characters enters the game world.
/// </summary>
public readonly struct CharacterInformation
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterInformation(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterInformation(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 72;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the map id.
    /// </summary>
    public ushort MapId
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the current experience.
    /// </summary>
    public ulong CurrentExperience
    {
        get => ReadUInt64BigEndian(this._data.Span[8..]);
        set => WriteUInt64BigEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the experience for next level.
    /// </summary>
    public ulong ExperienceForNextLevel
    {
        get => ReadUInt64BigEndian(this._data.Span[16..]);
        set => WriteUInt64BigEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the level up points.
    /// </summary>
    public ushort LevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[24..]);
        set => WriteUInt16LittleEndian(this._data.Span[24..], value);
    }

    /// <summary>
    /// Gets or sets the strength.
    /// </summary>
    public ushort Strength
    {
        get => ReadUInt16LittleEndian(this._data.Span[26..]);
        set => WriteUInt16LittleEndian(this._data.Span[26..], value);
    }

    /// <summary>
    /// Gets or sets the agility.
    /// </summary>
    public ushort Agility
    {
        get => ReadUInt16LittleEndian(this._data.Span[28..]);
        set => WriteUInt16LittleEndian(this._data.Span[28..], value);
    }

    /// <summary>
    /// Gets or sets the vitality.
    /// </summary>
    public ushort Vitality
    {
        get => ReadUInt16LittleEndian(this._data.Span[30..]);
        set => WriteUInt16LittleEndian(this._data.Span[30..], value);
    }

    /// <summary>
    /// Gets or sets the energy.
    /// </summary>
    public ushort Energy
    {
        get => ReadUInt16LittleEndian(this._data.Span[32..]);
        set => WriteUInt16LittleEndian(this._data.Span[32..], value);
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public ushort CurrentHealth
    {
        get => ReadUInt16LittleEndian(this._data.Span[34..]);
        set => WriteUInt16LittleEndian(this._data.Span[34..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public ushort MaximumHealth
    {
        get => ReadUInt16LittleEndian(this._data.Span[36..]);
        set => WriteUInt16LittleEndian(this._data.Span[36..], value);
    }

    /// <summary>
    /// Gets or sets the current mana.
    /// </summary>
    public ushort CurrentMana
    {
        get => ReadUInt16LittleEndian(this._data.Span[38..]);
        set => WriteUInt16LittleEndian(this._data.Span[38..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public ushort MaximumMana
    {
        get => ReadUInt16LittleEndian(this._data.Span[40..]);
        set => WriteUInt16LittleEndian(this._data.Span[40..], value);
    }

    /// <summary>
    /// Gets or sets the current shield.
    /// </summary>
    public ushort CurrentShield
    {
        get => ReadUInt16LittleEndian(this._data.Span[42..]);
        set => WriteUInt16LittleEndian(this._data.Span[42..], value);
    }

    /// <summary>
    /// Gets or sets the maximum shield.
    /// </summary>
    public ushort MaximumShield
    {
        get => ReadUInt16LittleEndian(this._data.Span[44..]);
        set => WriteUInt16LittleEndian(this._data.Span[44..], value);
    }

    /// <summary>
    /// Gets or sets the current ability.
    /// </summary>
    public ushort CurrentAbility
    {
        get => ReadUInt16LittleEndian(this._data.Span[46..]);
        set => WriteUInt16LittleEndian(this._data.Span[46..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public ushort MaximumAbility
    {
        get => ReadUInt16LittleEndian(this._data.Span[48..]);
        set => WriteUInt16LittleEndian(this._data.Span[48..], value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data.Span[52..]);
        set => WriteUInt32LittleEndian(this._data.Span[52..], value);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data.Span[56];
        set => this._data.Span[56] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data.Span[57];
        set => this._data.Span[57] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the used fruit points.
    /// </summary>
    public ushort UsedFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[58..]);
        set => WriteUInt16LittleEndian(this._data.Span[58..], value);
    }

    /// <summary>
    /// Gets or sets the max fruit points.
    /// </summary>
    public ushort MaxFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[60..]);
        set => WriteUInt16LittleEndian(this._data.Span[60..], value);
    }

    /// <summary>
    /// Gets or sets the leadership.
    /// </summary>
    public ushort Leadership
    {
        get => ReadUInt16LittleEndian(this._data.Span[62..]);
        set => WriteUInt16LittleEndian(this._data.Span[62..], value);
    }

    /// <summary>
    /// Gets or sets the used negative fruit points.
    /// </summary>
    public ushort UsedNegativeFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[64..]);
        set => WriteUInt16LittleEndian(this._data.Span[64..], value);
    }

    /// <summary>
    /// Gets or sets the max negative fruit points.
    /// </summary>
    public ushort MaxNegativeFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[66..]);
        set => WriteUInt16LittleEndian(this._data.Span[66..], value);
    }

    /// <summary>
    /// Gets or sets the inventory extensions.
    /// </summary>
    public byte InventoryExtensions
    {
        get => this._data.Span[68];
        set => this._data.Span[68] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterInformation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterInformation(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterInformation"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterInformation packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a character leveled up.
/// Causes reaction on client side: Updates the level (and other related stats) in the game client and shows an effect.
/// </summary>
public readonly struct CharacterLevelUpdateExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterLevelUpdateExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterLevelUpdateExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterLevelUpdateExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterLevelUpdateExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 32;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public ushort Level
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the level up points.
    /// </summary>
    public ushort LevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public uint MaximumHealth
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public uint MaximumMana
    {
        get => ReadUInt32LittleEndian(this._data.Span[12..]);
        set => WriteUInt32LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the maximum shield.
    /// </summary>
    public uint MaximumShield
    {
        get => ReadUInt32LittleEndian(this._data.Span[16..]);
        set => WriteUInt32LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public uint MaximumAbility
    {
        get => ReadUInt32LittleEndian(this._data.Span[20..]);
        set => WriteUInt32LittleEndian(this._data.Span[20..], value);
    }

    /// <summary>
    /// Gets or sets the fruit points.
    /// </summary>
    public ushort FruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[24..]);
        set => WriteUInt16LittleEndian(this._data.Span[24..], value);
    }

    /// <summary>
    /// Gets or sets the maximum fruit points.
    /// </summary>
    public ushort MaximumFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[26..]);
        set => WriteUInt16LittleEndian(this._data.Span[26..], value);
    }

    /// <summary>
    /// Gets or sets the negative fruit points.
    /// </summary>
    public ushort NegativeFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[28..]);
        set => WriteUInt16LittleEndian(this._data.Span[28..], value);
    }

    /// <summary>
    /// Gets or sets the maximum negative fruit points.
    /// </summary>
    public ushort MaximumNegativeFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[30..]);
        set => WriteUInt16LittleEndian(this._data.Span[30..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterLevelUpdateExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterLevelUpdateExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterLevelUpdateExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterLevelUpdateExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the character was selected by the player and entered the game.
/// Causes reaction on client side: The characters enters the game world.
/// </summary>
public readonly struct CharacterInformationExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformationExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterInformationExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformationExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterInformationExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 96;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the map id.
    /// </summary>
    public ushort MapId
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the current experience.
    /// </summary>
    public ulong CurrentExperience
    {
        get => ReadUInt64BigEndian(this._data.Span[8..]);
        set => WriteUInt64BigEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the experience for next level.
    /// </summary>
    public ulong ExperienceForNextLevel
    {
        get => ReadUInt64BigEndian(this._data.Span[16..]);
        set => WriteUInt64BigEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the level up points.
    /// </summary>
    public ushort LevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[24..]);
        set => WriteUInt16LittleEndian(this._data.Span[24..], value);
    }

    /// <summary>
    /// Gets or sets the strength.
    /// </summary>
    public ushort Strength
    {
        get => ReadUInt16LittleEndian(this._data.Span[26..]);
        set => WriteUInt16LittleEndian(this._data.Span[26..], value);
    }

    /// <summary>
    /// Gets or sets the agility.
    /// </summary>
    public ushort Agility
    {
        get => ReadUInt16LittleEndian(this._data.Span[28..]);
        set => WriteUInt16LittleEndian(this._data.Span[28..], value);
    }

    /// <summary>
    /// Gets or sets the vitality.
    /// </summary>
    public ushort Vitality
    {
        get => ReadUInt16LittleEndian(this._data.Span[30..]);
        set => WriteUInt16LittleEndian(this._data.Span[30..], value);
    }

    /// <summary>
    /// Gets or sets the energy.
    /// </summary>
    public ushort Energy
    {
        get => ReadUInt16LittleEndian(this._data.Span[32..]);
        set => WriteUInt16LittleEndian(this._data.Span[32..], value);
    }

    /// <summary>
    /// Gets or sets the leadership.
    /// </summary>
    public ushort Leadership
    {
        get => ReadUInt16LittleEndian(this._data.Span[34..]);
        set => WriteUInt16LittleEndian(this._data.Span[34..], value);
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public uint CurrentHealth
    {
        get => ReadUInt32LittleEndian(this._data.Span[36..]);
        set => WriteUInt32LittleEndian(this._data.Span[36..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public uint MaximumHealth
    {
        get => ReadUInt32LittleEndian(this._data.Span[40..]);
        set => WriteUInt32LittleEndian(this._data.Span[40..], value);
    }

    /// <summary>
    /// Gets or sets the current mana.
    /// </summary>
    public uint CurrentMana
    {
        get => ReadUInt32LittleEndian(this._data.Span[44..]);
        set => WriteUInt32LittleEndian(this._data.Span[44..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public uint MaximumMana
    {
        get => ReadUInt32LittleEndian(this._data.Span[48..]);
        set => WriteUInt32LittleEndian(this._data.Span[48..], value);
    }

    /// <summary>
    /// Gets or sets the current shield.
    /// </summary>
    public uint CurrentShield
    {
        get => ReadUInt32LittleEndian(this._data.Span[52..]);
        set => WriteUInt32LittleEndian(this._data.Span[52..], value);
    }

    /// <summary>
    /// Gets or sets the maximum shield.
    /// </summary>
    public uint MaximumShield
    {
        get => ReadUInt32LittleEndian(this._data.Span[56..]);
        set => WriteUInt32LittleEndian(this._data.Span[56..], value);
    }

    /// <summary>
    /// Gets or sets the current ability.
    /// </summary>
    public uint CurrentAbility
    {
        get => ReadUInt32LittleEndian(this._data.Span[60..]);
        set => WriteUInt32LittleEndian(this._data.Span[60..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public uint MaximumAbility
    {
        get => ReadUInt32LittleEndian(this._data.Span[64..]);
        set => WriteUInt32LittleEndian(this._data.Span[64..], value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data.Span[68..]);
        set => WriteUInt32LittleEndian(this._data.Span[68..], value);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data.Span[72];
        set => this._data.Span[72] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data.Span[73];
        set => this._data.Span[73] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the used fruit points.
    /// </summary>
    public ushort UsedFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[74..]);
        set => WriteUInt16LittleEndian(this._data.Span[74..], value);
    }

    /// <summary>
    /// Gets or sets the max fruit points.
    /// </summary>
    public ushort MaxFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[76..]);
        set => WriteUInt16LittleEndian(this._data.Span[76..], value);
    }

    /// <summary>
    /// Gets or sets the used negative fruit points.
    /// </summary>
    public ushort UsedNegativeFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[78..]);
        set => WriteUInt16LittleEndian(this._data.Span[78..], value);
    }

    /// <summary>
    /// Gets or sets the max negative fruit points.
    /// </summary>
    public ushort MaxNegativeFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[80..]);
        set => WriteUInt16LittleEndian(this._data.Span[80..], value);
    }

    /// <summary>
    /// Gets or sets the attack speed.
    /// </summary>
    public ushort AttackSpeed
    {
        get => ReadUInt16LittleEndian(this._data.Span[82..]);
        set => WriteUInt16LittleEndian(this._data.Span[82..], value);
    }

    /// <summary>
    /// Gets or sets the magic speed.
    /// </summary>
    public ushort MagicSpeed
    {
        get => ReadUInt16LittleEndian(this._data.Span[84..]);
        set => WriteUInt16LittleEndian(this._data.Span[84..], value);
    }

    /// <summary>
    /// Gets or sets the maximum attack speed.
    /// </summary>
    public ushort MaximumAttackSpeed
    {
        get => ReadUInt16LittleEndian(this._data.Span[86..]);
        set => WriteUInt16LittleEndian(this._data.Span[86..], value);
    }

    /// <summary>
    /// Gets or sets the inventory extensions.
    /// </summary>
    public byte InventoryExtensions
    {
        get => this._data.Span[88];
        set => this._data.Span[88] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterInformationExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterInformationExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterInformationExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterInformationExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the character was selected by the player and entered the game.
/// Causes reaction on client side: The characters enters the game world.
/// </summary>
public readonly struct CharacterInformation075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformation075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterInformation075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformation075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterInformation075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 42;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the map id.
    /// </summary>
    public byte MapId
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the current experience.
    /// </summary>
    public uint CurrentExperience
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the experience for next level.
    /// </summary>
    public uint ExperienceForNextLevel
    {
        get => ReadUInt32LittleEndian(this._data.Span[12..]);
        set => WriteUInt32LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the level up points.
    /// </summary>
    public ushort LevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[16..]);
        set => WriteUInt16LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the strength.
    /// </summary>
    public ushort Strength
    {
        get => ReadUInt16LittleEndian(this._data.Span[18..]);
        set => WriteUInt16LittleEndian(this._data.Span[18..], value);
    }

    /// <summary>
    /// Gets or sets the agility.
    /// </summary>
    public ushort Agility
    {
        get => ReadUInt16LittleEndian(this._data.Span[20..]);
        set => WriteUInt16LittleEndian(this._data.Span[20..], value);
    }

    /// <summary>
    /// Gets or sets the vitality.
    /// </summary>
    public ushort Vitality
    {
        get => ReadUInt16LittleEndian(this._data.Span[22..]);
        set => WriteUInt16LittleEndian(this._data.Span[22..], value);
    }

    /// <summary>
    /// Gets or sets the energy.
    /// </summary>
    public ushort Energy
    {
        get => ReadUInt16LittleEndian(this._data.Span[24..]);
        set => WriteUInt16LittleEndian(this._data.Span[24..], value);
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public ushort CurrentHealth
    {
        get => ReadUInt16LittleEndian(this._data.Span[26..]);
        set => WriteUInt16LittleEndian(this._data.Span[26..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public ushort MaximumHealth
    {
        get => ReadUInt16LittleEndian(this._data.Span[28..]);
        set => WriteUInt16LittleEndian(this._data.Span[28..], value);
    }

    /// <summary>
    /// Gets or sets the current mana.
    /// </summary>
    public ushort CurrentMana
    {
        get => ReadUInt16LittleEndian(this._data.Span[30..]);
        set => WriteUInt16LittleEndian(this._data.Span[30..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public ushort MaximumMana
    {
        get => ReadUInt16LittleEndian(this._data.Span[32..]);
        set => WriteUInt16LittleEndian(this._data.Span[32..], value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data.Span[36..]);
        set => WriteUInt32LittleEndian(this._data.Span[36..], value);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data.Span[40];
        set => this._data.Span[40] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data.Span[41];
        set => this._data.Span[41] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterInformation075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterInformation075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterInformation075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterInformation075 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the character was selected by the player and entered the game.
/// Causes reaction on client side: The characters enters the game world.
/// </summary>
public readonly struct CharacterInformation097
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformation097"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterInformation097(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInformation097"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterInformation097(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 52;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the map id.
    /// </summary>
    public byte MapId
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the direction.
    /// </summary>
    public byte Direction
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the current experience.
    /// </summary>
    public uint CurrentExperience
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the experience for next level.
    /// </summary>
    public uint ExperienceForNextLevel
    {
        get => ReadUInt32LittleEndian(this._data.Span[12..]);
        set => WriteUInt32LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the level up points.
    /// </summary>
    public ushort LevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[16..]);
        set => WriteUInt16LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the strength.
    /// </summary>
    public ushort Strength
    {
        get => ReadUInt16LittleEndian(this._data.Span[18..]);
        set => WriteUInt16LittleEndian(this._data.Span[18..], value);
    }

    /// <summary>
    /// Gets or sets the agility.
    /// </summary>
    public ushort Agility
    {
        get => ReadUInt16LittleEndian(this._data.Span[20..]);
        set => WriteUInt16LittleEndian(this._data.Span[20..], value);
    }

    /// <summary>
    /// Gets or sets the vitality.
    /// </summary>
    public ushort Vitality
    {
        get => ReadUInt16LittleEndian(this._data.Span[22..]);
        set => WriteUInt16LittleEndian(this._data.Span[22..], value);
    }

    /// <summary>
    /// Gets or sets the energy.
    /// </summary>
    public ushort Energy
    {
        get => ReadUInt16LittleEndian(this._data.Span[24..]);
        set => WriteUInt16LittleEndian(this._data.Span[24..], value);
    }

    /// <summary>
    /// Gets or sets the current health.
    /// </summary>
    public ushort CurrentHealth
    {
        get => ReadUInt16LittleEndian(this._data.Span[26..]);
        set => WriteUInt16LittleEndian(this._data.Span[26..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public ushort MaximumHealth
    {
        get => ReadUInt16LittleEndian(this._data.Span[28..]);
        set => WriteUInt16LittleEndian(this._data.Span[28..], value);
    }

    /// <summary>
    /// Gets or sets the current mana.
    /// </summary>
    public ushort CurrentMana
    {
        get => ReadUInt16LittleEndian(this._data.Span[30..]);
        set => WriteUInt16LittleEndian(this._data.Span[30..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public ushort MaximumMana
    {
        get => ReadUInt16LittleEndian(this._data.Span[32..]);
        set => WriteUInt16LittleEndian(this._data.Span[32..], value);
    }

    /// <summary>
    /// Gets or sets the current ability.
    /// </summary>
    public ushort CurrentAbility
    {
        get => ReadUInt16LittleEndian(this._data.Span[34..]);
        set => WriteUInt16LittleEndian(this._data.Span[34..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public ushort MaximumAbility
    {
        get => ReadUInt16LittleEndian(this._data.Span[36..]);
        set => WriteUInt16LittleEndian(this._data.Span[36..], value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data.Span[40..]);
        set => WriteUInt32LittleEndian(this._data.Span[40..], value);
    }

    /// <summary>
    /// Gets or sets the hero state.
    /// </summary>
    public CharacterHeroState HeroState
    {
        get => (CharacterHeroState)this._data.Span[44];
        set => this._data.Span[44] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the status.
    /// </summary>
    public CharacterStatus Status
    {
        get => (CharacterStatus)this._data.Span[45];
        set => this._data.Span[45] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the used fruit points.
    /// </summary>
    public ushort UsedFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[46..]);
        set => WriteUInt16LittleEndian(this._data.Span[46..], value);
    }

    /// <summary>
    /// Gets or sets the max fruit points.
    /// </summary>
    public ushort MaxFruitPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[48..]);
        set => WriteUInt16LittleEndian(this._data.Span[48..], value);
    }

    /// <summary>
    /// Gets or sets the leadership.
    /// </summary>
    public ushort Leadership
    {
        get => ReadUInt16LittleEndian(this._data.Span[50..]);
        set => WriteUInt16LittleEndian(this._data.Span[50..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterInformation097"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterInformation097(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterInformation097"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterInformation097 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player entered the game or finished a trade.
/// Causes reaction on client side: The user interface of the inventory is initialized with all of its items.
/// </summary>
public readonly struct CharacterInventory
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInventory"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CharacterInventory(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CharacterInventory"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CharacterInventory(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC4;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C4HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the item count.
    /// </summary>
    public byte ItemCount
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets the <see cref="StoredItem"/> of the specified index.
    /// </summary>
        public StoredItem this[int index, int storedItemLength] => new (this._data.Slice(6 + index * storedItemLength));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CharacterInventory"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CharacterInventory(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CharacterInventory"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CharacterInventory packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="StoredItem"/> and it's size.
    /// </summary>
    /// <param name="itemsCount">The count of <see cref="StoredItem"/> from which the size will be calculated.</param>
    /// <param name="structLength">The length of <see cref="StoredItem"/> from which the size will be calculated.</param>
          
    public static int GetRequiredSize(int itemsCount, int structLength) => itemsCount * structLength + 6;
}


/// <summary>
/// Is sent by the server when: An item in the inventory got upgraded by the player, e.g. by applying a jewel.
/// Causes reaction on client side: The item is updated on the user interface.
/// </summary>
public readonly struct InventoryItemUpgraded
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="InventoryItemUpgraded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public InventoryItemUpgraded(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="InventoryItemUpgraded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private InventoryItemUpgraded(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the inventory slot.
    /// </summary>
    public byte InventorySlot
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(5).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="InventoryItemUpgraded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator InventoryItemUpgraded(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="InventoryItemUpgraded"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(InventoryItemUpgraded packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 5;
}


/// <summary>
/// Is sent by the server when: When health of a summoned monster (Elf Skill) changed.
/// Causes reaction on client side: The health is updated on the user interface.
/// </summary>
public readonly struct SummonHealthUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SummonHealthUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SummonHealthUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SummonHealthUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SummonHealthUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x20;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the health percent.
    /// </summary>
    public byte HealthPercent
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SummonHealthUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SummonHealthUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SummonHealthUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SummonHealthUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Every second during a guild soccer match.
/// Causes reaction on client side: The time is updated on the user interface.
/// </summary>
public readonly struct GuildSoccerTimeUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildSoccerTimeUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildSoccerTimeUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildSoccerTimeUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildSoccerTimeUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x22;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the seconds.
    /// </summary>
    public ushort Seconds
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildSoccerTimeUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildSoccerTimeUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildSoccerTimeUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildSoccerTimeUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Whenever the score of the soccer game changed, and at the beginning of the match.
/// Causes reaction on client side: The score is updated on the user interface.
/// </summary>
public readonly struct GuildSoccerScoreUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildSoccerScoreUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildSoccerScoreUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildSoccerScoreUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildSoccerScoreUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x23;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 22;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the red team name.
    /// </summary>
    public string RedTeamName
    {
        get => this._data.Span.ExtractString(4, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 8).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the red team goals.
    /// </summary>
    public byte RedTeamGoals
    {
        get => this._data.Span[12];
        set => this._data.Span[12] = value;
    }

    /// <summary>
    /// Gets or sets the blue team name.
    /// </summary>
    public string BlueTeamName
    {
        get => this._data.Span.ExtractString(13, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(13, 8).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the blue team goals.
    /// </summary>
    public byte BlueTeamGoals
    {
        get => this._data.Span[21];
        set => this._data.Span[21] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildSoccerScoreUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildSoccerScoreUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildSoccerScoreUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildSoccerScoreUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: E.g. when event items are dropped to the floor, or a specific dialog should be shown.
/// Causes reaction on client side: The client shows an effect, e.g. a firework.
/// </summary>
public readonly struct ServerCommand
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ServerCommand"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ServerCommand(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ServerCommand"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ServerCommand(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the command type.
    /// </summary>
    public byte CommandType
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the parameter 1.
    /// </summary>
    public byte Parameter1
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the parameter 2.
    /// </summary>
    public byte Parameter2
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ServerCommand"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ServerCommand(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ServerCommand"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ServerCommand packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: E.g. when event items are dropped to the floor.
/// Causes reaction on client side: The client shows an fireworks effect at the specified coordinates.
/// </summary>
public readonly struct ShowFireworks
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowFireworks"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ShowFireworks(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowFireworks"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ShowFireworks(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.EffectType = 0;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the effect type.
    /// </summary>
    public byte EffectType
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ShowFireworks"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ShowFireworks(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ShowFireworks"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ShowFireworks packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: E.g. when event items are dropped to the floor.
/// Causes reaction on client side: The client shows an christmas fireworks effect at the specified coordinates.
/// </summary>
public readonly struct ShowChristmasFireworks
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowChristmasFireworks"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ShowChristmasFireworks(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowChristmasFireworks"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ShowChristmasFireworks(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.EffectType = 59;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the effect type.
    /// </summary>
    public byte EffectType
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ShowChristmasFireworks"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ShowChristmasFireworks(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ShowChristmasFireworks"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ShowChristmasFireworks packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: E.g. when event items are dropped to the floor.
/// Causes reaction on client side: The client plays a fanfare sound at the specified coordinates.
/// </summary>
public readonly struct PlayFanfareSound
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayFanfareSound"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayFanfareSound(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayFanfareSound"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PlayFanfareSound(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.EffectType = 2;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the effect type.
    /// </summary>
    public byte EffectType
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the x.
    /// </summary>
    public byte X
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the y.
    /// </summary>
    public byte Y
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PlayFanfareSound"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PlayFanfareSound(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PlayFanfareSound"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PlayFanfareSound packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: E.g. when event items are dropped to the floor.
/// Causes reaction on client side: The client shows a swirl effect at the specified object.
/// </summary>
public readonly struct ShowSwirl
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowSwirl"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ShowSwirl(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowSwirl"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ShowSwirl(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.EffectType = 58;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x40;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the effect type.
    /// </summary>
    public byte EffectType
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the target object id.
    /// </summary>
    public ushort TargetObjectId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ShowSwirl"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ShowSwirl(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ShowSwirl"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ShowSwirl packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After entering the game with a master class character.
/// Causes reaction on client side: The master related data is available.
/// </summary>
public readonly struct MasterStatsUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterStatsUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MasterStatsUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterStatsUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MasterStatsUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x50;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 32;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the master level.
    /// </summary>
    public ushort MasterLevel
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the master experience.
    /// </summary>
    public ulong MasterExperience
    {
        get => ReadUInt64BigEndian(this._data.Span[6..]);
        set => WriteUInt64BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the master experience of next level.
    /// </summary>
    public ulong MasterExperienceOfNextLevel
    {
        get => ReadUInt64BigEndian(this._data.Span[14..]);
        set => WriteUInt64BigEndian(this._data.Span[14..], value);
    }

    /// <summary>
    /// Gets or sets the master level up points.
    /// </summary>
    public ushort MasterLevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[22..]);
        set => WriteUInt16LittleEndian(this._data.Span[22..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public ushort MaximumHealth
    {
        get => ReadUInt16LittleEndian(this._data.Span[24..]);
        set => WriteUInt16LittleEndian(this._data.Span[24..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public ushort MaximumMana
    {
        get => ReadUInt16LittleEndian(this._data.Span[26..]);
        set => WriteUInt16LittleEndian(this._data.Span[26..], value);
    }

    /// <summary>
    /// Gets or sets the maximum shield.
    /// </summary>
    public ushort MaximumShield
    {
        get => ReadUInt16LittleEndian(this._data.Span[28..]);
        set => WriteUInt16LittleEndian(this._data.Span[28..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public ushort MaximumAbility
    {
        get => ReadUInt16LittleEndian(this._data.Span[30..]);
        set => WriteUInt16LittleEndian(this._data.Span[30..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MasterStatsUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MasterStatsUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MasterStatsUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MasterStatsUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After entering the game with a master class character.
/// Causes reaction on client side: The master related data is available.
/// </summary>
public readonly struct MasterStatsUpdateExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterStatsUpdateExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MasterStatsUpdateExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterStatsUpdateExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MasterStatsUpdateExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x50;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 40;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the master level.
    /// </summary>
    public ushort MasterLevel
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the master experience.
    /// </summary>
    public ulong MasterExperience
    {
        get => ReadUInt64BigEndian(this._data.Span[6..]);
        set => WriteUInt64BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the master experience of next level.
    /// </summary>
    public ulong MasterExperienceOfNextLevel
    {
        get => ReadUInt64BigEndian(this._data.Span[14..]);
        set => WriteUInt64BigEndian(this._data.Span[14..], value);
    }

    /// <summary>
    /// Gets or sets the master level up points.
    /// </summary>
    public ushort MasterLevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[22..]);
        set => WriteUInt16LittleEndian(this._data.Span[22..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public uint MaximumHealth
    {
        get => ReadUInt32LittleEndian(this._data.Span[24..]);
        set => WriteUInt32LittleEndian(this._data.Span[24..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public uint MaximumMana
    {
        get => ReadUInt32LittleEndian(this._data.Span[28..]);
        set => WriteUInt32LittleEndian(this._data.Span[28..], value);
    }

    /// <summary>
    /// Gets or sets the maximum shield.
    /// </summary>
    public uint MaximumShield
    {
        get => ReadUInt32LittleEndian(this._data.Span[32..]);
        set => WriteUInt32LittleEndian(this._data.Span[32..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public uint MaximumAbility
    {
        get => ReadUInt32LittleEndian(this._data.Span[36..]);
        set => WriteUInt32LittleEndian(this._data.Span[36..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MasterStatsUpdateExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MasterStatsUpdateExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MasterStatsUpdateExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MasterStatsUpdateExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a master character leveled up.
/// Causes reaction on client side: Updates the master level (and other related stats) in the game client and shows an effect.
/// </summary>
public readonly struct MasterCharacterLevelUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterCharacterLevelUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MasterCharacterLevelUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterCharacterLevelUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MasterCharacterLevelUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x51;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 20;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the master level.
    /// </summary>
    public ushort MasterLevel
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the gained master points.
    /// </summary>
    public ushort GainedMasterPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the current master points.
    /// </summary>
    public ushort CurrentMasterPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[8..]);
        set => WriteUInt16LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the maximum master points.
    /// </summary>
    public ushort MaximumMasterPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[10..]);
        set => WriteUInt16LittleEndian(this._data.Span[10..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public ushort MaximumHealth
    {
        get => ReadUInt16LittleEndian(this._data.Span[12..]);
        set => WriteUInt16LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public ushort MaximumMana
    {
        get => ReadUInt16LittleEndian(this._data.Span[14..]);
        set => WriteUInt16LittleEndian(this._data.Span[14..], value);
    }

    /// <summary>
    /// Gets or sets the maximum shield.
    /// </summary>
    public ushort MaximumShield
    {
        get => ReadUInt16LittleEndian(this._data.Span[16..]);
        set => WriteUInt16LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public ushort MaximumAbility
    {
        get => ReadUInt16LittleEndian(this._data.Span[18..]);
        set => WriteUInt16LittleEndian(this._data.Span[18..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MasterCharacterLevelUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MasterCharacterLevelUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MasterCharacterLevelUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MasterCharacterLevelUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a master character leveled up.
/// Causes reaction on client side: Updates the master level (and other related stats) in the game client and shows an effect.
/// </summary>
public readonly struct MasterCharacterLevelUpdateExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterCharacterLevelUpdateExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MasterCharacterLevelUpdateExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterCharacterLevelUpdateExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MasterCharacterLevelUpdateExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x51;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 28;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the master level.
    /// </summary>
    public ushort MasterLevel
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the gained master points.
    /// </summary>
    public ushort GainedMasterPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the current master points.
    /// </summary>
    public ushort CurrentMasterPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[8..]);
        set => WriteUInt16LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the maximum master points.
    /// </summary>
    public ushort MaximumMasterPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[10..]);
        set => WriteUInt16LittleEndian(this._data.Span[10..], value);
    }

    /// <summary>
    /// Gets or sets the maximum health.
    /// </summary>
    public uint MaximumHealth
    {
        get => ReadUInt32LittleEndian(this._data.Span[12..]);
        set => WriteUInt32LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the maximum mana.
    /// </summary>
    public uint MaximumMana
    {
        get => ReadUInt32LittleEndian(this._data.Span[16..]);
        set => WriteUInt32LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the maximum shield.
    /// </summary>
    public uint MaximumShield
    {
        get => ReadUInt32LittleEndian(this._data.Span[20..]);
        set => WriteUInt32LittleEndian(this._data.Span[20..], value);
    }

    /// <summary>
    /// Gets or sets the maximum ability.
    /// </summary>
    public uint MaximumAbility
    {
        get => ReadUInt32LittleEndian(this._data.Span[24..]);
        set => WriteUInt32LittleEndian(this._data.Span[24..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MasterCharacterLevelUpdateExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MasterCharacterLevelUpdateExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MasterCharacterLevelUpdateExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MasterCharacterLevelUpdateExtended packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a master skill level has been changed (usually increased).
/// Causes reaction on client side: The level is updated in the master skill tree.
/// </summary>
public readonly struct MasterSkillLevelUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterSkillLevelUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MasterSkillLevelUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterSkillLevelUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MasterSkillLevelUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x52;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 28;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[4..].GetBoolean();
        set => this._data.Span[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the master level up points.
    /// </summary>
    public ushort MasterLevelUpPoints
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the index of the master skill on the clients master skill tree for the given character class.
    /// </summary>
    public byte MasterSkillIndex
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the master skill number.
    /// </summary>
    public ushort MasterSkillNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[12..]);
        set => WriteUInt16LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public byte Level
    {
        get => this._data.Span[16];
        set => this._data.Span[16] = value;
    }

    /// <summary>
    /// Gets or sets the display value.
    /// </summary>
    public float DisplayValue
    {
        get => ReadSingleLittleEndian(this._data.Span[20..]);
        set => WriteSingleLittleEndian(this._data.Span[20..], value);
    }

    /// <summary>
    /// Gets or sets the display value of next level.
    /// </summary>
    public float DisplayValueOfNextLevel
    {
        get => ReadSingleLittleEndian(this._data.Span[24..]);
        set => WriteSingleLittleEndian(this._data.Span[24..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MasterSkillLevelUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MasterSkillLevelUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MasterSkillLevelUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MasterSkillLevelUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: Usually after entering the game with a master character.
/// Causes reaction on client side: The data is available in the master skill tree.
/// </summary>
public readonly struct MasterSkillList
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterSkillList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MasterSkillList(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterSkillList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MasterSkillList(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x53;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the master skill count.
    /// </summary>
    public uint MasterSkillCount
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets the <see cref="MasterSkillEntry"/> of the specified index.
    /// </summary>
        public MasterSkillEntry this[int index] => new (this._data.Slice(12 + index * MasterSkillEntry.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MasterSkillList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MasterSkillList(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MasterSkillList"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MasterSkillList packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="MasterSkillEntry"/>.
    /// </summary>
    /// <param name="skillsCount">The count of <see cref="MasterSkillEntry"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int skillsCount) => skillsCount * MasterSkillEntry.Length + 12;


/// <summary>
/// An entry in the master skill list..
/// </summary>
public readonly struct MasterSkillEntry
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MasterSkillEntry"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MasterSkillEntry(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets or sets the index of the master skill on the clients master skill tree for the given character class.
    /// </summary>
    public byte MasterSkillIndex
    {
        get => this._data.Span[0];
        set => this._data.Span[0] = value;
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public byte Level
    {
        get => this._data.Span[1];
        set => this._data.Span[1] = value;
    }

    /// <summary>
    /// Gets or sets the display value.
    /// </summary>
    public float DisplayValue
    {
        get => ReadSingleLittleEndian(this._data.Span[4..]);
        set => WriteSingleLittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the display value of next level.
    /// </summary>
    public float DisplayValueOfNextLevel
    {
        get => ReadSingleLittleEndian(this._data.Span[8..]);
        set => WriteSingleLittleEndian(this._data.Span[8..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: 
/// Causes reaction on client side: 
/// </summary>
public readonly struct ServerMessage
{
    /// <summary>
    /// Defines a type of a server message.
    /// </summary>
    public enum MessageType
    {
        /// <summary>
        /// The message is shown as centered golden message in the client.
        /// </summary>
            GoldenCenter = 0,

        /// <summary>
        /// The message is shown as a blue system message.
        /// </summary>
            BlueNormal = 1,

        /// <summary>
        /// The message is a guild notice, centered in green.
        /// </summary>
            GuildNotice = 2,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ServerMessage"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ServerMessage(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ServerMessage"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ServerMessage(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x0D;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public ServerMessage.MessageType Type
    {
        get => (MessageType)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the message.
    /// </summary>
    public string Message
    {
        get => this._data.Span.ExtractString(4, this._data.Length - 4, System.Text.Encoding.UTF8);
        set => this._data.Slice(4).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ServerMessage"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ServerMessage(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ServerMessage"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ServerMessage packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 4;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 4;
}


/// <summary>
/// Is sent by the server when: A player requested to join a guild. This message is sent then to the guild master.
/// Causes reaction on client side: The guild master gets a message box with the request popping up.
/// </summary>
public readonly struct GuildJoinRequest
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildJoinRequest"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildJoinRequest(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildJoinRequest"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildJoinRequest(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x50;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the requester id.
    /// </summary>
    public ushort RequesterId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildJoinRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildJoinRequest(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildJoinRequest"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildJoinRequest packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a guild master responded to a request of a player to join his guild. This message is sent back to the requesting player.
/// Causes reaction on client side: The requester gets a corresponding message showing.
/// </summary>
public readonly struct GuildJoinResponse
{
    /// <summary>
    /// The result of the guild join request.
    /// </summary>
    public enum GuildJoinRequestResult
    {
        /// <summary>
        /// Refused by the guild master.
        /// </summary>
            Refused = 0,

        /// <summary>
        /// Accepted by the guild master.
        /// </summary>
            Accepted = 1,

        /// <summary>
        /// The guild is full.
        /// </summary>
            GuildFull = 2,

        /// <summary>
        /// The guild master is disconnected.
        /// </summary>
            Disconnected = 3,

        /// <summary>
        /// The requested player is not the guild master of its guild.
        /// </summary>
            NotTheGuildMaster = 4,

        /// <summary>
        /// The player already has a guild.
        /// </summary>
            AlreadyHaveGuild = 5,

        /// <summary>
        /// he guild master or the requesting player is busy, e.g. by another request or by an ongoing guild war.
        /// </summary>
            GuildMasterOrRequesterIsBusy = 6,

        /// <summary>
        /// The requesting player needs a minimum level of 6.
        /// </summary>
            MinimumLevel6 = 7,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildJoinResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildJoinResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildJoinResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildJoinResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x51;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public GuildJoinResponse.GuildJoinRequestResult Result
    {
        get => (GuildJoinRequestResult)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildJoinResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildJoinResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildJoinResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildJoinResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a game client requested the list of players of his guild, which is usually the case when the player opens the guild dialog at the game client.
/// Causes reaction on client side: The list of player is available at the client.
/// </summary>
public readonly struct GuildList
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildList(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildList(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x52;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the is in guild.
    /// </summary>
    public bool IsInGuild
    {
        get => this._data.Span[4..].GetBoolean();
        set => this._data.Span[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the guild member count.
    /// </summary>
    public byte GuildMemberCount
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the total score.
    /// </summary>
    public uint TotalScore
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the current score.
    /// </summary>
    public byte CurrentScore
    {
        get => this._data.Span[12];
        set => this._data.Span[12] = value;
    }

    /// <summary>
    /// Gets or sets the rival guild name.
    /// </summary>
    public string RivalGuildName
    {
        get => this._data.Span.ExtractString(13, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(13, 8).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets the <see cref="GuildMember"/> of the specified index.
    /// </summary>
        public GuildMember this[int index] => new (this._data.Slice(24 + index * GuildMember.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildList(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildList"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildList packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="GuildMember"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="GuildMember"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * GuildMember.Length + 24;


/// <summary>
/// Contains the data of one guild member..
/// </summary>
public readonly struct GuildMember
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMember"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildMember(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the server id.
    /// </summary>
    public byte ServerId
    {
        get => this._data.Span[10];
        set => this._data.Span[10] = value;
    }

    /// <summary>
    /// Gets or sets the server id 2.
    /// </summary>
    public byte ServerId2
    {
        get => this._data.Span[11];
        set => this._data.Span[11] = value;
    }

    /// <summary>
    /// Gets or sets the role.
    /// </summary>
    public GuildMemberRole Role
    {
        get => (GuildMemberRole)this._data.Span[12];
        set => this._data.Span[12] = (byte)value;
    }
}
}


/// <summary>
/// Is sent by the server when: After a game client requested the list of players of his guild, which is usually the case when the player opens the guild dialog at the game client.
/// Causes reaction on client side: The list of player is available at the client.
/// </summary>
public readonly struct GuildList075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildList075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildList075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildList075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildList075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x52;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the is in guild.
    /// </summary>
    public bool IsInGuild
    {
        get => this._data.Span[4..].GetBoolean();
        set => this._data.Span[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the guild member count.
    /// </summary>
    public byte GuildMemberCount
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the total score.
    /// </summary>
    public uint TotalScore
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the current score.
    /// </summary>
    public byte CurrentScore
    {
        get => this._data.Span[12];
        set => this._data.Span[12] = value;
    }

    /// <summary>
    /// Gets the <see cref="GuildMember"/> of the specified index.
    /// </summary>
        public GuildMember this[int index] => new (this._data.Slice(13 + index * GuildMember.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildList075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildList075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildList075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildList075 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="GuildMember"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="GuildMember"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * GuildMember.Length + 13;


/// <summary>
/// Contains the data of one guild member..
/// </summary>
public readonly struct GuildMember
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMember"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildMember(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the server id.
    /// </summary>
    public byte ServerId
    {
        get => this._data.Span[10];
        set => this._data.Span[10] = value;
    }

    /// <summary>
    /// Gets or sets the server id 2.
    /// </summary>
    public byte ServerId2
    {
        get => this._data.Span[11];
        set => this._data.Span[11] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: After a guild master sent a request to kick a player from its guild and the server processed this request.
/// Causes reaction on client side: The client shows a message depending on the result.
/// </summary>
public readonly struct GuildKickResponse
{
    /// <summary>
    /// The result of the guild kick request.
    /// </summary>
    public enum GuildKickSuccess
    {
        /// <summary>
        /// The kick request failed because of an incorrect password.
        /// </summary>
            FailedPasswordIncorrect = 0,

        /// <summary>
        /// The kick request was successful.
        /// </summary>
            KickSucceeded = 1,

        /// <summary>
        /// The kick failed because player is not guild master.
        /// </summary>
            KickFailedBecausePlayerIsNotGuildMaster = 2,

        /// <summary>
        /// The kick request failed.
        /// </summary>
            Failed = 3,

        /// <summary>
        /// The guild has been disbanded.
        /// </summary>
            GuildDisband = 4,

        /// <summary>
        /// The guild member has been withdrawn.
        /// </summary>
            GuildMemberWithdrawn = 5,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildKickResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildKickResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildKickResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildKickResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x53;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public GuildKickResponse.GuildKickSuccess Result
    {
        get => (GuildKickSuccess)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildKickResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildKickResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildKickResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildKickResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a player started talking to the guild master NPC and the player is allowed to create a guild.
/// Causes reaction on client side: The client shows the guild master dialog.
/// </summary>
public readonly struct ShowGuildMasterDialog
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowGuildMasterDialog"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ShowGuildMasterDialog(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowGuildMasterDialog"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ShowGuildMasterDialog(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x54;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ShowGuildMasterDialog"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ShowGuildMasterDialog(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ShowGuildMasterDialog"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ShowGuildMasterDialog packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a player started talking to the guild master NPC and the player proceeds to create a guild.
/// Causes reaction on client side: The client shows the guild creation dialog.
/// </summary>
public readonly struct ShowGuildCreationDialog
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowGuildCreationDialog"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ShowGuildCreationDialog(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ShowGuildCreationDialog"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ShowGuildCreationDialog(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x55;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ShowGuildCreationDialog"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ShowGuildCreationDialog(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ShowGuildCreationDialog"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ShowGuildCreationDialog packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a player requested to create a guild at the guild master NPC.
/// Causes reaction on client side: Depending on the result, a message is shown.
/// </summary>
public readonly struct GuildCreationResult
{
    /// <summary>
    /// Defines a guild creation error.
    /// </summary>
    public enum GuildCreationErrorType
    {
        /// <summary>
        /// No error occured.
        /// </summary>
            None = 0,

        /// <summary>
        /// The requested guild name is already taken.
        /// </summary>
            GuildNameAlreadyTaken = 179,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildCreationResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildCreationResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildCreationResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildCreationResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x56;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the error.
    /// </summary>
    public GuildCreationResult.GuildCreationErrorType Error
    {
        get => (GuildCreationErrorType)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildCreationResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildCreationResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildCreationResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildCreationResult packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player left a guild. This message is sent to the player and all surrounding players.
/// Causes reaction on client side: The player is not longer shown as a guild member.
/// </summary>
public readonly struct GuildMemberLeftGuild
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMemberLeftGuild"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildMemberLeftGuild(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMemberLeftGuild"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildMemberLeftGuild(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x5D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the is guild master.
    /// </summary>
    public bool IsGuildMaster
    {
        get => this._data.Span[3..].GetBoolean(7);
        set => this._data.Span[3..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildMemberLeftGuild"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildMemberLeftGuild(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildMemberLeftGuild"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildMemberLeftGuild packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A guild master requested a guild war against another guild.
/// Causes reaction on client side: The guild master of the other guild gets this request.
/// </summary>
public readonly struct GuildWarRequestResult
{
    /// <summary>
    /// Describes the result of the guild war request.
    /// </summary>
    public enum RequestResult
    {
        /// <summary>
        /// Failed, guild not found.
        /// </summary>
            GuildNotFound = 0,

        /// <summary>
        /// Request has been sent to the guild master. Waiting for his answer.
        /// </summary>
            RequestSentToGuildMaster = 1,

        /// <summary>
        /// Failed, because the guild master is offline.
        /// </summary>
            GuildMasterOffline = 2,

        /// <summary>
        /// Failed, because player is not in a guild.
        /// </summary>
            NotInGuild = 3,

        /// <summary>
        /// The guild war couldn't be started, e.g. because the soccer arena is already in use.
        /// </summary>
            Failed = 4,

        /// <summary>
        /// Failed, because player is not the guild master.
        /// </summary>
            NotTheGuildMaster = 5,

        /// <summary>
        /// Failed, because the requested guild is already in a war.
        /// </summary>
            AlreadyInWar = 6,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarRequestResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildWarRequestResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarRequestResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildWarRequestResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x60;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public GuildWarRequestResult.RequestResult Result
    {
        get => (RequestResult)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildWarRequestResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildWarRequestResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildWarRequestResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildWarRequestResult packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A guild master requested a guild war against another guild.
/// Causes reaction on client side: The guild master of the other guild gets this request.
/// </summary>
public readonly struct GuildWarRequest
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarRequest"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildWarRequest(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarRequest"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildWarRequest(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x61;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.Span.ExtractString(3, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 8).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public GuildWarType Type
    {
        get => (GuildWarType)this._data.Span[11];
        set => this._data.Span[11] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildWarRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildWarRequest(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildWarRequest"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildWarRequest packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A guild master requested a guild war against another guild.
/// Causes reaction on client side: The guild master of the other guild gets this request.
/// </summary>
public readonly struct GuildWarDeclared
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarDeclared"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildWarDeclared(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarDeclared"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildWarDeclared(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x62;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.Span.ExtractString(3, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 8).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public GuildWarType Type
    {
        get => (GuildWarType)this._data.Span[11];
        set => this._data.Span[11] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the team code.
    /// </summary>
    public byte TeamCode
    {
        get => this._data.Span[12];
        set => this._data.Span[12] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildWarDeclared"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildWarDeclared(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildWarDeclared"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildWarDeclared packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The guild war ended.
/// Causes reaction on client side: The guild war is shown as ended on the client side.
/// </summary>
public readonly struct GuildWarEnded
{
    /// <summary>
    /// Describes the result of the guild war.
    /// </summary>
    public enum GuildWarResult
    {
        /// <summary>
        /// The war was lost.
        /// </summary>
            Lost = 0,

        /// <summary>
        /// The war was won.
        /// </summary>
            Won = 1,

        /// <summary>
        /// The war was cancelled by the other guild master.
        /// </summary>
            OtherGuildMasterCancelledWar = 2,

        /// <summary>
        /// The war was cancelled by the own guild master.
        /// </summary>
            CancelledWar = 3,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarEnded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildWarEnded(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarEnded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildWarEnded(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x63;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public GuildWarEnded.GuildWarResult Result
    {
        get => (GuildWarResult)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.Span.ExtractString(4, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 8).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildWarEnded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildWarEnded(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildWarEnded"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildWarEnded packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The guild war score changed.
/// Causes reaction on client side: The guild score is updated on the client side.
/// </summary>
public readonly struct GuildWarScoreUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarScoreUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildWarScoreUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildWarScoreUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildWarScoreUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.Type = 0;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x64;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the score of own guild.
    /// </summary>
    public byte ScoreOfOwnGuild
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the score of enemy guild.
    /// </summary>
    public byte ScoreOfEnemyGuild
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildWarScoreUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildWarScoreUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildWarScoreUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildWarScoreUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The server wants to visibly assign a player to a guild, e.g. when two players met each other and one of them is a guild member.
/// Causes reaction on client side: The players which belong to the guild are shown as guild players. If the game client doesn't met a player of this guild yet, it will send another request to get the guild information.
/// </summary>
public readonly struct AssignCharacterToGuild
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AssignCharacterToGuild"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AssignCharacterToGuild(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AssignCharacterToGuild"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AssignCharacterToGuild(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x65;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the player count.
    /// </summary>
    public byte PlayerCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="GuildMemberRelation"/> of the specified index.
    /// </summary>
        public GuildMemberRelation this[int index] => new (this._data.Slice(5 + index * GuildMemberRelation.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AssignCharacterToGuild"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AssignCharacterToGuild(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AssignCharacterToGuild"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AssignCharacterToGuild packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="GuildMemberRelation"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="GuildMemberRelation"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * GuildMemberRelation.Length + 5;


/// <summary>
/// Relation between a guild and a member..
/// </summary>
public readonly struct GuildMemberRelation
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMemberRelation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildMemberRelation(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public uint GuildId
    {
        get => ReadUInt32LittleEndian(this._data.Span);
        set => WriteUInt32LittleEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the role.
    /// </summary>
    public GuildMemberRole Role
    {
        get => (GuildMemberRole)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the is player appearing new.
    /// </summary>
    public bool IsPlayerAppearingNew
    {
        get => this._data.Span[7..].GetBoolean(7);
        set => this._data.Span[7..].SetBoolean(value, 7);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[7..]);
        set => WriteUInt16BigEndian(this._data.Span[7..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: The server wants to visibly assign a player to a guild, e.g. when two players met each other and one of them is a guild member.
/// Causes reaction on client side: The players which belong to the guild are shown as guild players. If the game client doesn't met a player of this guild yet, it will send another request to get the guild information.
/// </summary>
public readonly struct AssignCharacterToGuild075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AssignCharacterToGuild075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AssignCharacterToGuild075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AssignCharacterToGuild075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AssignCharacterToGuild075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x5B;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the player count.
    /// </summary>
    public byte PlayerCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="GuildMemberRelation"/> of the specified index.
    /// </summary>
        public GuildMemberRelation this[int index] => new (this._data.Slice(5 + index * GuildMemberRelation.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AssignCharacterToGuild075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AssignCharacterToGuild075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AssignCharacterToGuild075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AssignCharacterToGuild075 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="GuildMemberRelation"/>.
    /// </summary>
    /// <param name="membersCount">The count of <see cref="GuildMemberRelation"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int membersCount) => membersCount * GuildMemberRelation.Length + 5;


/// <summary>
/// Relation between a guild and a member..
/// </summary>
public readonly struct GuildMemberRelation
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildMemberRelation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildMemberRelation(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public ushort GuildId
    {
        get => ReadUInt16BigEndian(this._data.Span[2..]);
        set => WriteUInt16BigEndian(this._data.Span[2..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: A game client requested the (public) info of a guild, e.g. when it met a player of previously unknown guild.
/// Causes reaction on client side: The players which belong to the guild are shown as guild players.
/// </summary>
public readonly struct GuildInformation
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildInformation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildInformation(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildInformation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildInformation(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x66;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 60;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public uint GuildId
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the guild type.
    /// </summary>
    public byte GuildType
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the alliance guild name.
    /// </summary>
    public string AllianceGuildName
    {
        get => this._data.Span.ExtractString(9, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(9, 8).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.Span.ExtractString(17, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(17, 8).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the logo.
    /// </summary>
    public Span<byte> Logo
    {
        get => this._data.Slice(25, 32).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildInformation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildInformation(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildInformation"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildInformation packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A player went into the scope of one or more guild members.
/// Causes reaction on client side: The players which belong to the guild are shown as guild players.
/// </summary>
public readonly struct GuildInformations075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildInformations075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildInformations075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildInformations075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private GuildInformations075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x5A;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild count.
    /// </summary>
    public byte GuildCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="GuildInfo"/> of the specified index.
    /// </summary>
        public GuildInfo this[int index] => new (this._data.Slice(5 + index * GuildInfo.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="GuildInformations075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator GuildInformations075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="GuildInformations075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(GuildInformations075 packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="GuildInfo"/>.
    /// </summary>
    /// <param name="guildsCount">The count of <see cref="GuildInfo"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int guildsCount) => guildsCount * GuildInfo.Length + 5;


/// <summary>
/// Information about one guild..
/// </summary>
public readonly struct GuildInfo
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="GuildInfo"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public GuildInfo(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 42;

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public ushort GuildId
    {
        get => ReadUInt16BigEndian(this._data.Span);
        set => WriteUInt16BigEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.Span.ExtractString(2, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(2, 8).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the logo.
    /// </summary>
    public Span<byte> Logo
    {
        get => this._data.Slice(10, 32).Span;
    }
}
}


/// <summary>
/// Is sent by the server when: After a guild has been created. However, in OpenMU, we just send the GuildInformations075 message, because it works just the same.
/// Causes reaction on client side: The players which belong to the guild are shown as guild players.
/// </summary>
public readonly struct SingleGuildInformation075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SingleGuildInformation075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SingleGuildInformation075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SingleGuildInformation075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SingleGuildInformation075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x5C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 45;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the guild id.
    /// </summary>
    public ushort GuildId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the guild name.
    /// </summary>
    public string GuildName
    {
        get => this._data.Span.ExtractString(5, 8, System.Text.Encoding.UTF8);
        set => this._data.Slice(5, 8).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the logo.
    /// </summary>
    public Span<byte> Logo
    {
        get => this._data.Slice(13, 32).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SingleGuildInformation075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SingleGuildInformation075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SingleGuildInformation075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SingleGuildInformation075 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to move money between the vault and inventory.
/// Causes reaction on client side: The game client updates the money values of vault and inventory.
/// </summary>
public readonly struct VaultMoneyUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultMoneyUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public VaultMoneyUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultMoneyUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private VaultMoneyUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x81;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the vault money.
    /// </summary>
    public uint VaultMoney
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the inventory money.
    /// </summary>
    public uint InventoryMoney
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="VaultMoneyUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator VaultMoneyUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="VaultMoneyUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(VaultMoneyUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to close the vault, this confirmation is sent back to the client.
/// Causes reaction on client side: The game client closes the vault dialog.
/// </summary>
public readonly struct VaultClosed
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultClosed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public VaultClosed(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultClosed"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private VaultClosed(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x82;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="VaultClosed"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator VaultClosed(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="VaultClosed"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(VaultClosed packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to open the vault.
/// Causes reaction on client side: The game client updates the UI to show the current vault protection state.
/// </summary>
public readonly struct VaultProtectionInformation
{
    /// <summary>
    /// Defines the vault protection state.
    /// </summary>
    public enum VaultProtectionState
    {
        /// <summary>
        /// The vault is unprotected.
        /// </summary>
            Unprotected = 0,

        /// <summary>
        /// The vault is protected and locked. To move items or money, the player needs to unlock it.
        /// </summary>
            Locked = 1,

        /// <summary>
        /// The vault is protected and locked. The user-requested unlock failed by a wrong pin.
        /// </summary>
            UnlockFailedByWrongPin = 10,

        /// <summary>
        /// The vault is protected and locked and the player-requested pin setting failed because of the lock.
        /// </summary>
            SetPinFailedBecauseLock = 11,

        /// <summary>
        /// The vault is protected, but was unlocked by the player.
        /// </summary>
            Unlocked = 12,

        /// <summary>
        /// The vault is protected and the player-requested pin removal failed by using the wrong password.
        /// </summary>
            RemovePinFailedByWrongPassword = 13,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultProtectionInformation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public VaultProtectionInformation(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="VaultProtectionInformation"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private VaultProtectionInformation(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x83;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the protection state.
    /// </summary>
    public VaultProtectionInformation.VaultProtectionState ProtectionState
    {
        get => (VaultProtectionState)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="VaultProtectionInformation"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator VaultProtectionInformation(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="VaultProtectionInformation"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(VaultProtectionInformation packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to execute an item crafting, e.g. at the chaos machine.
/// Causes reaction on client side: The game client updates the UI to show the resulting item.
/// </summary>
public readonly struct ItemCraftingResult
{
    /// <summary>
    /// Defines the crafting result.
    /// </summary>
    public enum CraftingResult
    {
        /// <summary>
        /// The crafting failed.
        /// </summary>
            Failed = 0,

        /// <summary>
        /// The crafting succeeded.
        /// </summary>
            Success = 1,

        /// <summary>
        /// The crafting wasn't executed because of missing money.
        /// </summary>
            NotEnoughMoney = 2,

        /// <summary>
        /// The crafting wasn't executed because of too many items.
        /// </summary>
            TooManyItems = 3,

        /// <summary>
        /// The crafting wasn't executed because the character level is too low.
        /// </summary>
            CharacterLevelTooLow = 4,

        /// <summary>
        /// The crafting wasn't executed because of missing items.
        /// </summary>
            LackingMixItems = 6,

        /// <summary>
        /// The crafting wasn't executed because of incorrect items.
        /// </summary>
            IncorrectMixItems = 7,

        /// <summary>
        /// The crafting wasn't executed because of an invalid item level.
        /// </summary>
            InvalidItemLevel = 8,

        /// <summary>
        /// The crafting wasn't executed because the character class is too low.
        /// </summary>
            CharacterClassTooLow = 9,

        /// <summary>
        /// The blood castle ticket crafting wasn't executed because the BloodCastle items are not correct.
        /// </summary>
            IncorrectBloodCastleItems = 10,

        /// <summary>
        /// The crafting wasn't executed because the player has not enough money for the blood castle ticket crafting.
        /// </summary>
            NotEnoughMoneyForBloodCastle = 11,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemCraftingResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ItemCraftingResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ItemCraftingResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ItemCraftingResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x86;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public ItemCraftingResult.CraftingResult Result
    {
        get => (CraftingResult)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the item data.
    /// </summary>
    public Span<byte> ItemData
    {
        get => this._data.Slice(4).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ItemCraftingResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ItemCraftingResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ItemCraftingResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ItemCraftingResult packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified length of <see cref="ItemData"/>.
    /// </summary>
    /// <param name="itemDataLength">The length in bytes of <see cref="ItemData"/> on which the required size depends.</param>
        
    public static int GetRequiredSize(int itemDataLength) => itemDataLength + 4;
}


/// <summary>
/// Is sent by the server when: After the player requested to close the crafting dialog, this confirmation is sent back to the client.
/// Causes reaction on client side: The game client closes the crafting dialog.
/// </summary>
public readonly struct CraftingDialogClosed075
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="CraftingDialogClosed075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public CraftingDialogClosed075(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="CraftingDialogClosed075"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private CraftingDialogClosed075(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x87;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 3;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="CraftingDialogClosed075"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator CraftingDialogClosed075(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="CraftingDialogClosed075"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(CraftingDialogClosed075 packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player entered the game with his character.
/// Causes reaction on client side: The game client updates the quest state for the quest dialog accordingly.
/// </summary>
public readonly partial struct LegacyQuestStateList
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestStateList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LegacyQuestStateList(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestStateList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LegacyQuestStateList(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            this.QuestCount = 6;
            this.ScrollOfEmperorState = LegacyQuestState.Inactive;
            this.ThreeTreasuresOfMuState = LegacyQuestState.Inactive;
            this.GainHeroStatusState = LegacyQuestState.Inactive;
            this.SecretOfDarkStoneState = LegacyQuestState.Inactive;
            this.CertificateOfStrengthState = LegacyQuestState.Inactive;
            this.InfiltrationOfBarrackState = LegacyQuestState.Inactive;
            this.InfiltrationOfRefugeState = LegacyQuestState.Inactive;
            this.UnusedQuestState = LegacyQuestState.Undefined;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA0;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest count.
    /// </summary>
    public byte QuestCount
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the scroll of emperor state.
    /// </summary>
    public LegacyQuestState ScrollOfEmperorState
    {
        get => (LegacyQuestState)this._data.Span[4..].GetByteValue(2, 0);
        set => this._data.Span[4..].SetByteValue((byte)value, 2, 0);
    }

    /// <summary>
    /// Gets or sets the three treasures of mu state.
    /// </summary>
    public LegacyQuestState ThreeTreasuresOfMuState
    {
        get => (LegacyQuestState)this._data.Span[4..].GetByteValue(2, 2);
        set => this._data.Span[4..].SetByteValue((byte)value, 2, 2);
    }

    /// <summary>
    /// Gets or sets the gain hero status state.
    /// </summary>
    public LegacyQuestState GainHeroStatusState
    {
        get => (LegacyQuestState)this._data.Span[4..].GetByteValue(2, 4);
        set => this._data.Span[4..].SetByteValue((byte)value, 2, 4);
    }

    /// <summary>
    /// Gets or sets the secret of dark stone state.
    /// </summary>
    public LegacyQuestState SecretOfDarkStoneState
    {
        get => (LegacyQuestState)this._data.Span[4..].GetByteValue(2, 6);
        set => this._data.Span[4..].SetByteValue((byte)value, 2, 6);
    }

    /// <summary>
    /// Gets or sets the certificate of strength state.
    /// </summary>
    public LegacyQuestState CertificateOfStrengthState
    {
        get => (LegacyQuestState)this._data.Span[5..].GetByteValue(2, 0);
        set => this._data.Span[5..].SetByteValue((byte)value, 2, 0);
    }

    /// <summary>
    /// Gets or sets the infiltration of barrack state.
    /// </summary>
    public LegacyQuestState InfiltrationOfBarrackState
    {
        get => (LegacyQuestState)this._data.Span[5..].GetByteValue(2, 2);
        set => this._data.Span[5..].SetByteValue((byte)value, 2, 2);
    }

    /// <summary>
    /// Gets or sets the infiltration of refuge state.
    /// </summary>
    public LegacyQuestState InfiltrationOfRefugeState
    {
        get => (LegacyQuestState)this._data.Span[5..].GetByteValue(2, 4);
        set => this._data.Span[5..].SetByteValue((byte)value, 2, 4);
    }

    /// <summary>
    /// Gets or sets the unused quest state.
    /// </summary>
    public LegacyQuestState UnusedQuestState
    {
        get => (LegacyQuestState)this._data.Span[5..].GetByteValue(2, 6);
        set => this._data.Span[5..].SetByteValue((byte)value, 2, 6);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="LegacyQuestStateList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LegacyQuestStateList(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LegacyQuestStateList"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(LegacyQuestStateList packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the player clicks on the quest npc.
/// Causes reaction on client side: The game client shows the next steps in the quest dialog.
/// </summary>
public readonly struct LegacyQuestStateDialog
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestStateDialog"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LegacyQuestStateDialog(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestStateDialog"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LegacyQuestStateDialog(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA1;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest index.
    /// </summary>
    public byte QuestIndex
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets this is the complete byte with the state of four quests within the same byte.
    /// </summary>
    public byte State
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="LegacyQuestStateDialog"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LegacyQuestStateDialog(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LegacyQuestStateDialog"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(LegacyQuestStateDialog packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: As response to the set state request (C1A2).
/// Causes reaction on client side: The game client shows the new quest state.
/// </summary>
public readonly struct LegacySetQuestStateResponse
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacySetQuestStateResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LegacySetQuestStateResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacySetQuestStateResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LegacySetQuestStateResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA2;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest index.
    /// </summary>
    public byte QuestIndex
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets this value is 0 if successful. Otherwise, 0xFF or even other magic values.
    /// </summary>
    public byte Result
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets this is the complete byte with the state of four quests within the same byte.
    /// </summary>
    public byte NewState
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="LegacySetQuestStateResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LegacySetQuestStateResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LegacySetQuestStateResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(LegacySetQuestStateResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: As response to the completed quest of a player in scope.
/// Causes reaction on client side: The game client shows the reward accordingly.
/// </summary>
public readonly struct LegacyQuestReward
{
    /// <summary>
    /// Defines the reward type in the quest reward message.
    /// </summary>
    public enum QuestRewardType
    {
        /// <summary>
        /// The character receives additional points.
        /// </summary>
            LevelUpPoints = 200,

        /// <summary>
        /// The character class changes from the first to the second class.
        /// </summary>
            CharacterEvolutionFirstToSecond = 201,

        /// <summary>
        /// The character receives additional points per level.
        /// </summary>
            LevelUpPointsPerLevelIncrease = 202,

        /// <summary>
        /// The character receives the ability to perform skill combinations.
        /// </summary>
            ComboSkill = 203,

        /// <summary>
        /// The character class changes from the second to the third class.
        /// </summary>
            CharacterEvolutionSecondToThird = 204,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestReward"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LegacyQuestReward(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestReward"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LegacyQuestReward(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA3;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16BigEndian(this._data.Span[3..]);
        set => WriteUInt16BigEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the reward.
    /// </summary>
    public LegacyQuestReward.QuestRewardType Reward
    {
        get => (QuestRewardType)this._data.Span[5];
        set => this._data.Span[5] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the count.
    /// </summary>
    public byte Count
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="LegacyQuestReward"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LegacyQuestReward(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LegacyQuestReward"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(LegacyQuestReward packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: As response when a player opens the quest npc with a running quest which requires monster kills.
/// Causes reaction on client side: The game client shows the current state.
/// </summary>
public readonly struct LegacyQuestMonsterKillInfo
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestMonsterKillInfo"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LegacyQuestMonsterKillInfo(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LegacyQuestMonsterKillInfo"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LegacyQuestMonsterKillInfo(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Result = 1;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA4;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 48;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public byte Result
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the quest index.
    /// </summary>
    public byte QuestIndex
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets the <see cref="MonsterKillInfo"/> of the specified index.
    /// </summary>
        public MonsterKillInfo this[int index] => new (this._data.Slice(8 + index * MonsterKillInfo.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="LegacyQuestMonsterKillInfo"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LegacyQuestMonsterKillInfo(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LegacyQuestMonsterKillInfo"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(LegacyQuestMonsterKillInfo packet) => packet._data; 


/// <summary>
/// A pair of Monster number and the current kill count..
/// </summary>
public readonly struct MonsterKillInfo
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MonsterKillInfo"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MonsterKillInfo(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets or sets the monster number.
    /// </summary>
    public uint MonsterNumber
    {
        get => ReadUInt32LittleEndian(this._data.Span);
        set => WriteUInt32LittleEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the kill count.
    /// </summary>
    public uint KillCount
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: After the client sent a PetAttackCommand (as confirmation), or when the previous command finished and the pet is reset to Normal-mode.
/// Causes reaction on client side: The client updates the pet mode in its user interface.
/// </summary>
public readonly struct PetMode
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PetMode"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PetMode(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PetMode"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PetMode(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.Pet = ClientToServer.PetType.DarkRaven;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA7;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the pet.
    /// </summary>
    public ClientToServer.PetType Pet
    {
        get => (ClientToServer.PetType)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the pet command mode.
    /// </summary>
    public ClientToServer.PetCommandMode PetCommandMode
    {
        get => (ClientToServer.PetCommandMode)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PetMode"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PetMode(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PetMode"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PetMode packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the client sent a PetAttackCommand, the pet attacks automatically. For each attack, the player and all observing players get this message.
/// Causes reaction on client side: The client shows the pet attacking the target.
/// </summary>
public readonly struct PetAttack
{
    /// <summary>
    /// Describes the type of the pet attack.
    /// </summary>
    public enum PetSkillType
    {
        /// <summary>
        /// A single target attack, used for critical and excellent hits.
        /// </summary>
            SingleTarget = 0,

        /// <summary>
        /// A range attack for multiple targets, usually up to 3 additional targets which all get their own PetAttack messages with 'SingleTarget' right after the first 'Range' message.
        /// </summary>
            Range = 1,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PetAttack"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PetAttack(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PetAttack"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PetAttack(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.Pet = ClientToServer.PetType.DarkRaven;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA8;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the pet.
    /// </summary>
    public ClientToServer.PetType Pet
    {
        get => (ClientToServer.PetType)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the skill type.
    /// </summary>
    public PetAttack.PetSkillType SkillType
    {
        get => (PetSkillType)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the owner id.
    /// </summary>
    public ushort OwnerId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16BigEndian(this._data.Span[7..]);
        set => WriteUInt16BigEndian(this._data.Span[7..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PetAttack"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PetAttack(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PetAttack"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PetAttack packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the client sent a PetInfoRequest for a pet (dark raven, horse).
/// Causes reaction on client side: The client shows the information about the pet.
/// </summary>
public readonly struct PetInfoResponse
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PetInfoResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PetInfoResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="PetInfoResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private PetInfoResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xA9;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the pet.
    /// </summary>
    public ClientToServer.PetType Pet
    {
        get => (ClientToServer.PetType)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the storage.
    /// </summary>
    public ClientToServer.StorageType Storage
    {
        get => (ClientToServer.StorageType)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the item slot.
    /// </summary>
    public byte ItemSlot
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the level.
    /// </summary>
    public byte Level
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the experience.
    /// </summary>
    public uint Experience
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the health.
    /// </summary>
    public byte Health
    {
        get => this._data.Span[12];
        set => this._data.Span[12] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="PetInfoResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator PetInfoResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="PetInfoResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(PetInfoResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the client sent a DuelStartRequest, and it either failed or the requested player sent a response.
/// Causes reaction on client side: The client shows the started or aborted duel.
/// </summary>
public readonly struct DuelStartResult
{
    /// <summary>
    /// Describes the type of the duel result.
    /// </summary>
    public enum DuelStartResultType
    {
        /// <summary>
        /// The duel has been started.
        /// </summary>
            Success = 0,

        /// <summary>
        /// The duel couldn't be started, because one of the players has not the minimum level, usually 30.
        /// </summary>
            FailedByTooLowLevel = 12,

        /// <summary>
        /// The duel couldn't be started, because of an unexpected error.
        /// </summary>
            FailedByError = 14,

        /// <summary>
        /// The duel couldn't be started, because the opponent refused.
        /// </summary>
            Refused = 15,

        /// <summary>
        /// The duel couldn't be started, because no duel room is free.
        /// </summary>
            FailedByNoFreeRoom = 16,

        /// <summary>
        /// The duel couldn't be started, because ...
        /// </summary>
            FailedBy_ = 28,

        /// <summary>
        /// The duel couldn't be started, because one of the players has not enough money, usually 30000. 
        /// </summary>
            FailedByNotEnoughMoney = 30,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStartResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelStartResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStartResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelStartResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 17;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public DuelStartResult.DuelStartResultType Result
    {
        get => (DuelStartResultType)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the opponent id.
    /// </summary>
    public ushort OpponentId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the opponent name.
    /// </summary>
    public string OpponentName
    {
        get => this._data.Span.ExtractString(7, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(7, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DuelStartResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelStartResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelStartResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DuelStartResult packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After another client sent a DuelStartRequest, to ask the requested player for a response.
/// Causes reaction on client side: The client shows the duel request.
/// </summary>
public readonly struct DuelStartRequest
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStartRequest"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelStartRequest(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStartRequest"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelStartRequest(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the requester id.
    /// </summary>
    public ushort RequesterId
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the requester name.
    /// </summary>
    public string RequesterName
    {
        get => this._data.Span.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DuelStartRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelStartRequest(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelStartRequest"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DuelStartRequest packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a duel ended.
/// Causes reaction on client side: The client updates its state.
/// </summary>
public readonly struct DuelEnd
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelEnd"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelEnd(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelEnd"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelEnd(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.Result = 0;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 17;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public byte Result
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the opponent id.
    /// </summary>
    public ushort OpponentId
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the opponent name.
    /// </summary>
    public string OpponentName
    {
        get => this._data.Span.ExtractString(7, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(7, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DuelEnd"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelEnd(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelEnd"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DuelEnd packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the score of the duel has been changed.
/// Causes reaction on client side: The client updates the displayed duel score.
/// </summary>
public readonly struct DuelScore
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelScore"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelScore(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelScore"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelScore(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x04;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the player 1 id.
    /// </summary>
    public ushort Player1Id
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the player 2 id.
    /// </summary>
    public ushort Player2Id
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the player 1 score.
    /// </summary>
    public byte Player1Score
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the player 2 score.
    /// </summary>
    public byte Player2Score
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DuelScore"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelScore(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelScore"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DuelScore packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the health/shield of the duel players has been changed.
/// Causes reaction on client side: The client updates the displayed health and shield bars.
/// </summary>
public readonly struct DuelHealthUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelHealthUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelHealthUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelHealthUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelHealthUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x05;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the player 1 id.
    /// </summary>
    public ushort Player1Id
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the player 2 id.
    /// </summary>
    public ushort Player2Id
    {
        get => ReadUInt16BigEndian(this._data.Span[6..]);
        set => WriteUInt16BigEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the player 1 health percentage.
    /// </summary>
    public byte Player1HealthPercentage
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the player 2 health percentage.
    /// </summary>
    public byte Player2HealthPercentage
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }

    /// <summary>
    /// Gets or sets the player 1 shield percentage.
    /// </summary>
    public byte Player1ShieldPercentage
    {
        get => this._data.Span[10];
        set => this._data.Span[10] = value;
    }

    /// <summary>
    /// Gets or sets the player 2 shield percentage.
    /// </summary>
    public byte Player2ShieldPercentage
    {
        get => this._data.Span[11];
        set => this._data.Span[11] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DuelHealthUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelHealthUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelHealthUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DuelHealthUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the client requested the list of the current duel rooms.
/// Causes reaction on client side: The client shows the list of duel rooms.
/// </summary>
public readonly struct DuelStatus
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStatus"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelStatus(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelStatus"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelStatus(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x06;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 92;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets the <see cref="DuelRoomStatus"/> of the specified index.
    /// </summary>
        public DuelRoomStatus this[int index] => new (this._data.Slice(4 + index * DuelRoomStatus.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DuelStatus"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelStatus(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelStatus"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DuelStatus packet) => packet._data; 


/// <summary>
/// Structure for a duel room entry..
/// </summary>
public readonly struct DuelRoomStatus
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelRoomStatus"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelRoomStatus(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 22;

    /// <summary>
    /// Gets or sets the player 1 name.
    /// </summary>
    public string Player1Name
    {
        get => this._data.Span.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the player 2 name.
    /// </summary>
    public string Player2Name
    {
        get => this._data.Span.ExtractString(10, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(10, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the duel running.
    /// </summary>
    public bool DuelRunning
    {
        get => this._data.Span[20..].GetBoolean();
        set => this._data.Span[20..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the duel open.
    /// </summary>
    public bool DuelOpen
    {
        get => this._data.Span[21..].GetBoolean();
        set => this._data.Span[21..].SetBoolean(value);
    }
}
}


/// <summary>
/// Is sent by the server when: When the duel starts.
/// Causes reaction on client side: The client initializes the duel state.
/// </summary>
public readonly struct DuelInit
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelInit"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelInit(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelInit"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelInit(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 30;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public byte Result
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the room index.
    /// </summary>
    public byte RoomIndex
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the player 1 name.
    /// </summary>
    public string Player1Name
    {
        get => this._data.Span.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the player 2 name.
    /// </summary>
    public string Player2Name
    {
        get => this._data.Span.ExtractString(16, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(16, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the player 1 id.
    /// </summary>
    public ushort Player1Id
    {
        get => ReadUInt16BigEndian(this._data.Span[26..]);
        set => WriteUInt16BigEndian(this._data.Span[26..], value);
    }

    /// <summary>
    /// Gets or sets the player 2 id.
    /// </summary>
    public ushort Player2Id
    {
        get => ReadUInt16BigEndian(this._data.Span[28..]);
        set => WriteUInt16BigEndian(this._data.Span[28..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DuelInit"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelInit(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelInit"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DuelInit packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When the duel starts, after the DuelInit message.
/// Causes reaction on client side: The client updates the displayed health and shield bars.
/// </summary>
public readonly struct DuelHealthBarInit
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelHealthBarInit"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelHealthBarInit(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelHealthBarInit"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelHealthBarInit(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DuelHealthBarInit"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelHealthBarInit(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelHealthBarInit"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DuelHealthBarInit packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When a spectator joins a duel.
/// Causes reaction on client side: The client updates the list of spectators.
/// </summary>
public readonly struct DuelSpectatorAdded
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorAdded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelSpectatorAdded(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorAdded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelSpectatorAdded(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x08;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DuelSpectatorAdded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelSpectatorAdded(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelSpectatorAdded"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DuelSpectatorAdded packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When a spectator joins a duel.
/// Causes reaction on client side: The client updates the list of spectators.
/// </summary>
public readonly struct DuelSpectatorRemoved
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorRemoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelSpectatorRemoved(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorRemoved"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelSpectatorRemoved(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DuelSpectatorRemoved"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelSpectatorRemoved(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelSpectatorRemoved"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DuelSpectatorRemoved packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: When a spectator joins or leaves a duel.
/// Causes reaction on client side: The client updates the list of spectators.
/// </summary>
public readonly struct DuelSpectatorList
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelSpectatorList(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectatorList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelSpectatorList(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 105;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the count.
    /// </summary>
    public byte Count
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="DuelSpectator"/> of the specified index.
    /// </summary>
        public DuelSpectator this[int index] => new (this._data.Slice(5 + index * DuelSpectator.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DuelSpectatorList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelSpectatorList(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelSpectatorList"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DuelSpectatorList packet) => packet._data; 


/// <summary>
/// Structure for a duel room entry..
/// </summary>
public readonly struct DuelSpectator
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelSpectator"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelSpectator(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }
}
}


/// <summary>
/// Is sent by the server when: When the duel finished.
/// Causes reaction on client side: The client shows the winner and loser names.
/// </summary>
public readonly struct DuelFinished
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelFinished"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DuelFinished(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DuelFinished"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DuelFinished(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAA;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the winner.
    /// </summary>
    public string Winner
    {
        get => this._data.Span.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the loser.
    /// </summary>
    public string Loser
    {
        get => this._data.Span.ExtractString(14, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(14, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DuelFinished"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DuelFinished(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DuelFinished"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DuelFinished packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a player started a skill which needs to load up, like Nova.
/// Causes reaction on client side: The client may show the loading intensity.
/// </summary>
public readonly struct SkillStageUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillStageUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public SkillStageUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SkillStageUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private SkillStageUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.SkillNumber = 0x28;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBA;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the object id.
    /// </summary>
    public ushort ObjectId
    {
        get => ReadUInt16LittleEndian(this._data.Span[3..]);
        set => WriteUInt16LittleEndian(this._data.Span[3..], value);
    }

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public byte SkillNumber
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the stage.
    /// </summary>
    public byte Stage
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="SkillStageUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator SkillStageUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="SkillStageUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(SkillStageUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to enter the illusion temple event.
/// Causes reaction on client side: The client shows the result.
/// </summary>
public readonly struct IllusionTempleEnterResult
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleEnterResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleEnterResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleEnterResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleEnterResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x00;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public byte Result
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="IllusionTempleEnterResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleEnterResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleEnterResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(IllusionTempleEnterResult packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player is in the illusion temple event and the server sends a cyclic update.
/// Causes reaction on client side: The client shows the state in the user interface.
/// </summary>
public readonly struct IllusionTempleState
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleState"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleState(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleState"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleState(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the remaining seconds.
    /// </summary>
    public ushort RemainingSeconds
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the player index.
    /// </summary>
    public ushort PlayerIndex
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the team 1 points.
    /// </summary>
    public byte Team1Points
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the team 2 points.
    /// </summary>
    public byte Team2Points
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }

    /// <summary>
    /// Gets or sets the my team.
    /// </summary>
    public byte MyTeam
    {
        get => this._data.Span[10];
        set => this._data.Span[10] = value;
    }

    /// <summary>
    /// Gets or sets the party count.
    /// </summary>
    public byte PartyCount
    {
        get => this._data.Span[11];
        set => this._data.Span[11] = value;
    }

    /// <summary>
    /// Gets the <see cref="IllusionTemplePartyEntry"/> of the specified index.
    /// </summary>
        public IllusionTemplePartyEntry this[int index] => new (this._data.Slice(12 + index * IllusionTemplePartyEntry.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="IllusionTempleState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleState(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleState"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(IllusionTempleState packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="IllusionTemplePartyEntry"/>.
    /// </summary>
    /// <param name="partyMembersCount">The count of <see cref="IllusionTemplePartyEntry"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int partyMembersCount) => partyMembersCount * IllusionTemplePartyEntry.Length + 12;


/// <summary>
/// Contains the info about a party member in illusion temple..
/// </summary>
public readonly struct IllusionTemplePartyEntry
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTemplePartyEntry"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTemplePartyEntry(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16LittleEndian(this._data.Span);
        set => WriteUInt16LittleEndian(this._data.Span, value);
    }

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public ushort MapNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[2..]);
        set => WriteUInt16LittleEndian(this._data.Span[2..], value);
    }

    /// <summary>
    /// Gets or sets the position x.
    /// </summary>
    public byte PositionX
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the position y.
    /// </summary>
    public byte PositionY
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: A player requested to use a specific skill in the illusion temple event.
/// Causes reaction on client side: The client shows the result.
/// </summary>
public readonly struct IllusionTempleSkillUsageResult
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillUsageResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleSkillUsageResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillUsageResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleSkillUsageResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x02;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 11;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public byte Result
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16BigEndian(this._data.Span[5..]);
        set => WriteUInt16BigEndian(this._data.Span[5..], value);
    }

    /// <summary>
    /// Gets or sets the source object id.
    /// </summary>
    public ushort SourceObjectId
    {
        get => ReadUInt16LittleEndian(this._data.Span[7..]);
        set => WriteUInt16LittleEndian(this._data.Span[7..], value);
    }

    /// <summary>
    /// Gets or sets the target object id.
    /// </summary>
    public ushort TargetObjectId
    {
        get => ReadUInt16LittleEndian(this._data.Span[9..]);
        set => WriteUInt16LittleEndian(this._data.Span[9..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="IllusionTempleSkillUsageResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleSkillUsageResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleSkillUsageResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(IllusionTempleSkillUsageResult packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: ?
/// Causes reaction on client side: The client shows the counts.
/// </summary>
public readonly struct IllusionTempleUserCount
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleUserCount"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleUserCount(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleUserCount"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleUserCount(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 10;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the user count 1.
    /// </summary>
    public byte UserCount1
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the user count 2.
    /// </summary>
    public byte UserCount2
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the user count 3.
    /// </summary>
    public byte UserCount3
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the user count 4.
    /// </summary>
    public byte UserCount4
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the user count 5.
    /// </summary>
    public byte UserCount5
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the user count 6.
    /// </summary>
    public byte UserCount6
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="IllusionTempleUserCount"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleUserCount(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleUserCount"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(IllusionTempleUserCount packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The illusion temple event ended.
/// Causes reaction on client side: The client shows the results.
/// </summary>
public readonly struct IllusionTempleResult
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x04;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the team 1 points.
    /// </summary>
    public byte Team1Points
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the team 2 points.
    /// </summary>
    public byte Team2Points
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the player count.
    /// </summary>
    public byte PlayerCount
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets the <see cref="PlayerResult"/> of the specified index.
    /// </summary>
        public PlayerResult this[int index] => new (this._data.Slice(10 + index * PlayerResult.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="IllusionTempleResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(IllusionTempleResult packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="PlayerResult"/>.
    /// </summary>
    /// <param name="playersCount">The count of <see cref="PlayerResult"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int playersCount) => playersCount * PlayerResult.Length + 10;


/// <summary>
/// Contains the result of a player in the event..
/// </summary>
public readonly struct PlayerResult
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="PlayerResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public PlayerResult(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 17;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(0, this._data.Length - 0, System.Text.Encoding.UTF8);
        set => this._data.Slice(0).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the map number.
    /// </summary>
    public byte MapNumber
    {
        get => this._data.Span[10];
        set => this._data.Span[10] = value;
    }

    /// <summary>
    /// Gets or sets the team.
    /// </summary>
    public byte Team
    {
        get => this._data.Span[11];
        set => this._data.Span[11] = value;
    }

    /// <summary>
    /// Gets or sets the class.
    /// </summary>
    public byte Class
    {
        get => this._data.Span[12];
        set => this._data.Span[12] = value;
    }

    /// <summary>
    /// Gets or sets the added experience.
    /// </summary>
    public uint AddedExperience
    {
        get => ReadUInt32LittleEndian(this._data.Span[13..]);
        set => WriteUInt32LittleEndian(this._data.Span[13..], value);
    }

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Name' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 0;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Name' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 0;
}
}


/// <summary>
/// Is sent by the server when: ?
/// Causes reaction on client side: The client shows the skill points.
/// </summary>
public readonly struct IllusionTempleSkillPointUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillPointUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleSkillPointUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillPointUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleSkillPointUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x06;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill points.
    /// </summary>
    public byte SkillPoints
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="IllusionTempleSkillPointUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleSkillPointUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleSkillPointUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(IllusionTempleSkillPointUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: ?
/// Causes reaction on client side: The client shows the skill points.
/// </summary>
public readonly struct IllusionTempleSkillEnded
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillEnded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleSkillEnded(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillEnded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleSkillEnded(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the object index.
    /// </summary>
    public ushort ObjectIndex
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="IllusionTempleSkillEnded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleSkillEnded(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleSkillEnded"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(IllusionTempleSkillEnded packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: ?
/// Causes reaction on client side: ?.
/// </summary>
public readonly struct IllusionTempleHolyItemRelics
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleHolyItemRelics"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleHolyItemRelics(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleHolyItemRelics"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleHolyItemRelics(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x08;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the user index.
    /// </summary>
    public ushort UserIndex
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(6, this._data.Length - 6, System.Text.Encoding.UTF8);
        set => this._data.Slice(6).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="IllusionTempleHolyItemRelics"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleHolyItemRelics(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleHolyItemRelics"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(IllusionTempleHolyItemRelics packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Name' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 6;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Name' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 6;
}


/// <summary>
/// Is sent by the server when: ?
/// Causes reaction on client side: The client shows the skill points.
/// </summary>
public readonly struct IllusionTempleSkillEnd
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillEnd"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public IllusionTempleSkillEnd(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IllusionTempleSkillEnd"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private IllusionTempleSkillEnd(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x07;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the temple number.
    /// </summary>
    public byte TempleNumber
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the state.
    /// </summary>
    public byte State
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="IllusionTempleSkillEnd"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator IllusionTempleSkillEnd(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="IllusionTempleSkillEnd"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(IllusionTempleSkillEnd packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player applied chain lightning to a target and the server calculated the hits.
/// Causes reaction on client side: The client shows the chain lightning effect.
/// </summary>
public readonly struct ChainLightningHitInfo
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChainLightningHitInfo"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChainLightningHitInfo(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChainLightningHitInfo"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChainLightningHitInfo(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0A;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the skill number.
    /// </summary>
    public ushort SkillNumber
    {
        get => ReadUInt16BigEndian(this._data.Span[4..]);
        set => WriteUInt16BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the player id.
    /// </summary>
    public ushort PlayerId
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the target count.
    /// </summary>
    public byte TargetCount
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets the <see cref="ChainTarget"/> of the specified index.
    /// </summary>
        public ChainTarget this[int index] => new (this._data.Slice(10 + index * ChainTarget.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ChainLightningHitInfo"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChainLightningHitInfo(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChainLightningHitInfo"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ChainLightningHitInfo packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="ChainTarget"/>.
    /// </summary>
    /// <param name="targetsCount">The count of <see cref="ChainTarget"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int targetsCount) => targetsCount * ChainTarget.Length + 10;


/// <summary>
/// Contains the target identifier..
/// </summary>
public readonly struct ChainTarget
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChainTarget"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChainTarget(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 2;

    /// <summary>
    /// Gets or sets the target id.
    /// </summary>
    public ushort TargetId
    {
        get => ReadUInt16LittleEndian(this._data.Span);
        set => WriteUInt16LittleEndian(this._data.Span, value);
    }
}
}


/// <summary>
/// Is sent by the server when: The server validated or changed the status of the MU Helper.
/// Causes reaction on client side: The client toggle the MU Helper status.
/// </summary>
public readonly struct MuHelperStatusUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MuHelperStatusUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MuHelperStatusUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MuHelperStatusUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MuHelperStatusUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xBF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x51;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 16;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the flag, if money should be consumed. If this is 'true', setting PauseStatus to 'false' doesn't cause starting the helper.
    /// </summary>
    public bool ConsumeMoney
    {
        get => this._data.Span[4..].GetBoolean();
        set => this._data.Span[4..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the money.
    /// </summary>
    public uint Money
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the pause status. A value of 'true' always works to stop the helper. However, it can only be started, with ConsumeMoney set to 'false'.
    /// </summary>
    public bool PauseStatus
    {
        get => this._data.Span[12..].GetBoolean();
        set => this._data.Span[12..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MuHelperStatusUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MuHelperStatusUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MuHelperStatusUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MuHelperStatusUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The server saved the users MU Helper data.
/// Causes reaction on client side: The user wants to save the MU Helper data.
/// </summary>
public readonly struct MuHelperConfigurationData
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MuHelperConfigurationData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MuHelperConfigurationData(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MuHelperConfigurationData"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MuHelperConfigurationData(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAE;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 261;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the helper data.
    /// </summary>
    public Span<byte> HelperData
    {
        get => this._data.Slice(4, 257).Span;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MuHelperConfigurationData"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MuHelperConfigurationData(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MuHelperConfigurationData"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MuHelperConfigurationData packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After entering the game with a character.
/// Causes reaction on client side: 
/// </summary>
public readonly struct MessengerInitialization
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MessengerInitialization"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MessengerInitialization(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MessengerInitialization"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MessengerInitialization(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC0;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the letter count.
    /// </summary>
    public byte LetterCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the maximum letter count.
    /// </summary>
    public byte MaximumLetterCount
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the friend count.
    /// </summary>
    public byte FriendCount
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets the <see cref="Friend"/> of the specified index.
    /// </summary>
        public Friend this[int index] => new (this._data.Slice(7 + index * Friend.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MessengerInitialization"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MessengerInitialization(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MessengerInitialization"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MessengerInitialization packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="Friend"/>.
    /// </summary>
    /// <param name="friendsCount">The count of <see cref="Friend"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int friendsCount) => friendsCount * Friend.Length + 7;


/// <summary>
/// The structure which contains the friend name and online state..
/// </summary>
public readonly struct Friend
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="Friend"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public Friend(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 11;

    /// <summary>
    /// Gets or sets the name.
    /// </summary>
    public string Name
    {
        get => this._data.Span.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the server id on which the player currently is online. 0xFF means offline.
    /// </summary>
    public byte ServerId
    {
        get => this._data.Span[10];
        set => this._data.Span[10] = value;
    }
}
}


/// <summary>
/// Is sent by the server when: After a friend has been added to the friend list.
/// Causes reaction on client side: The friend appears in the friend list.
/// </summary>
public readonly struct FriendAdded
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendAdded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendAdded(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendAdded"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendAdded(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
            this.ServerId = 0xFF;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC1;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 15;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the friend name.
    /// </summary>
    public string FriendName
    {
        get => this._data.Span.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the server id on which the player currently is online. 0xFF means offline.
    /// </summary>
    public byte ServerId
    {
        get => this._data.Span[14];
        set => this._data.Span[14] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="FriendAdded"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendAdded(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendAdded"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(FriendAdded packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a player has requested to add another player as friend. This other player gets this message.
/// Causes reaction on client side: The friend request appears on the user interface.
/// </summary>
public readonly struct FriendRequest
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendRequest"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendRequest(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendRequest"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendRequest(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC2;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the requester.
    /// </summary>
    public string Requester
    {
        get => this._data.Span.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="FriendRequest"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendRequest(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendRequest"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(FriendRequest packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a friend has been removed from the friend list.
/// Causes reaction on client side: The friend is removed from the friend list.
/// </summary>
public readonly struct FriendDeleted
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendDeleted"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendDeleted(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendDeleted"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendDeleted(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC3;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the friend name.
    /// </summary>
    public string FriendName
    {
        get => this._data.Span.ExtractString(4, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(4, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="FriendDeleted"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendDeleted(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendDeleted"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(FriendDeleted packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a friend has been added to the friend list.
/// Causes reaction on client side: The friend appears in the friend list.
/// </summary>
public readonly struct FriendOnlineStateUpdate
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendOnlineStateUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendOnlineStateUpdate(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendOnlineStateUpdate"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendOnlineStateUpdate(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC4;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 14;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the friend name.
    /// </summary>
    public string FriendName
    {
        get => this._data.Span.ExtractString(3, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the server id on which the player currently is online. 0xFF means offline.
    /// </summary>
    public byte ServerId
    {
        get => this._data.Span[13];
        set => this._data.Span[13] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="FriendOnlineStateUpdate"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendOnlineStateUpdate(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendOnlineStateUpdate"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(FriendOnlineStateUpdate packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to send a letter to another player.
/// Causes reaction on client side: Depending on the result, the letter send dialog closes or an error message appears.
/// </summary>
public readonly struct LetterSendResponse
{
    /// <summary>
    /// Describes the result of a letter send request.
    /// </summary>
    public enum LetterSendRequestResult
    {
        /// <summary>
        /// The letter wasn't sent because there was an internal problem. The user should try again.
        /// </summary>
            TryAgain = 0,

        /// <summary>
        /// The letter was sent.
        /// </summary>
            Success = 1,

        /// <summary>
        /// The mailbox of the recipient is full.
        /// </summary>
            MailboxFull = 2,

        /// <summary>
        /// The receiver does not exist.
        /// </summary>
            ReceiverNotExists = 3,

        /// <summary>
        /// A letter can't be sent to yourself.
        /// </summary>
            CantSendToYourself = 4,

        /// <summary>
        /// The sender doesn't have enough money to send a letter.
        /// </summary>
            NotEnoughMoney = 7,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="LetterSendResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public LetterSendResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="LetterSendResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private LetterSendResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC5;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the letter id.
    /// </summary>
    public uint LetterId
    {
        get => ReadUInt32LittleEndian(this._data.Span[4..]);
        set => WriteUInt32LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public LetterSendResponse.LetterSendRequestResult Result
    {
        get => (LetterSendRequestResult)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="LetterSendResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator LetterSendResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="LetterSendResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(LetterSendResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After a letter has been received or after the player entered the game with a character.
/// Causes reaction on client side: The letter appears in the letter list.
/// </summary>
public readonly struct AddLetter
{
    /// <summary>
    /// Describes the state of a letter.
    /// </summary>
    public enum LetterState
    {
        /// <summary>
        /// The letter was read before.
        /// </summary>
            Read = 0,

        /// <summary>
        /// The letter wasn't read yet.
        /// </summary>
            Unread = 1,

        /// <summary>
        /// The letter is new (= was just sent by the sender) and wasn't read yet. It will notify the user about the received letter.
        /// </summary>
            New = 2,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AddLetter"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AddLetter(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AddLetter"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AddLetter(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC6;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 79;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the letter index.
    /// </summary>
    public ushort LetterIndex
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the sender name.
    /// </summary>
    public string SenderName
    {
        get => this._data.Span.ExtractString(6, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(6, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the timestamp.
    /// </summary>
    public string Timestamp
    {
        get => this._data.Span.ExtractString(16, 30, System.Text.Encoding.UTF8);
        set => this._data.Slice(16, 30).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the subject.
    /// </summary>
    public string Subject
    {
        get => this._data.Span.ExtractString(46, 32, System.Text.Encoding.UTF8);
        set => this._data.Slice(46, 32).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the state.
    /// </summary>
    public AddLetter.LetterState State
    {
        get => (LetterState)this._data.Span[78];
        set => this._data.Span[78] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AddLetter"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AddLetter(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AddLetter"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AddLetter packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the player requested to read a letter.
/// Causes reaction on client side: The letter is opened in a new dialog.
/// </summary>
public readonly struct OpenLetter
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenLetter"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public OpenLetter(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenLetter"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private OpenLetter(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC4;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C4Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the letter index.
    /// </summary>
    public ushort LetterIndex
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the message size.
    /// </summary>
    public ushort MessageSize
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the sender appearance.
    /// </summary>
    public Span<byte> SenderAppearance
    {
        get => this._data.Slice(8, 18).Span;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[26];
        set => this._data.Span[26] = value;
    }

    /// <summary>
    /// Gets or sets the animation.
    /// </summary>
    public byte Animation
    {
        get => this._data.Span[27];
        set => this._data.Span[27] = value;
    }

    /// <summary>
    /// Gets or sets the message.
    /// </summary>
    public string Message
    {
        get => this._data.Span.ExtractString(28, this._data.Length - 28, System.Text.Encoding.UTF8);
        set => this._data.Slice(28).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="OpenLetter"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator OpenLetter(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="OpenLetter"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(OpenLetter packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 28;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 28;
}


/// <summary>
/// Is sent by the server when: After the player requested to read a letter.
/// Causes reaction on client side: The letter is opened in a new dialog.
/// </summary>
public readonly struct OpenLetterExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenLetterExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public OpenLetterExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenLetterExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private OpenLetterExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC4;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C4Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the letter index.
    /// </summary>
    public ushort LetterIndex
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the sender appearance.
    /// </summary>
    public Span<byte> SenderAppearance
    {
        get => this._data.Slice(6, 42).Span;
    }

    /// <summary>
    /// Gets or sets the rotation.
    /// </summary>
    public byte Rotation
    {
        get => this._data.Span[48];
        set => this._data.Span[48] = value;
    }

    /// <summary>
    /// Gets or sets the animation.
    /// </summary>
    public byte Animation
    {
        get => this._data.Span[49];
        set => this._data.Span[49] = value;
    }

    /// <summary>
    /// Gets or sets the message.
    /// </summary>
    public string Message
    {
        get => this._data.Span.ExtractString(50, this._data.Length - 50, System.Text.Encoding.UTF8);
        set => this._data.Slice(50).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="OpenLetterExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator OpenLetterExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="OpenLetterExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(OpenLetterExtended packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="content">The content of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 50;

    /// <summary>
    /// Calculates the size of the packet for the specified field content.
    /// </summary>
    /// <param name="contentLength">The content length in bytes of the variable 'Message' field from which the size will be calculated.</param>
    public static int GetRequiredSize(int contentLength) => contentLength + 1 + 50;
}


/// <summary>
/// Is sent by the server when: After a letter has been deleted by the request of the player.
/// Causes reaction on client side: The letter is removed from the letter list.
/// </summary>
public readonly struct RemoveLetter
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="RemoveLetter"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public RemoveLetter(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="RemoveLetter"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private RemoveLetter(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.RequestSuccessful = true;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xC8;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 6;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the request successful.
    /// </summary>
    public bool RequestSuccessful
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the letter index.
    /// </summary>
    public ushort LetterIndex
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="RemoveLetter"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator RemoveLetter(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="RemoveLetter"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(RemoveLetter packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player is invited to join a chat room on the chat server.
/// Causes reaction on client side: The game client connects to the chat server and joins the chat room with the specified authentication data.
/// </summary>
public readonly struct ChatRoomConnectionInfo
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatRoomConnectionInfo"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChatRoomConnectionInfo(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChatRoomConnectionInfo"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChatRoomConnectionInfo(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.Type = 1;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xCA;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 36;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the chat server ip.
    /// </summary>
    public string ChatServerIp
    {
        get => this._data.Span.ExtractString(3, 15, System.Text.Encoding.UTF8);
        set => this._data.Slice(3, 15).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the chat room id.
    /// </summary>
    public ushort ChatRoomId
    {
        get => ReadUInt16LittleEndian(this._data.Span[18..]);
        set => WriteUInt16LittleEndian(this._data.Span[18..], value);
    }

    /// <summary>
    /// Gets or sets the authentication token.
    /// </summary>
    public uint AuthenticationToken
    {
        get => ReadUInt32LittleEndian(this._data.Span[20..]);
        set => WriteUInt32LittleEndian(this._data.Span[20..], value);
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data.Span[24];
        set => this._data.Span[24] = value;
    }

    /// <summary>
    /// Gets or sets the friend name.
    /// </summary>
    public string FriendName
    {
        get => this._data.Span.ExtractString(25, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(25, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[35..].GetBoolean();
        set => this._data.Span[35..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ChatRoomConnectionInfo"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChatRoomConnectionInfo(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChatRoomConnectionInfo"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ChatRoomConnectionInfo packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to add another player to his friend list and the server processed this request.
/// Causes reaction on client side: The game client knows if the invitation could be sent to the other player.
/// </summary>
public readonly struct FriendInvitationResult
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendInvitationResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public FriendInvitationResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="FriendInvitationResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private FriendInvitationResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xCB;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the request id.
    /// </summary>
    public uint RequestId
    {
        get => ReadUInt32BigEndian(this._data.Span[4..]);
        set => WriteUInt32BigEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="FriendInvitationResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator FriendInvitationResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="FriendInvitationResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(FriendInvitationResult packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the game client requested the list of event quests after entering the game. It seems to be sent only if the character is not a member of a Gen.
/// Causes reaction on client side: Unknown.
/// </summary>
public readonly struct QuestEventResponse
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestEventResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestEventResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestEventResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestEventResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x03;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets the <see cref="QuestIdentification"/> of the specified index.
    /// </summary>
        public QuestIdentification this[int index] => new (this._data.Slice(4 + index * QuestIdentification.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="QuestEventResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestEventResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestEventResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(QuestEventResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the game client requested the list of available quests through an NPC dialog.
/// Causes reaction on client side: The client shows the available quests for the currently interacting NPC.
/// </summary>
public readonly struct AvailableQuests
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="AvailableQuests"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public AvailableQuests(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AvailableQuests"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private AvailableQuests(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0A;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest npc number.
    /// </summary>
    public ushort QuestNpcNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest count.
    /// </summary>
    public ushort QuestCount
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets the <see cref="QuestIdentification"/> of the specified index.
    /// </summary>
        public QuestIdentification this[int index] => new (this._data.Slice(8 + index * QuestIdentification.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="AvailableQuests"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator AvailableQuests(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="AvailableQuests"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(AvailableQuests packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="QuestIdentification"/>.
    /// </summary>
    /// <param name="questsCount">The count of <see cref="QuestIdentification"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int questsCount) => questsCount * QuestIdentification.Length + 8;
}


/// <summary>
/// Is sent by the server when: After the game client clicked on a quest in the quest list, proceeded with a quest or refused to start a quest.
/// Causes reaction on client side: The client shows the corresponding description about the current quest step.
/// </summary>
public readonly struct QuestStepInfo
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStepInfo"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestStepInfo(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStepInfo"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestStepInfo(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 11;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets a number specifying the description: A) when selecting a quest in the quest list, it's the "StartingNumber"; B) when a quest has been started it's the quest number; C) when the starting number has been sent previously and the player refused to start the quest, it sends a "RefuseNumber".
    /// </summary>
    public ushort QuestStepNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="QuestStepInfo"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestStepInfo(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestStepInfo"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(QuestStepInfo packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: First, after the game client requested to initialize a quest and the quest is already active. Second, after the game client requested the next quest step.
/// Causes reaction on client side: The client shows the quest progress accordingly.
/// </summary>
public readonly struct QuestProgress
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestProgress"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestProgress(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestProgress"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestProgress(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 251;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the condition count.
    /// </summary>
    public byte ConditionCount
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the reward count.
    /// </summary>
    public byte RewardCount
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }

    /// <summary>
    /// Gets the <see cref="QuestCondition"/> of the specified index.
    /// </summary>
    public QuestCondition GetQuestCondition(int index) => new (this._data.Slice(11 + index * QuestConditionRef.Length));

    /// <summary>
    /// Gets the <see cref="QuestReward"/> of the specified index.
    /// </summary>
    public QuestReward GetQuestReward(int index) => new (this._data.Slice(141 + index * QuestRewardRef.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="QuestProgress"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestProgress(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestProgress"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(QuestProgress packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="QuestCondition"/>.
    /// </summary>
    /// <param name="conditionsCount">The count of <see cref="QuestCondition"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int conditionsCount) => conditionsCount * QuestCondition.Length + 11;
}


/// <summary>
/// Is sent by the server when: First, after the game client requested to initialize a quest and the quest is already active. Second, after the game client requested the next quest step.
/// Causes reaction on client side: The client shows the quest progress accordingly.
/// </summary>
public readonly struct QuestProgressExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestProgressExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestProgressExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestProgressExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestProgressExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0C;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 272;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the condition count.
    /// </summary>
    public byte ConditionCount
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the reward count.
    /// </summary>
    public byte RewardCount
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the random reward count.
    /// </summary>
    public byte RandomRewardCount
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[8..]);
        set => WriteUInt16LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data.Span[10..]);
        set => WriteUInt16LittleEndian(this._data.Span[10..], value);
    }

    /// <summary>
    /// Gets the <see cref="QuestConditionExtended"/> of the specified index.
    /// </summary>
    public QuestConditionExtended GetQuestConditionExtended(int index) => new (this._data.Slice(12 + index * QuestConditionExtendedRef.Length));

    /// <summary>
    /// Gets the <see cref="QuestRewardExtended"/> of the specified index.
    /// </summary>
    public QuestRewardExtended GetQuestRewardExtended(int index) => new (this._data.Slice(152 + index * QuestRewardExtendedRef.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="QuestProgressExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestProgressExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestProgressExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(QuestProgressExtended packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="QuestConditionExtended"/>.
    /// </summary>
    /// <param name="conditionsCount">The count of <see cref="QuestConditionExtended"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int conditionsCount) => conditionsCount * QuestConditionExtended.Length + 12;
}


/// <summary>
/// Is sent by the server when: The server acknowledges the completion of a quest.
/// Causes reaction on client side: The client shows the success and possibly requests for the next available quests.
/// </summary>
public readonly struct QuestCompletionResponse
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCompletionResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestCompletionResponse(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCompletionResponse"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestCompletionResponse(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0D;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 9;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the is quest completed.
    /// </summary>
    public bool IsQuestCompleted
    {
        get => this._data.Span[8..].GetBoolean();
        set => this._data.Span[8..].SetBoolean(value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="QuestCompletionResponse"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestCompletionResponse(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestCompletionResponse"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(QuestCompletionResponse packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The server acknowledges the requested cancellation of a quest.
/// Causes reaction on client side: The client resets the state of the quest and can request a new list of available quests again. This list would then probably contain the cancelled quest again.
/// </summary>
public readonly struct QuestCancelled
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCancelled"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestCancelled(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestCancelled"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestCancelled(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x0F;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 8;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the current quest number. In this message, it's always 0, because the group is relevant for the client.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="QuestCancelled"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestCancelled(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestCancelled"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(QuestCancelled packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: After the game client requested the list of all quests which are currently in progress or accepted.
/// Causes reaction on client side: Unknown.
/// </summary>
public readonly struct QuestStateList
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStateList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestStateList(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStateList"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestStateList(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x1A;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest count.
    /// </summary>
    public byte QuestCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="QuestIdentification"/> of the specified index.
    /// </summary>
        public QuestIdentification this[int index] => new (this._data.Slice(5 + index * QuestIdentification.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="QuestStateList"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestStateList(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestStateList"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(QuestStateList packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="QuestIdentification"/>.
    /// </summary>
    /// <param name="questsCount">The count of <see cref="QuestIdentification"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int questsCount) => questsCount * QuestIdentification.Length + 5;
}


/// <summary>
/// Is sent by the server when: After the game client requested it, when the player opened the quest menu and clicked on a quest.
/// Causes reaction on client side: The client shows the quest progress accordingly.
/// </summary>
public readonly struct QuestState
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestState"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestState(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestState"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestState(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x1B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 251;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the condition count.
    /// </summary>
    public byte ConditionCount
    {
        get => this._data.Span[8];
        set => this._data.Span[8] = value;
    }

    /// <summary>
    /// Gets or sets the reward count.
    /// </summary>
    public byte RewardCount
    {
        get => this._data.Span[9];
        set => this._data.Span[9] = value;
    }

    /// <summary>
    /// Gets or sets the random reward count.
    /// </summary>
    public byte RandomRewardCount
    {
        get => this._data.Span[10];
        set => this._data.Span[10] = value;
    }

    /// <summary>
    /// Gets the <see cref="QuestCondition"/> of the specified index.
    /// </summary>
    public QuestCondition GetQuestCondition(int index) => new (this._data.Slice(11 + index * QuestConditionRef.Length));

    /// <summary>
    /// Gets the <see cref="QuestReward"/> of the specified index.
    /// </summary>
    public QuestReward GetQuestReward(int index) => new (this._data.Slice(141 + index * QuestRewardRef.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="QuestState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestState(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestState"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(QuestState packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="QuestCondition"/>.
    /// </summary>
    /// <param name="conditionsCount">The count of <see cref="QuestCondition"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int conditionsCount) => conditionsCount * QuestCondition.Length + 11;
}


/// <summary>
/// Is sent by the server when: After the game client requested it, when the player opened the quest menu and clicked on a quest.
/// Causes reaction on client side: The client shows the quest progress accordingly.
/// </summary>
public readonly struct QuestStateExtended
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStateExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public QuestStateExtended(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="QuestStateExtended"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private QuestStateExtended(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (ushort)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC2;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF6;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x1B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 272;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C2HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the condition count.
    /// </summary>
    public byte ConditionCount
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets the reward count.
    /// </summary>
    public byte RewardCount
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Gets or sets the random reward count.
    /// </summary>
    public byte RandomRewardCount
    {
        get => this._data.Span[7];
        set => this._data.Span[7] = value;
    }

    /// <summary>
    /// Gets or sets the quest number.
    /// </summary>
    public ushort QuestNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[8..]);
        set => WriteUInt16LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the quest group.
    /// </summary>
    public ushort QuestGroup
    {
        get => ReadUInt16LittleEndian(this._data.Span[10..]);
        set => WriteUInt16LittleEndian(this._data.Span[10..], value);
    }

    /// <summary>
    /// Gets the <see cref="QuestConditionExtended"/> of the specified index.
    /// </summary>
    public QuestConditionExtended GetQuestConditionExtended(int index) => new (this._data.Slice(12 + index * QuestConditionExtendedRef.Length));

    /// <summary>
    /// Gets the <see cref="QuestRewardExtended"/> of the specified index.
    /// </summary>
    public QuestRewardExtended GetQuestRewardExtended(int index) => new (this._data.Slice(152 + index * QuestRewardExtendedRef.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="QuestStateExtended"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator QuestStateExtended(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="QuestStateExtended"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(QuestStateExtended packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="QuestConditionExtended"/>.
    /// </summary>
    /// <param name="conditionsCount">The count of <see cref="QuestConditionExtended"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int conditionsCount) => conditionsCount * QuestConditionExtended.Length + 12;
}


/// <summary>
/// Is sent by the server when: The server acknowledges the requested opening of an npc dialog.
/// Causes reaction on client side: The client opens the dialog of the specified npc.
/// </summary>
public readonly struct OpenNpcDialog
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenNpcDialog"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public OpenNpcDialog(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="OpenNpcDialog"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private OpenNpcDialog(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC3;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xF9;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 12;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C3HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the npc number.
    /// </summary>
    public ushort NpcNumber
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the gens contribution points.
    /// </summary>
    public uint GensContributionPoints
    {
        get => ReadUInt32LittleEndian(this._data.Span[8..]);
        set => WriteUInt32LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="OpenNpcDialog"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator OpenNpcDialog(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="OpenNpcDialog"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(OpenNpcDialog packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to enter the devil square mini game through the Charon NPC.
/// Causes reaction on client side: In case it failed, it shows the corresponding error message.
/// </summary>
public readonly struct DevilSquareEnterResult
{
    /// <summary>
    /// Defines the result of the enter request.
    /// </summary>
    public enum EnterResult
    {
        /// <summary>
        /// The event has been entered.
        /// </summary>
            Success = 0,

        /// <summary>
        /// Entering the event failed, e.g. by missing event ticket or level range.
        /// </summary>
            Failed = 1,

        /// <summary>
        /// Entering the event failed, because it's not opened.
        /// </summary>
            NotOpen = 2,

        /// <summary>
        /// Entering the event failed, because the character level is too high for the requested event level.
        /// </summary>
            CharacterLevelTooHigh = 3,

        /// <summary>
        /// Entering the event failed, because the character level is too low for the requested event level.
        /// </summary>
            CharacterLevelTooLow = 4,

        /// <summary>
        /// Entering the event failed, because it's full.
        /// </summary>
            Full = 5,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="DevilSquareEnterResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public DevilSquareEnterResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DevilSquareEnterResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private DevilSquareEnterResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x90;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public DevilSquareEnterResult.EnterResult Result
    {
        get => (EnterResult)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="DevilSquareEnterResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator DevilSquareEnterResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="DevilSquareEnterResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(DevilSquareEnterResult packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requests to get the current opening state of a mini game event, by clicking on an ticket item.
/// Causes reaction on client side: The opening state of the event (remaining entering time, etc.) is shown at the client.
/// </summary>
public readonly struct MiniGameOpeningState
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MiniGameOpeningState"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MiniGameOpeningState(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MiniGameOpeningState"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MiniGameOpeningState(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x91;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 7;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the game type.
    /// </summary>
    public MiniGameType GameType
    {
        get => (MiniGameType)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the remaining entering time minutes.
    /// </summary>
    public byte RemainingEnteringTimeMinutes
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the user count.
    /// </summary>
    public byte UserCount
    {
        get => this._data.Span[5];
        set => this._data.Span[5] = value;
    }

    /// <summary>
    /// Gets or sets just used for Chaos Castle. In this case, this field contains the lower byte of the remaining minutes. For other event types, this field is not used.
    /// </summary>
    public byte RemainingEnteringTimeMinutesLow
    {
        get => this._data.Span[6];
        set => this._data.Span[6] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MiniGameOpeningState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MiniGameOpeningState(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MiniGameOpeningState"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MiniGameOpeningState packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The state of a mini game event is about to change in 30 seconds.
/// Causes reaction on client side: The client side shows a message about the changing state.
/// </summary>
public readonly struct UpdateMiniGameState
{
    /// <summary>
    /// The state of the mini games.
    /// </summary>
    public enum MiniGameTypeState
    {
        /// <summary>
        /// Is sent when the devil square is currently closed and will be opened. "You will enter Devil Square (x seconds from now)".
        /// </summary>
            DevilSquareClosed = 0,

        /// <summary>
        /// Is sent when the devil square game is currently opened for entrance and closing for entrance. "The gate of Devil Square will close down in x seconds".
        /// </summary>
            DevilSquareOpened = 1,

        /// <summary>
        /// Is sent when the devil square game is currently running and is about to end. "The gate of Devil Square is closing down (x seconds remaining)".
        /// </summary>
            DevilSquareRunning = 2,

        /// <summary>
        /// The blood castle game is closed. "Blood Castle Closing (in x seconds)".
        /// </summary>
            BloodCastleClosed = 3,

        /// <summary>
        /// The blood castle game is opened for entrance. "Blood Castle Infiltration (in x seconds)".
        /// </summary>
            BloodCastleOpened = 4,

        /// <summary>
        /// The blood castle game is ending. "Blood Castle ends (in x seconds)".
        /// </summary>
            BloodCastleEnding = 5,

        /// <summary>
        /// The blood castle game is finished. "Blood Castle Event shuts down (in x seconds)".
        /// </summary>
            BloodCastleFinished = 6,

        /// <summary>
        /// The blood castle game was finished successfully. "Congratulations".
        /// </summary>
            BloodCastleCongratulations = 7,

        /// <summary>
        /// The chaos castle game is closed. "Chaos Castle Closing (in x seconds)".
        /// </summary>
            ChaosCastleClosed = 10,

        /// <summary>
        /// The chaos castle game is opened for entrance. "Chaos Castle Penetration (in x seconds)".
        /// </summary>
            ChaosCastleOpened = 11,

        /// <summary>
        /// The chaos castle game is ending. "Chaos Castle Event ends (in x seconds)".
        /// </summary>
            ChaosCastleEnding = 12,

        /// <summary>
        /// The chaos castle game is finished. Chaos Castle Event shuts down (in x seconds)".
        /// </summary>
            ChaosCastleFinished = 13,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="UpdateMiniGameState"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public UpdateMiniGameState(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="UpdateMiniGameState"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private UpdateMiniGameState(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x92;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the state.
    /// </summary>
    public UpdateMiniGameState.MiniGameTypeState State
    {
        get => (MiniGameTypeState)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="UpdateMiniGameState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator UpdateMiniGameState(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="UpdateMiniGameState"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(UpdateMiniGameState packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: A mini game ended and the score table is sent to the player.
/// Causes reaction on client side: The score table is shown at the client.
/// </summary>
public readonly struct MiniGameScoreTable
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MiniGameScoreTable"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MiniGameScoreTable(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MiniGameScoreTable"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MiniGameScoreTable(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)data.Length;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x93;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the player rank.
    /// </summary>
    public byte PlayerRank
    {
        get => this._data.Span[3];
        set => this._data.Span[3] = value;
    }

    /// <summary>
    /// Gets or sets the result count.
    /// </summary>
    public byte ResultCount
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets the <see cref="ResultItem"/> of the specified index.
    /// </summary>
        public ResultItem this[int index] => new (this._data.Slice(5 + index * ResultItem.Length));

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MiniGameScoreTable"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MiniGameScoreTable(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MiniGameScoreTable"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MiniGameScoreTable packet) => packet._data; 

    /// <summary>
    /// Calculates the size of the packet for the specified count of <see cref="ResultItem"/>.
    /// </summary>
    /// <param name="resultsCount">The count of <see cref="ResultItem"/> from which the size will be calculated.</param>
        
    public static int GetRequiredSize(int resultsCount) => resultsCount * ResultItem.Length + 5;


/// <summary>
/// The result of one player..
/// </summary>
public readonly struct ResultItem
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ResultItem"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ResultItem(Memory<byte> data)
    {
        this._data = data;
    }

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 24;

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.Span.ExtractString(0, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(0, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the total score.
    /// </summary>
    public uint TotalScore
    {
        get => ReadUInt32LittleEndian(this._data.Span[12..]);
        set => WriteUInt32LittleEndian(this._data.Span[12..], value);
    }

    /// <summary>
    /// Gets or sets the bonus experience.
    /// </summary>
    public uint BonusExperience
    {
        get => ReadUInt32LittleEndian(this._data.Span[16..]);
        set => WriteUInt32LittleEndian(this._data.Span[16..], value);
    }

    /// <summary>
    /// Gets or sets the bonus money.
    /// </summary>
    public uint BonusMoney
    {
        get => ReadUInt32LittleEndian(this._data.Span[20..]);
        set => WriteUInt32LittleEndian(this._data.Span[20..], value);
    }
}
}


/// <summary>
/// Is sent by the server when: The blood castle mini game ended and the score of the player is sent to the player.
/// Causes reaction on client side: The score is shown at the client.
/// </summary>
public readonly struct BloodCastleScore
{
    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleScore"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public BloodCastleScore(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleScore"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private BloodCastleScore(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            this.Type = 0xFF;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x93;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 29;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the success.
    /// </summary>
    public bool Success
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the type.
    /// </summary>
    public byte Type
    {
        get => this._data.Span[4];
        set => this._data.Span[4] = value;
    }

    /// <summary>
    /// Gets or sets the player name.
    /// </summary>
    public string PlayerName
    {
        get => this._data.Span.ExtractString(5, 10, System.Text.Encoding.UTF8);
        set => this._data.Slice(5, 10).Span.WriteString(value, System.Text.Encoding.UTF8);
    }

    /// <summary>
    /// Gets or sets the total score.
    /// </summary>
    public uint TotalScore
    {
        get => ReadUInt32LittleEndian(this._data.Span[17..]);
        set => WriteUInt32LittleEndian(this._data.Span[17..], value);
    }

    /// <summary>
    /// Gets or sets the bonus experience.
    /// </summary>
    public uint BonusExperience
    {
        get => ReadUInt32LittleEndian(this._data.Span[21..]);
        set => WriteUInt32LittleEndian(this._data.Span[21..], value);
    }

    /// <summary>
    /// Gets or sets the bonus money.
    /// </summary>
    public uint BonusMoney
    {
        get => ReadUInt32LittleEndian(this._data.Span[25..]);
        set => WriteUInt32LittleEndian(this._data.Span[25..], value);
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="BloodCastleScore"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator BloodCastleScore(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="BloodCastleScore"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(BloodCastleScore packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to enter the blood castle mini game through the Archangel Messenger NPC.
/// Causes reaction on client side: In case it failed, it shows the corresponding error message.
/// </summary>
public readonly struct BloodCastleEnterResult
{
    /// <summary>
    /// Defines the result of the enter request.
    /// </summary>
    public enum EnterResult
    {
        /// <summary>
        /// The event has been entered.
        /// </summary>
            Success = 0,

        /// <summary>
        /// Entering the event failed, e.g. by missing event ticket or level range.
        /// </summary>
            Failed = 1,

        /// <summary>
        /// Entering the event failed, because it's not opened.
        /// </summary>
            NotOpen = 2,

        /// <summary>
        /// Entering the event failed, because the character level is too high for the requested event level.
        /// </summary>
            CharacterLevelTooHigh = 3,

        /// <summary>
        /// Entering the event failed, because the character level is too low for the requested event level.
        /// </summary>
            CharacterLevelTooLow = 4,

        /// <summary>
        /// Entering the event failed, because it's full.
        /// </summary>
            Full = 5,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleEnterResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public BloodCastleEnterResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleEnterResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private BloodCastleEnterResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x9A;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 4;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public BloodCastleEnterResult.EnterResult Result
    {
        get => (EnterResult)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="BloodCastleEnterResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator BloodCastleEnterResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="BloodCastleEnterResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(BloodCastleEnterResult packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The state of a blood castle event is about to change.
/// Causes reaction on client side: The client side shows a message about the changing state.
/// </summary>
public readonly struct BloodCastleState
{
    /// <summary>
    /// Defines the status of the event.
    /// </summary>
    public enum Status
    {
        /// <summary>
        /// The blood castle event has just started and is running.
        /// </summary>
            BloodCastleStarted = 0,

        /// <summary>
        /// The blood castle event is running, but the gate is not destroyed.
        /// </summary>
            BloodCastleGateNotDestroyed = 1,

        /// <summary>
        /// The blood castle event has ended.
        /// </summary>
            BloodCastleEnded = 2,

        /// <summary>
        /// The blood castle event is running and the gate is destroyed.
        /// </summary>
            BloodCastleGateDestroyed = 4,

        /// <summary>
        /// The chaos castle event has just started and is running.
        /// </summary>
            ChaosCastleStarted = 5,

        /// <summary>
        /// The chaos castle event is running.
        /// </summary>
            ChaosCastleRunning = 6,

        /// <summary>
        /// The chaos castle event has ended.
        /// </summary>
            ChaosCastleEnded = 7,

        /// <summary>
        /// The chaos castle event reached the first stage of map shrinking.
        /// </summary>
            ChaosCastleStageOne = 8,

        /// <summary>
        /// The chaos castle event reached the second stage of map shrinking.
        /// </summary>
            ChaosCastleStageTwo = 9,

        /// <summary>
        /// The chaos castle event reached the third stage of map shrinking.
        /// </summary>
            ChaosCastleStageThree = 10,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleState"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public BloodCastleState(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="BloodCastleState"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private BloodCastleState(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x9B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 13;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the state.
    /// </summary>
    public BloodCastleState.Status State
    {
        get => (Status)this._data.Span[3];
        set => this._data.Span[3] = (byte)value;
    }

    /// <summary>
    /// Gets or sets the remain second.
    /// </summary>
    public ushort RemainSecond
    {
        get => ReadUInt16LittleEndian(this._data.Span[4..]);
        set => WriteUInt16LittleEndian(this._data.Span[4..], value);
    }

    /// <summary>
    /// Gets or sets the max monster.
    /// </summary>
    public ushort MaxMonster
    {
        get => ReadUInt16LittleEndian(this._data.Span[6..]);
        set => WriteUInt16LittleEndian(this._data.Span[6..], value);
    }

    /// <summary>
    /// Gets or sets the cur monster.
    /// </summary>
    public ushort CurMonster
    {
        get => ReadUInt16LittleEndian(this._data.Span[8..]);
        set => WriteUInt16LittleEndian(this._data.Span[8..], value);
    }

    /// <summary>
    /// Gets or sets the item owner id.
    /// </summary>
    public ushort ItemOwnerId
    {
        get => ReadUInt16LittleEndian(this._data.Span[10..]);
        set => WriteUInt16LittleEndian(this._data.Span[10..], value);
    }

    /// <summary>
    /// Gets or sets the item level.
    /// </summary>
    public byte ItemLevel
    {
        get => this._data.Span[12];
        set => this._data.Span[12] = value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="BloodCastleState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator BloodCastleState(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="BloodCastleState"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(BloodCastleState packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The player requested to enter the chaos castle mini game by using the 'Armor of Guardsman' item.
/// Causes reaction on client side: In case it failed, it shows the corresponding error message.
/// </summary>
public readonly struct ChaosCastleEnterResult
{
    /// <summary>
    /// Defines the result of the enter request.
    /// </summary>
    public enum EnterResult
    {
        /// <summary>
        /// The event has been entered.
        /// </summary>
            Success = 0,

        /// <summary>
        /// Entering the event failed, e.g. by missing event ticket or level range.
        /// </summary>
            Failed = 1,

        /// <summary>
        /// Entering the event failed, because it's not opened.
        /// </summary>
            NotOpen = 2,

        /// <summary>
        /// Entering the event failed, because it's full.
        /// </summary>
            Full = 5,

        /// <summary>
        /// Entering the event failed, because the player doesn't have enough money for the entrance fee.
        /// </summary>
            NotEnoughMoney = 7,

        /// <summary>
        /// Entering the event failed, because the player has a pk state.
        /// </summary>
            PlayerKillerCantEnter = 8,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="ChaosCastleEnterResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public ChaosCastleEnterResult(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ChaosCastleEnterResult"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private ChaosCastleEnterResult(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
            header.SubCode = SubCode;
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0xAF;

    /// <summary>
    /// Gets the operation sub-code of this data packet.
    /// The <see cref="Code" /> is used as a grouping key.
    /// </summary>
    public static byte SubCode => 0x01;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1HeaderWithSubCode Header => new (this._data);

    /// <summary>
    /// Gets or sets the result.
    /// </summary>
    public ChaosCastleEnterResult.EnterResult Result
    {
        get => (EnterResult)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="ChaosCastleEnterResult"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator ChaosCastleEnterResult(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="ChaosCastleEnterResult"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(ChaosCastleEnterResult packet) => packet._data; 
}


/// <summary>
/// Is sent by the server when: The state of event is about to change.
/// Causes reaction on client side: The event's effect is shown.
/// </summary>
public readonly struct MapEventState
{
    /// <summary>
    /// Defines all events.
    /// </summary>
    public enum Events
    {
        /// <summary>
        /// Red dragon invasion.
        /// </summary>
            RedDragon = 1,

        /// <summary>
        /// Golden dragon invasion.
        /// </summary>
            GoldenDragon = 3,
    }

    private readonly Memory<byte> _data;

    /// <summary>
    /// Initializes a new instance of the <see cref="MapEventState"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    public MapEventState(Memory<byte> data)
        : this(data, true)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MapEventState"/> struct.
    /// </summary>
    /// <param name="data">The underlying data.</param>
    /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
    private MapEventState(Memory<byte> data, bool initialize)
    {
        this._data = data;
        if (initialize)
        {
            var header = this.Header;
            header.Type = HeaderType;
            header.Code = Code;
            header.Length = (byte)Math.Min(data.Length, Length);
        }
    }

    /// <summary>
    /// Gets the header type of this data packet.
    /// </summary>
    public static byte HeaderType => 0xC1;

    /// <summary>
    /// Gets the operation code of this data packet.
    /// </summary>
    public static byte Code => 0x0B;

    /// <summary>
    /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
    /// </summary>
    public static int Length => 5;

    /// <summary>
    /// Gets the header of this packet.
    /// </summary>
    public C1Header Header => new (this._data);

    /// <summary>
    /// Gets or sets the enable.
    /// </summary>
    public bool Enable
    {
        get => this._data.Span[3..].GetBoolean();
        set => this._data.Span[3..].SetBoolean(value);
    }

    /// <summary>
    /// Gets or sets the event.
    /// </summary>
    public MapEventState.Events Event
    {
        get => (Events)this._data.Span[4];
        set => this._data.Span[4] = (byte)value;
    }

    /// <summary>
    /// Performs an implicit conversion from a Memory of bytes to a <see cref="MapEventState"/>.
    /// </summary>
    /// <param name="packet">The packet as span.</param>
    /// <returns>The packet as struct.</returns>
    public static implicit operator MapEventState(Memory<byte> packet) => new (packet, false);

    /// <summary>
    /// Performs an implicit conversion from <see cref="MapEventState"/> to a Memory of bytes.
    /// </summary>
    /// <param name="packet">The packet as struct.</param>
    /// <returns>The packet as byte span.</returns>
    public static implicit operator Memory<byte>(MapEventState packet) => packet._data; 
}
    /// <summary>
    /// Defines the role of a guild member.
    /// </summary>
    public enum GuildMemberRole
    {
        /// <summary>
        /// The member is a normal member without special rights.
        /// </summary>
            NormalMember = 0,

        /// <summary>
        /// The member is a battle master.
        /// </summary>
            BattleMaster = 32,

        /// <summary>
        /// The member is the guild master.
        /// </summary>
            GuildMaster = 128,

        /// <summary>
        /// The character is not a member, therefore the role is undefined.
        /// </summary>
            Undefined = 255,
    }

    /// <summary>
    /// Describes the type of the guild war.
    /// </summary>
    public enum GuildWarType
    {
        /// <summary>
        /// A normal guild war.
        /// </summary>
            Normal = 0,

        /// <summary>
        /// A guild soccer match.
        /// </summary>
            Soccer = 1,
    }

    /// <summary>
    /// The status of a character.
    /// </summary>
    public enum CharacterStatus
    {
        /// <summary>
        /// The state of the character is normal.
        /// </summary>
            Normal = 0,

        /// <summary>
        /// The character is banned from the game.
        /// </summary>
            Banned = 1,

        /// <summary>
        /// The character is a game master.
        /// </summary>
            GameMaster = 32,
    }

    /// <summary>
    /// Defines the type of the condition.
    /// </summary>
    public enum ConditionType
    {
        /// <summary>
        /// No condition is defined.
        /// </summary>
            None = 0,

        /// <summary>
        /// The condition is to kill a specified amount of specified monsters.
        /// </summary>
            MonsterKills = 1,

        /// <summary>
        /// The condition is to learn a specified skill.
        /// </summary>
            Skill = 2,

        /// <summary>
        /// The condition is to find a specified item and to have it in the inventory.
        /// </summary>
            Item = 4,

        /// <summary>
        /// The condition is to reach the specified character level.
        /// </summary>
            Level = 8,

        /// <summary>
        /// The condition is a client action. For example, this may be the completion of a tutorial.
        /// </summary>
            ClientAction = 16,

        /// <summary>
        /// The condition is to request a buff from an NPC.
        /// </summary>
            RequestBuff = 32,

        /// <summary>
        /// The condition is to kill a specific amount of players in an event.
        /// </summary>
            EventMapPlayerKills = 64,

        /// <summary>
        /// The condition is to kill a specific amount of monsters in an event.
        /// </summary>
            EventMapMonsterKills = 65,

        /// <summary>
        /// The condition is to destroy the blood castle gate.
        /// </summary>
            BloodCastleGate = 66,

        /// <summary>
        /// The condition is to win the blood castle event.
        /// </summary>
            WinBloodCastle = 256,

        /// <summary>
        /// The condition is to win the chaos castle.
        /// </summary>
            WinChaosCastle = 257,

        /// <summary>
        /// The condition is to win the devil square event.
        /// </summary>
            WinDevilSquare = 258,

        /// <summary>
        /// The condition is to win the illusion temple event.
        /// </summary>
            WinIllusionTemple = 259,

        /// <summary>
        /// The condition is to reach a specific amount of points in the devil square event.
        /// </summary>
            DevilSquarePoints = 260,

        /// <summary>
        /// The condition is to give a specific amount of zen.
        /// </summary>
            Money = 261,

        /// <summary>
        /// The condition is to reach a specific amount of PVP points.
        /// </summary>
            PvpPoints = 262,

        /// <summary>
        /// The condition is to talk to a specific NPC.
        /// </summary>
            NpcTalk = 263,
    }

    /// <summary>
    /// Defines the type of the condition.
    /// </summary>
    public enum ConditionTypeExtended
    {
        /// <summary>
        /// No condition is defined.
        /// </summary>
            None = 0,

        /// <summary>
        /// The condition is to kill a specified amount of specified monsters.
        /// </summary>
            MonsterKills = 1,

        /// <summary>
        /// The condition is to learn a specified skill.
        /// </summary>
            Skill = 2,

        /// <summary>
        /// The condition is to find a specified item and to have it in the inventory.
        /// </summary>
            Item = 3,

        /// <summary>
        /// The condition is to reach the specified character level.
        /// </summary>
            Level = 4,

        /// <summary>
        /// The condition is a client action. For example, this may be the completion of a tutorial.
        /// </summary>
            ClientAction = 5,

        /// <summary>
        /// The condition is to request a buff from an NPC.
        /// </summary>
            RequestBuff = 6,

        /// <summary>
        /// The condition is to kill a specific amount of players in an event.
        /// </summary>
            EventMapPlayerKills = 7,

        /// <summary>
        /// The condition is to kill a specific amount of monsters in an event.
        /// </summary>
            EventMapMonsterKills = 8,

        /// <summary>
        /// The condition is to destroy the blood castle gate.
        /// </summary>
            BloodCastleGate = 9,

        /// <summary>
        /// The condition is to win the blood castle event.
        /// </summary>
            WinBloodCastle = 10,

        /// <summary>
        /// The condition is to win the chaos castle.
        /// </summary>
            WinChaosCastle = 11,

        /// <summary>
        /// The condition is to win the devil square event.
        /// </summary>
            WinDevilSquare = 12,

        /// <summary>
        /// The condition is to win the illusion temple event.
        /// </summary>
            WinIllusionTemple = 13,

        /// <summary>
        /// The condition is to reach a specific amount of points in the devil square event.
        /// </summary>
            DevilSquarePoints = 14,

        /// <summary>
        /// The condition is to give a specific amount of zen.
        /// </summary>
            Money = 15,

        /// <summary>
        /// The condition is to reach a specific amount of PVP points.
        /// </summary>
            PvpPoints = 16,

        /// <summary>
        /// The condition is to talk to a specific NPC.
        /// </summary>
            NpcTalk = 17,
    }

    /// <summary>
    /// Defines the reward which is given when the quest is completed.
    /// </summary>
    public enum RewardType
    {
        /// <summary>
        /// No reward is defined.
        /// </summary>
            None = 0,

        /// <summary>
        /// The reward is added experience to the character.
        /// </summary>
            Experience = 1,

        /// <summary>
        /// The reward is added money to the inventory.
        /// </summary>
            Money = 2,

        /// <summary>
        /// The reward is an item which is added to the inventory.
        /// </summary>
            Item = 4,

        /// <summary>
        /// The reward is added gens contribution points.
        /// </summary>
            GensContribution = 16,

        /// <summary>
        /// The reward is random?.
        /// </summary>
            Random = 32,
    }

    /// <summary>
    /// Defines the possible socket options.
    /// </summary>
    public enum SocketOption
    {
        /// <summary>
        /// Fire((Level type)Attack/Wizardry increase +20)
        /// </summary>
            FireAttackWizByLevelIncrease = 0,

        /// <summary>
        /// Fire(Attack speed increase +7)
        /// </summary>
            FireAttackSpeedIncrease = 1,

        /// <summary>
        /// Fire(Maximum attack/Wizardry increase +30)
        /// </summary>
            FireMaxDmgIncrease = 2,

        /// <summary>
        /// Fire(Minimum attack/Wizardry increase +20)
        /// </summary>
            FireMinDmgIncrease = 3,

        /// <summary>
        /// Fire(Attack/Wizardry increase +20)
        /// </summary>
            FireAttackWizIncrease = 4,

        /// <summary>
        /// Fire(AG cost decrease +40)
        /// </summary>
            FireAgCostDecrease = 5,

        /// <summary>
        /// Water(Block rating increase +10)
        /// </summary>
            WaterBlockRateIncrease = 10,

        /// <summary>
        /// Water(Defense increase +30)
        /// </summary>
            WaterDefenseIncrease = 11,

        /// <summary>
        /// Water(Shield protection increase +7)
        /// </summary>
            WaterShieldProtectionIncrease = 12,

        /// <summary>
        /// Water(Damage reduction +4)
        /// </summary>
            WaterDamageReduction4 = 13,

        /// <summary>
        /// Water(Damage reduction +5)
        /// </summary>
            WaterDamageReduction5 = 14,

        /// <summary>
        /// Ice(Monster destruction for the Life increase +8)
        /// </summary>
            IceLifeIncrease = 16,

        /// <summary>
        /// Ice(Monster destruction for the Mana increase +8)
        /// </summary>
            IceManaIncrease = 17,

        /// <summary>
        /// Ice(Skill attack increase +37)
        /// </summary>
            IceSkillAttackIncrease = 18,

        /// <summary>
        /// Ice(Attack rating increase +25)
        /// </summary>
            IceAttackRateIncrease = 19,

        /// <summary>
        /// Ice(Item durability increase +30)
        /// </summary>
            IceDurabilityIncrease = 20,

        /// <summary>
        /// Wind(Automatic Life recovery increase +8)
        /// </summary>
            WindAutoLifeRecoveryIncrease = 21,

        /// <summary>
        /// Wind(Maximum Life increase +4)
        /// </summary>
            WindMaxHealthIncrease = 22,

        /// <summary>
        /// Wind(Maximum Mana increase +4)
        /// </summary>
            WindMaxManaIncrease = 23,

        /// <summary>
        /// Wind(Automatic Mana recovery increase +7)
        /// </summary>
            WindAutoManaRecoverIncrease = 24,

        /// <summary>
        /// Wind(Maximum AG increase +25)
        /// </summary>
            WindMaxAgIncrease = 25,

        /// <summary>
        /// Wind(AG value increase +26)
        /// </summary>
            WindAutoAgRecoverIncrease = 26,

        /// <summary>
        /// Lightning(Excellent damage increase +15)
        /// </summary>
            LightningExcDmgIncrease = 29,

        /// <summary>
        /// Lightning(Excellent damage rate increase +10)
        /// </summary>
            LightningExcDmgRateIncrease = 30,

        /// <summary>
        /// Lightning(Critical damage increase +30)
        /// </summary>
            LightningCritDmgIncrease = 31,

        /// <summary>
        /// Lightning(Critical damage rate increase +8)
        /// </summary>
            LightningCritDmgRateIncrease = 32,

        /// <summary>
        /// Earth(Health increase +30)
        /// </summary>
            EarthHealhIncrease = 36,

        /// <summary>
        /// Empty Socket
        /// </summary>
            EmptySocket = 254,

        /// <summary>
        /// No Socket
        /// </summary>
            NoSocket = 255,
    }

    /// <summary>
    /// The flags to unlock the specified character classes for the creation of new characters.
    /// </summary>
    public enum CharacterCreationUnlockFlags
    {
        /// <summary>
        /// No unlocked class.
        /// </summary>
            None = 0,

        /// <summary>
        /// Unlocks the summoner class.
        /// </summary>
            Summoner = 1,

        /// <summary>
        /// Unlocks the dark lord class.
        /// </summary>
            DarkLord = 2,

        /// <summary>
        /// Unlocks the magic gladiator class.
        /// </summary>
            MagicGladiator = 4,

        /// <summary>
        /// Unlocks the rage fighter class.
        /// </summary>
            RageFighter = 8,
    }

    /// <summary>
    /// Defines the kind of the damage.
    /// </summary>
    public enum DamageKind
    {
        /// <summary>
        /// Red color, used by normal damage.
        /// </summary>
            NormalRed = 0,

        /// <summary>
        /// Cyan color, usually used by ignore defense damage.
        /// </summary>
            IgnoreDefenseCyan = 1,

        /// <summary>
        /// Light green color, usually used by excellent damage.
        /// </summary>
            ExcellentLightGreen = 2,

        /// <summary>
        /// Blue color, usually used by critical damage.
        /// </summary>
            CriticalBlue = 3,

        /// <summary>
        /// Light pink color.
        /// </summary>
            LightPink = 4,

        /// <summary>
        /// Dark green color, usually used by poison damage.
        /// </summary>
            PoisonDarkGreen = 5,

        /// <summary>
        /// Dark pink color, usually used by reflected damage.
        /// </summary>
            ReflectedDarkPink = 6,

        /// <summary>
        /// White color.
        /// </summary>
            White = 7,
    }

