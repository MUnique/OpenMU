// <copyright file="ConnectionExtensions.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable RedundantVerbatimPrefix
// ReSharper disable AssignmentIsFullyDiscarded
// ReSharper disable UnusedMember.Global
// ReSharper disable UseObjectOrCollectionInitializer

#nullable enable
namespace MUnique.OpenMU.Network.Packets.ServerToClient;

using System;
using System.Threading;
using MUnique.OpenMU.Network;

/// <summary>
/// Extension methods to start writing messages of this namespace on a <see cref="IConnection"/>.
/// </summary>
public static class ConnectionExtensions
{

    /// <summary>
    /// Sends a <see cref="GameServerEntered" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="versionString">The version string.</param>
    /// <param name="version">The version.</param>
    /// <param name="success">The success.</param>
    /// <remarks>
    /// Is sent by the server when: After a game client has connected to the game.
    /// Causes reaction on client side: It shows the login dialog.
    /// </remarks>
    public static async ValueTask SendGameServerEnteredAsync(this IConnection? connection, ushort @playerId, string @versionString, Memory<byte> @version, bool @success = true)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GameServerEnteredRef.Length;
            var packet = new GameServerEnteredRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;
            packet.PlayerId = @playerId;
            packet.VersionString = @versionString;
            @version.Span.CopyTo(packet.Version);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MagicEffectStatus" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="isActive">The is active.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="effectId">The effect id.</param>
    /// <remarks>
    /// Is sent by the server when: A magic effect was added or removed to the own or another player.
    /// Causes reaction on client side: The user interface updates itself. If it's the effect of the own player, it's shown as icon at the top of the interface.
    /// </remarks>
    public static async ValueTask SendMagicEffectStatusAsync(this IConnection? connection, bool @isActive, ushort @playerId, byte @effectId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MagicEffectStatusRef.Length;
            var packet = new MagicEffectStatusRef(connection.Output.GetSpan(length)[..length]);
            packet.IsActive = @isActive;
            packet.PlayerId = @playerId;
            packet.EffectId = @effectId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="WeatherStatusUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="weather">A random value between 0 and 2 (inclusive).</param>
    /// <param name="variation">A random value between 0 and 9 (inclusive).</param>
    /// <remarks>
    /// Is sent by the server when: The weather on the current map has been changed or the player entered the map.
    /// Causes reaction on client side: The game client updates the weather effects.
    /// </remarks>
    public static async ValueTask SendWeatherStatusUpdateAsync(this IConnection? connection, byte @weather, byte @variation)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = WeatherStatusUpdateRef.Length;
            var packet = new WeatherStatusUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.Weather = @weather;
            packet.Variation = @variation;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ObjectGotKilled" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="killedId">The killed id.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="killerId">The killer id.</param>
    /// <remarks>
    /// Is sent by the server when: An observed object was killed.
    /// Causes reaction on client side: The object is shown as dead.
    /// </remarks>
    public static async ValueTask SendObjectGotKilledAsync(this IConnection? connection, ushort @killedId, ushort @skillId, ushort @killerId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ObjectGotKilledRef.Length;
            var packet = new ObjectGotKilledRef(connection.Output.GetSpan(length)[..length]);
            packet.KilledId = @killedId;
            packet.SkillId = @skillId;
            packet.KillerId = @killerId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ObjectAnimation" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="objectId">The object id.</param>
    /// <param name="direction">The direction.</param>
    /// <param name="animation">The animation.</param>
    /// <param name="targetId">The target id.</param>
    /// <remarks>
    /// Is sent by the server when: An object performs an animation.
    /// Causes reaction on client side: The animation is shown for the specified object.
    /// </remarks>
    public static async ValueTask SendObjectAnimationAsync(this IConnection? connection, ushort @objectId, byte @direction, byte @animation, ushort @targetId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ObjectAnimationRef.Length;
            var packet = new ObjectAnimationRef(connection.Output.GetSpan(length)[..length]);
            packet.ObjectId = @objectId;
            packet.Direction = @direction;
            packet.Animation = @animation;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="AreaSkillAnimation" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="pointX">The point x.</param>
    /// <param name="pointY">The point y.</param>
    /// <param name="rotation">The rotation.</param>
    /// <remarks>
    /// Is sent by the server when: An object performs a skill which has effect on an area.
    /// Causes reaction on client side: The animation is shown on the user interface.
    /// </remarks>
    public static async ValueTask SendAreaSkillAnimationAsync(this IConnection? connection, ushort @skillId, ushort @playerId, byte @pointX, byte @pointY, byte @rotation)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = AreaSkillAnimationRef.Length;
            var packet = new AreaSkillAnimationRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.PlayerId = @playerId;
            packet.PointX = @pointX;
            packet.PointY = @pointY;
            packet.Rotation = @rotation;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SkillAnimation" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="targetId">The target id.</param>
    /// <remarks>
    /// Is sent by the server when: An object performs a skill which is directly targeted to another object.
    /// Causes reaction on client side: The animation is shown on the user interface.
    /// </remarks>
    public static async ValueTask SendSkillAnimationAsync(this IConnection? connection, ushort @skillId, ushort @playerId, ushort @targetId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SkillAnimationRef.Length;
            var packet = new SkillAnimationRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.PlayerId = @playerId;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="AreaSkillAnimation075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="pointX">The point x.</param>
    /// <param name="pointY">The point y.</param>
    /// <param name="rotation">The rotation.</param>
    /// <remarks>
    /// Is sent by the server when: An object performs a skill which has effect on an area.
    /// Causes reaction on client side: The animation is shown on the user interface.
    /// </remarks>
    public static async ValueTask SendAreaSkillAnimation075Async(this IConnection? connection, byte @skillId, ushort @playerId, byte @pointX, byte @pointY, byte @rotation)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = AreaSkillAnimation075Ref.Length;
            var packet = new AreaSkillAnimation075Ref(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.PlayerId = @playerId;
            packet.PointX = @pointX;
            packet.PointY = @pointY;
            packet.Rotation = @rotation;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="AreaSkillAnimation095" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="pointX">The point x.</param>
    /// <param name="pointY">The point y.</param>
    /// <param name="rotation">The rotation.</param>
    /// <remarks>
    /// Is sent by the server when: An object performs a skill which has effect on an area.
    /// Causes reaction on client side: The animation is shown on the user interface.
    /// </remarks>
    public static async ValueTask SendAreaSkillAnimation095Async(this IConnection? connection, byte @skillId, ushort @playerId, byte @pointX, byte @pointY, byte @rotation)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = AreaSkillAnimation095Ref.Length;
            var packet = new AreaSkillAnimation095Ref(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.PlayerId = @playerId;
            packet.PointX = @pointX;
            packet.PointY = @pointY;
            packet.Rotation = @rotation;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SkillAnimation075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="targetId">The target id.</param>
    /// <param name="effectApplied">The effect applied.</param>
    /// <remarks>
    /// Is sent by the server when: An object performs a skill which is directly targeted to another object.
    /// Causes reaction on client side: The animation is shown on the user interface.
    /// </remarks>
    public static async ValueTask SendSkillAnimation075Async(this IConnection? connection, byte @skillId, ushort @playerId, ushort @targetId, bool @effectApplied)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SkillAnimation075Ref.Length;
            var packet = new SkillAnimation075Ref(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.PlayerId = @playerId;
            packet.TargetId = @targetId;
            packet.EffectApplied = @effectApplied;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SkillAnimation095" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="targetId">The target id.</param>
    /// <param name="effectApplied">The effect applied.</param>
    /// <remarks>
    /// Is sent by the server when: An object performs a skill which is directly targeted to another object.
    /// Causes reaction on client side: The animation is shown on the user interface.
    /// </remarks>
    public static async ValueTask SendSkillAnimation095Async(this IConnection? connection, byte @skillId, ushort @playerId, ushort @targetId, bool @effectApplied)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SkillAnimation095Ref.Length;
            var packet = new SkillAnimation095Ref(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.PlayerId = @playerId;
            packet.TargetId = @targetId;
            packet.EffectApplied = @effectApplied;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MagicEffectCancelled" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="targetId">The target id.</param>
    /// <remarks>
    /// Is sent by the server when: A player cancelled a specific magic effect of a skill (Infinity Arrow, Wizardry Enhance), or an effect was removed due a timeout (Ice, Poison) or antidote.
    /// Causes reaction on client side: The effect is removed from the target object.
    /// </remarks>
    public static async ValueTask SendMagicEffectCancelledAsync(this IConnection? connection, ushort @skillId, ushort @targetId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MagicEffectCancelledRef.Length;
            var packet = new MagicEffectCancelledRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MagicEffectCancelled075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="targetId">The target id.</param>
    /// <remarks>
    /// Is sent by the server when: A player cancelled a specific magic effect of a skill (Infinity Arrow, Wizardry Enhance), or an effect was removed due a timeout (Ice, Poison) or antidote.
    /// Causes reaction on client side: The effect is removed from the target object.
    /// </remarks>
    public static async ValueTask SendMagicEffectCancelled075Async(this IConnection? connection, byte @skillId, ushort @targetId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MagicEffectCancelled075Ref.Length;
            var packet = new MagicEffectCancelled075Ref(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RageAttack" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillId">The skill id.</param>
    /// <param name="sourceId">The source id.</param>
    /// <param name="targetId">The target id.</param>
    /// <remarks>
    /// Is sent by the server when: A player (rage fighter) performs the dark side skill on a target and sent a RageAttackRangeRequest.
    /// Causes reaction on client side: The targets are attacked with visual effects.
    /// </remarks>
    public static async ValueTask SendRageAttackAsync(this IConnection? connection, ushort @skillId, ushort @sourceId, ushort @targetId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RageAttackRef.Length;
            var packet = new RageAttackRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillId = @skillId;
            packet.SourceId = @sourceId;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="AppearanceChanged" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="changedPlayerId">The changed player id.</param>
    /// <param name="itemData">The item data.</param>
    /// <remarks>
    /// Is sent by the server when: The appearance of a player changed, all surrounding players are informed about it.
    /// Causes reaction on client side: The appearance of the player is updated.
    /// </remarks>
    public static async ValueTask SendAppearanceChangedAsync(this IConnection? connection, ushort @changedPlayerId, Memory<byte> @itemData)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = AppearanceChangedRef.GetRequiredSize(itemData.Length);
            var packet = new AppearanceChangedRef(connection.Output.GetSpan(length)[..length]);
            packet.ChangedPlayerId = @changedPlayerId;
            @itemData.Span.CopyTo(packet.ItemData);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ObjectMessage" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="objectId">The object id.</param>
    /// <param name="message">The message.</param>
    /// <remarks>
    /// Is sent by the server when: The server wants to show a message above any kind of character, even NPCs.
    /// Causes reaction on client side: The message is shown above the character.
    /// </remarks>
    public static async ValueTask SendObjectMessageAsync(this IConnection? connection, ushort @objectId, string @message)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ObjectMessageRef.GetRequiredSize(message);
            var packet = new ObjectMessageRef(connection.Output.GetSpan(length)[..length]);
            packet.ObjectId = @objectId;
            packet.Message = @message;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PartyRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="requesterId">The requester id.</param>
    /// <remarks>
    /// Is sent by the server when: Another player requests party from the receiver of this message.
    /// Causes reaction on client side: The party request is shown.
    /// </remarks>
    public static async ValueTask SendPartyRequestAsync(this IConnection? connection, ushort @requesterId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PartyRequestRef.Length;
            var packet = new PartyRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.RequesterId = @requesterId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RemovePartyMember" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="index">The index.</param>
    /// <remarks>
    /// Is sent by the server when: A party member got removed from a party in which the player is in.
    /// Causes reaction on client side: The party member with the specified index is removed from the party list on the user interface.
    /// </remarks>
    public static async ValueTask SendRemovePartyMemberAsync(this IConnection? connection, byte @index)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RemovePartyMemberRef.Length;
            var packet = new RemovePartyMemberRef(connection.Output.GetSpan(length)[..length]);
            packet.Index = @index;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PlayerShopOpenSuccessful" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="success">The success.</param>
    /// <remarks>
    /// Is sent by the server when: After the player requested to open his shop and this request was successful.
    /// Causes reaction on client side: The own player shop is shown as open.
    /// </remarks>
    public static async ValueTask SendPlayerShopOpenSuccessfulAsync(this IConnection? connection, bool @success = true)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PlayerShopOpenSuccessfulRef.Length;
            var packet = new PlayerShopOpenSuccessfulRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TradeButtonStateChanged" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="state">The state.</param>
    /// <remarks>
    /// Is sent by the server when: After the trading partner checked or unchecked the trade accept button.
    /// Causes reaction on client side: The game client updates the trade button state accordingly.
    /// </remarks>
    public static async ValueTask SendTradeButtonStateChangedAsync(this IConnection? connection, TradeButtonStateChanged.TradeButtonState @state)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TradeButtonStateChangedRef.Length;
            var packet = new TradeButtonStateChangedRef(connection.Output.GetSpan(length)[..length]);
            packet.State = @state;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TradeMoneySetResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the server when: The trade money has been set by a previous request of the player.
    /// Causes reaction on client side: The money which was set into the trade by the player is updated on the UI.
    /// </remarks>
    public static async ValueTask SendTradeMoneySetResponseAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TradeMoneySetResponseRef.Length;
            var packet = new TradeMoneySetResponseRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TradeMoneyUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="moneyAmount">The money amount.</param>
    /// <remarks>
    /// Is sent by the server when: This message is sent when the trading partner put a certain amount of money (also 0) into the trade.
    /// Causes reaction on client side: It overrides all previous sent money values.
    /// </remarks>
    public static async ValueTask SendTradeMoneyUpdateAsync(this IConnection? connection, uint @moneyAmount)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TradeMoneyUpdateRef.Length;
            var packet = new TradeMoneyUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.MoneyAmount = @moneyAmount;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TradeRequestAnswer" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="accepted">The accepted.</param>
    /// <param name="name">The name.</param>
    /// <param name="tradePartnerLevel">The trade partner level.</param>
    /// <param name="guildId">The guild id.</param>
    /// <remarks>
    /// Is sent by the server when: The player which receives this message, sent a trade request to another player. This message is sent when the other player responded to this request.
    /// Causes reaction on client side: If the trade was accepted, a trade dialog is opened. Otherwise, a message is shown.
    /// </remarks>
    public static async ValueTask SendTradeRequestAnswerAsync(this IConnection? connection, bool @accepted, string @name, ushort @tradePartnerLevel, uint @guildId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TradeRequestAnswerRef.Length;
            var packet = new TradeRequestAnswerRef(connection.Output.GetSpan(length)[..length]);
            packet.Accepted = @accepted;
            packet.Name = @name;
            packet.TradePartnerLevel = @tradePartnerLevel;
            packet.GuildId = @guildId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TradeRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="name">The name.</param>
    /// <remarks>
    /// Is sent by the server when: A trade was requested by another player.
    /// Causes reaction on client side: A trade request dialog is shown.
    /// </remarks>
    public static async ValueTask SendTradeRequestAsync(this IConnection? connection, string @name)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TradeRequestRef.Length;
            var packet = new TradeRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.Name = @name;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TradeFinished" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <remarks>
    /// Is sent by the server when: A trade was finished.
    /// Causes reaction on client side: The trade dialog is closed. Depending on the result, a message is shown.
    /// </remarks>
    public static async ValueTask SendTradeFinishedAsync(this IConnection? connection, TradeFinished.TradeResult @result)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TradeFinishedRef.Length;
            var packet = new TradeFinishedRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TradeItemAdded" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="toSlot">The to slot.</param>
    /// <param name="itemData">The item data.</param>
    /// <remarks>
    /// Is sent by the server when: The trading partner added an item to the trade.
    /// Causes reaction on client side: The item is added in the trade dialog.
    /// </remarks>
    public static async ValueTask SendTradeItemAddedAsync(this IConnection? connection, byte @toSlot, Memory<byte> @itemData)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TradeItemAddedRef.GetRequiredSize(itemData.Length);
            var packet = new TradeItemAddedRef(connection.Output.GetSpan(length)[..length]);
            packet.ToSlot = @toSlot;
            @itemData.Span.CopyTo(packet.ItemData);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="TradeItemRemoved" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="slot">The slot.</param>
    /// <remarks>
    /// Is sent by the server when: The trading partner removed an item from the trade.
    /// Causes reaction on client side: The item is removed from the trade dialog.
    /// </remarks>
    public static async ValueTask SendTradeItemRemovedAsync(this IConnection? connection, byte @slot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = TradeItemRemovedRef.Length;
            var packet = new TradeItemRemovedRef(connection.Output.GetSpan(length)[..length]);
            packet.Slot = @slot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LoginResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="success">The success.</param>
    /// <remarks>
    /// Is sent by the server when: After the login request has been processed by the server.
    /// Causes reaction on client side: Shows the result. When it was successful, the client proceeds by sending a character list request.
    /// </remarks>
    public static async ValueTask SendLoginResponseAsync(this IConnection? connection, LoginResponse.LoginResult @success)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LoginResponseRef.Length;
            var packet = new LoginResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LogoutResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="type">The type.</param>
    /// <remarks>
    /// Is sent by the server when: After the logout request has been processed by the server.
    /// Causes reaction on client side: Depending on the result, the game client closes the game or changes to another selection screen.
    /// </remarks>
    public static async ValueTask SendLogoutResponseAsync(this IConnection? connection, LogOutType @type)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LogoutResponseRef.Length;
            var packet = new LogoutResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Type = @type;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ChatMessage" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="type">The type.</param>
    /// <param name="sender">The sender.</param>
    /// <param name="message">The message.</param>
    /// <remarks>
    /// Is sent by the server when: A player sends a chat message.
    /// Causes reaction on client side: The message is shown in the chat box and above the character of the sender.
    /// </remarks>
    public static async ValueTask SendChatMessageAsync(this IConnection? connection, ChatMessage.ChatMessageType @type, string @sender, string @message)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ChatMessageRef.GetRequiredSize(message);
            var packet = new ChatMessageRef(connection.Output.GetSpan(length)[..length]);
            packet.Type = @type;
            packet.Sender = @sender;
            packet.Message = @message;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ObjectHit" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="headerCode">The header code.</param>
    /// <param name="objectId">The object id.</param>
    /// <param name="healthDamage">The health damage.</param>
    /// <param name="kind">The kind.</param>
    /// <param name="isDoubleDamage">The is double damage.</param>
    /// <param name="isTripleDamage">The is triple damage.</param>
    /// <param name="shieldDamage">The shield damage.</param>
    /// <remarks>
    /// Is sent by the server when: An object got hit in two cases: 1. When the own player is hit; 2. When the own player attacked some other object which got hit.
    /// Causes reaction on client side: The damage is shown at the object which received the hit.
    /// </remarks>
    public static async ValueTask SendObjectHitAsync(this IConnection? connection, byte @headerCode, ushort @objectId, ushort @healthDamage, ObjectHit.DamageKind @kind, bool @isDoubleDamage, bool @isTripleDamage, ushort @shieldDamage)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ObjectHitRef.Length;
            var packet = new ObjectHitRef(connection.Output.GetSpan(length)[..length]);
            packet.HeaderCode = @headerCode;
            packet.ObjectId = @objectId;
            packet.HealthDamage = @healthDamage;
            packet.Kind = @kind;
            packet.IsDoubleDamage = @isDoubleDamage;
            packet.IsTripleDamage = @isTripleDamage;
            packet.ShieldDamage = @shieldDamage;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ObjectMoved" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="headerCode">The header code.</param>
    /// <param name="objectId">The object id.</param>
    /// <param name="positionX">The position x.</param>
    /// <param name="positionY">The position y.</param>
    /// <remarks>
    /// Is sent by the server when: An object in the observed scope (including the own player) moved instantly.
    /// Causes reaction on client side: The position of the object is updated on client side.
    /// </remarks>
    public static async ValueTask SendObjectMovedAsync(this IConnection? connection, byte @headerCode, ushort @objectId, byte @positionX, byte @positionY)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ObjectMovedRef.Length;
            var packet = new ObjectMovedRef(connection.Output.GetSpan(length)[..length]);
            packet.HeaderCode = @headerCode;
            packet.ObjectId = @objectId;
            packet.PositionX = @positionX;
            packet.PositionY = @positionY;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ObjectWalked" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="headerCode">The header code.</param>
    /// <param name="objectId">The object id.</param>
    /// <param name="targetX">The target x.</param>
    /// <param name="targetY">The target y.</param>
    /// <param name="targetRotation">The target rotation.</param>
    /// <param name="stepCount">The step count.</param>
    /// <param name="stepData">The step data.</param>
    /// <remarks>
    /// Is sent by the server when: An object in the observed scope (including the own player) walked to another position.
    /// Causes reaction on client side: The object is animated to walk to the new position.
    /// </remarks>
    public static async ValueTask SendObjectWalkedAsync(this IConnection? connection, byte @headerCode, ushort @objectId, byte @targetX, byte @targetY, byte @targetRotation, byte @stepCount, Memory<byte> @stepData)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ObjectWalkedRef.GetRequiredSize(stepData.Length);
            var packet = new ObjectWalkedRef(connection.Output.GetSpan(length)[..length]);
            packet.HeaderCode = @headerCode;
            packet.ObjectId = @objectId;
            packet.TargetX = @targetX;
            packet.TargetY = @targetY;
            packet.TargetRotation = @targetRotation;
            packet.StepCount = @stepCount;
            @stepData.Span.CopyTo(packet.StepData);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ObjectWalked075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="objectId">The object id.</param>
    /// <param name="targetX">The target x.</param>
    /// <param name="targetY">The target y.</param>
    /// <param name="targetRotation">The target rotation.</param>
    /// <remarks>
    /// Is sent by the server when: An object in the observed scope (including the own player) walked to another position.
    /// Causes reaction on client side: The object is animated to walk to the new position.
    /// </remarks>
    public static async ValueTask SendObjectWalked075Async(this IConnection? connection, ushort @objectId, byte @targetX, byte @targetY, byte @targetRotation)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ObjectWalked075Ref.Length;
            var packet = new ObjectWalked075Ref(connection.Output.GetSpan(length)[..length]);
            packet.ObjectId = @objectId;
            packet.TargetX = @targetX;
            packet.TargetY = @targetY;
            packet.TargetRotation = @targetRotation;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ExperienceGained" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="killedObjectId">The killed object id.</param>
    /// <param name="addedExperience">The added experience.</param>
    /// <param name="damageOfLastHit">The damage of last hit.</param>
    /// <remarks>
    /// Is sent by the server when: A player gained experience.
    /// Causes reaction on client side: The experience is added to the experience counter and bar.
    /// </remarks>
    public static async ValueTask SendExperienceGainedAsync(this IConnection? connection, ushort @killedObjectId, ushort @addedExperience, ushort @damageOfLastHit)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ExperienceGainedRef.Length;
            var packet = new ExperienceGainedRef(connection.Output.GetSpan(length)[..length]);
            packet.KilledObjectId = @killedObjectId;
            packet.AddedExperience = @addedExperience;
            packet.DamageOfLastHit = @damageOfLastHit;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MapChanged" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="mapNumber">The map number.</param>
    /// <param name="positionX">The position x.</param>
    /// <param name="positionY">The position y.</param>
    /// <param name="rotation">The rotation.</param>
    /// <param name="isMapChange">If false, it shows the teleport animation (white bubbles), and the client doesn't remove all of the objects in its scope.</param>
    /// <remarks>
    /// Is sent by the server when: The map was changed on the server side.
    /// Causes reaction on client side: The game client changes to the specified map and coordinates.
    /// </remarks>
    public static async ValueTask SendMapChangedAsync(this IConnection? connection, ushort @mapNumber, byte @positionX, byte @positionY, byte @rotation, bool @isMapChange = true)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MapChangedRef.Length;
            var packet = new MapChangedRef(connection.Output.GetSpan(length)[..length]);
            packet.IsMapChange = @isMapChange;
            packet.MapNumber = @mapNumber;
            packet.PositionX = @positionX;
            packet.PositionY = @positionY;
            packet.Rotation = @rotation;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MapChanged075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="mapNumber">The map number.</param>
    /// <param name="positionX">The position x.</param>
    /// <param name="positionY">The position y.</param>
    /// <param name="rotation">The rotation.</param>
    /// <param name="isMapChange">If false, it shows the teleport animation (white bubbles), and the client doesn't remove all of the objects in its scope.</param>
    /// <remarks>
    /// Is sent by the server when: The map was changed on the server side.
    /// Causes reaction on client side: The game client changes to the specified map and coordinates.
    /// </remarks>
    public static async ValueTask SendMapChanged075Async(this IConnection? connection, byte @mapNumber, byte @positionX, byte @positionY, byte @rotation, bool @isMapChange = true)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MapChanged075Ref.Length;
            var packet = new MapChanged075Ref(connection.Output.GetSpan(length)[..length]);
            packet.IsMapChange = @isMapChange;
            packet.MapNumber = @mapNumber;
            packet.PositionX = @positionX;
            packet.PositionY = @positionY;
            packet.Rotation = @rotation;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ApplyKeyConfiguration" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="configuration">The binary data of the key configuration</param>
    /// <remarks>
    /// Is sent by the server when: When entering the game world with a character.
    /// Causes reaction on client side: The client restores this configuration in its user interface.
    /// </remarks>
    public static async ValueTask SendApplyKeyConfigurationAsync(this IConnection? connection, Memory<byte> @configuration)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ApplyKeyConfigurationRef.GetRequiredSize(configuration.Length);
            var packet = new ApplyKeyConfigurationRef(connection.Output.GetSpan(length)[..length]);
            @configuration.Span.CopyTo(packet.Configuration);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MoneyDropped" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="id">The id.</param>
    /// <param name="isFreshDrop">If this flag is set, the money is added to the map with an animation and sound. Otherwise it's just added like it was already on the ground before.</param>
    /// <param name="positionX">The position x.</param>
    /// <param name="positionY">The position y.</param>
    /// <param name="amount">The amount.</param>
    /// <param name="itemCount">The item count.</param>
    /// <param name="moneyGroup">The money group.</param>
    /// <param name="moneyNumber">The money number.</param>
    /// <remarks>
    /// Is sent by the server when: Money dropped on the ground.
    /// Causes reaction on client side: The client adds the money to the ground.
    /// </remarks>
    public static async ValueTask SendMoneyDroppedAsync(this IConnection? connection, ushort @id, bool @isFreshDrop, byte @positionX, byte @positionY, uint @amount, byte @itemCount = 1, byte @moneyGroup = 14, byte @moneyNumber = 15)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MoneyDroppedRef.Length;
            var packet = new MoneyDroppedRef(connection.Output.GetSpan(length)[..length]);
            packet.ItemCount = @itemCount;
            packet.Id = @id;
            packet.IsFreshDrop = @isFreshDrop;
            packet.PositionX = @positionX;
            packet.PositionY = @positionY;
            packet.MoneyNumber = @moneyNumber;
            packet.Amount = @amount;
            packet.MoneyGroup = @moneyGroup;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MoneyDropped075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="id">The id.</param>
    /// <param name="isFreshDrop">If this flag is set, the money is added to the map with an animation and sound. Otherwise it's just added like it was already on the ground before.</param>
    /// <param name="positionX">The position x.</param>
    /// <param name="positionY">The position y.</param>
    /// <param name="amount">The amount.</param>
    /// <param name="itemCount">The item count.</param>
    /// <param name="moneyGroup">The money group.</param>
    /// <param name="moneyNumber">The money number.</param>
    /// <remarks>
    /// Is sent by the server when: Money dropped on the ground.
    /// Causes reaction on client side: The client adds the money to the ground.
    /// </remarks>
    public static async ValueTask SendMoneyDropped075Async(this IConnection? connection, ushort @id, bool @isFreshDrop, byte @positionX, byte @positionY, uint @amount, byte @itemCount = 1, byte @moneyGroup = 14, byte @moneyNumber = 15)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MoneyDropped075Ref.Length;
            var packet = new MoneyDropped075Ref(connection.Output.GetSpan(length)[..length]);
            packet.ItemCount = @itemCount;
            packet.Id = @id;
            packet.IsFreshDrop = @isFreshDrop;
            packet.PositionX = @positionX;
            packet.PositionY = @positionY;
            packet.MoneyNumber = @moneyNumber;
            packet.MoneyGroup = @moneyGroup;
            packet.Amount = @amount;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ItemAddedToInventory" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="inventorySlot">The inventory slot.</param>
    /// <param name="itemData">The item data.</param>
    /// <remarks>
    /// Is sent by the server when: A new item was added to the inventory.
    /// Causes reaction on client side: The client adds the item to the inventory user interface.
    /// </remarks>
    public static async ValueTask SendItemAddedToInventoryAsync(this IConnection? connection, byte @inventorySlot, Memory<byte> @itemData)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ItemAddedToInventoryRef.GetRequiredSize(itemData.Length);
            var packet = new ItemAddedToInventoryRef(connection.Output.GetSpan(length)[..length]);
            packet.InventorySlot = @inventorySlot;
            @itemData.Span.CopyTo(packet.ItemData);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ItemDropResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="success">The success.</param>
    /// <param name="inventorySlot">The inventory slot.</param>
    /// <remarks>
    /// Is sent by the server when: The player requested to drop an item of his inventory. This message is the response about the success of the request.
    /// Causes reaction on client side: If successful, the client removes the item from the inventory user interface.
    /// </remarks>
    public static async ValueTask SendItemDropResponseAsync(this IConnection? connection, bool @success, byte @inventorySlot)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ItemDropResponseRef.Length;
            var packet = new ItemDropResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;
            packet.InventorySlot = @inventorySlot;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ItemPickUpRequestFailed" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="failReason">The fail reason.</param>
    /// <remarks>
    /// Is sent by the server when: The player requested to pick up an item from to ground to add it to his inventory, but it failed.
    /// Causes reaction on client side: Depending on the reason, the game client shows a message.
    /// </remarks>
    public static async ValueTask SendItemPickUpRequestFailedAsync(this IConnection? connection, ItemPickUpRequestFailed.ItemPickUpFailReason @failReason)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ItemPickUpRequestFailedRef.Length;
            var packet = new ItemPickUpRequestFailedRef(connection.Output.GetSpan(length)[..length]);
            packet.FailReason = @failReason;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="InventoryMoneyUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="money">The money.</param>
    /// <remarks>
    /// Is sent by the server when: The players money amount of the inventory has been changed and needs an update.
    /// Causes reaction on client side: The money is updated in the inventory user interface.
    /// </remarks>
    public static async ValueTask SendInventoryMoneyUpdateAsync(this IConnection? connection, uint @money)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = InventoryMoneyUpdateRef.Length;
            var packet = new InventoryMoneyUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.Money = @money;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ItemMoved" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="targetStorageType">The target storage type.</param>
    /// <param name="targetSlot">The target slot.</param>
    /// <param name="itemData">The item data.</param>
    /// <remarks>
    /// Is sent by the server when: An item in the inventory or vault of the player has been moved.
    /// Causes reaction on client side: The client updates the position of item in the user interface.
    /// </remarks>
    public static async ValueTask SendItemMovedAsync(this IConnection? connection, ItemStorageKind @targetStorageType, byte @targetSlot, Memory<byte> @itemData)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ItemMovedRef.GetRequiredSize(itemData.Length);
            var packet = new ItemMovedRef(connection.Output.GetSpan(length)[..length]);
            packet.TargetStorageType = @targetStorageType;
            packet.TargetSlot = @targetSlot;
            @itemData.Span.CopyTo(packet.ItemData);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ItemMoveRequestFailed" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="itemData">The item data.</param>
    /// <remarks>
    /// Is sent by the server when: An item in the inventory or vault of the player could not be moved as requested by the player.
    /// Causes reaction on client side: The client restores the position of item in the user interface.
    /// </remarks>
    public static async ValueTask SendItemMoveRequestFailedAsync(this IConnection? connection, Memory<byte> @itemData)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ItemMoveRequestFailedRef.GetRequiredSize(itemData.Length);
            var packet = new ItemMoveRequestFailedRef(connection.Output.GetSpan(length)[..length]);
            @itemData.Span.CopyTo(packet.ItemData);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CurrentHealthAndShield" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="health">The health.</param>
    /// <param name="shield">The shield.</param>
    /// <remarks>
    /// Is sent by the server when: Periodically, or if the current health or shield changed on the server side, e.g. by hits.
    /// Causes reaction on client side: The health and shield bar is updated on the game client user interface.
    /// </remarks>
    public static async ValueTask SendCurrentHealthAndShieldAsync(this IConnection? connection, ushort @health, ushort @shield)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CurrentHealthAndShieldRef.Length;
            var packet = new CurrentHealthAndShieldRef(connection.Output.GetSpan(length)[..length]);
            packet.Health = @health;
            packet.Shield = @shield;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MaximumHealthAndShield" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="health">The health.</param>
    /// <param name="shield">The shield.</param>
    /// <remarks>
    /// Is sent by the server when: When the maximum health changed, e.g. by adding stat points or changed items.
    /// Causes reaction on client side: The health and shield bar is updated on the game client user interface.
    /// </remarks>
    public static async ValueTask SendMaximumHealthAndShieldAsync(this IConnection? connection, ushort @health, ushort @shield)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MaximumHealthAndShieldRef.Length;
            var packet = new MaximumHealthAndShieldRef(connection.Output.GetSpan(length)[..length]);
            packet.Health = @health;
            packet.Shield = @shield;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ItemConsumptionFailed" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="health">The health.</param>
    /// <param name="shield">The shield.</param>
    /// <remarks>
    /// Is sent by the server when: When the consumption of an item failed.
    /// Causes reaction on client side: The game client gets a feedback about a failed consumption, and allows for do further consumption requests.
    /// </remarks>
    public static async ValueTask SendItemConsumptionFailedAsync(this IConnection? connection, ushort @health, ushort @shield)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ItemConsumptionFailedRef.Length;
            var packet = new ItemConsumptionFailedRef(connection.Output.GetSpan(length)[..length]);
            packet.Health = @health;
            packet.Shield = @shield;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CurrentManaAndAbility" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="mana">The mana.</param>
    /// <param name="ability">The ability.</param>
    /// <remarks>
    /// Is sent by the server when: The currently available mana or ability has changed, e.g. by using a skill.
    /// Causes reaction on client side: The mana and ability bar is updated on the game client user interface.
    /// </remarks>
    public static async ValueTask SendCurrentManaAndAbilityAsync(this IConnection? connection, ushort @mana, ushort @ability)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CurrentManaAndAbilityRef.Length;
            var packet = new CurrentManaAndAbilityRef(connection.Output.GetSpan(length)[..length]);
            packet.Mana = @mana;
            packet.Ability = @ability;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MaximumManaAndAbility" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="mana">The mana.</param>
    /// <param name="ability">The ability.</param>
    /// <remarks>
    /// Is sent by the server when: The maximum available mana or ability has changed, e.g. by adding stat points.
    /// Causes reaction on client side: The mana and ability bar is updated on the game client user interface.
    /// </remarks>
    public static async ValueTask SendMaximumManaAndAbilityAsync(this IConnection? connection, ushort @mana, ushort @ability)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MaximumManaAndAbilityRef.Length;
            var packet = new MaximumManaAndAbilityRef(connection.Output.GetSpan(length)[..length]);
            packet.Mana = @mana;
            packet.Ability = @ability;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ItemRemoved" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="inventorySlot">The affected slot of the item in the inventory.</param>
    /// <param name="trueFlag">The true flag.</param>
    /// <remarks>
    /// Is sent by the server when: The item has been removed from the inventory of the player.
    /// Causes reaction on client side: The client removes the item in the inventory user interface.
    /// </remarks>
    public static async ValueTask SendItemRemovedAsync(this IConnection? connection, byte @inventorySlot, byte @trueFlag = 1)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ItemRemovedRef.Length;
            var packet = new ItemRemovedRef(connection.Output.GetSpan(length)[..length]);
            packet.InventorySlot = @inventorySlot;
            packet.TrueFlag = @trueFlag;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ConsumeItemWithEffect" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="itemType">The item type.</param>
    /// <param name="effectTimeInSeconds">The effect time in seconds.</param>
    /// <remarks>
    /// Is sent by the server when: The client requested to consume a special item, e.g. a bottle of Ale.
    /// Causes reaction on client side: The player is shown in a red color and has increased attack speed.
    /// </remarks>
    public static async ValueTask SendConsumeItemWithEffectAsync(this IConnection? connection, ConsumeItemWithEffect.ConsumedItemType @itemType, ushort @effectTimeInSeconds)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ConsumeItemWithEffectRef.Length;
            var packet = new ConsumeItemWithEffectRef(connection.Output.GetSpan(length)[..length]);
            packet.ItemType = @itemType;
            packet.EffectTimeInSeconds = @effectTimeInSeconds;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ItemDurabilityChanged" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="inventorySlot">The inventory slot.</param>
    /// <param name="durability">The durability.</param>
    /// <param name="byConsumption">true, if the change resulted from an item consumption; otherwise, false</param>
    /// <remarks>
    /// Is sent by the server when: The durability of an item in the inventory of the player has been changed.
    /// Causes reaction on client side: The client updates the item in the inventory user interface.
    /// </remarks>
    public static async ValueTask SendItemDurabilityChangedAsync(this IConnection? connection, byte @inventorySlot, byte @durability, bool @byConsumption)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ItemDurabilityChangedRef.Length;
            var packet = new ItemDurabilityChangedRef(connection.Output.GetSpan(length)[..length]);
            packet.InventorySlot = @inventorySlot;
            packet.Durability = @durability;
            packet.ByConsumption = @byConsumption;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="FruitConsumptionResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <param name="statPoints">The stat points.</param>
    /// <param name="statType">The stat type.</param>
    /// <remarks>
    /// Is sent by the server when: The player requested to consume a fruit.
    /// Causes reaction on client side: The client updates the user interface, by changing the added stat points and used fruit points.
    /// </remarks>
    public static async ValueTask SendFruitConsumptionResponseAsync(this IConnection? connection, FruitConsumptionResponse.FruitConsumptionResult @result, ushort @statPoints, FruitConsumptionResponse.FruitStatType @statType)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = FruitConsumptionResponseRef.Length;
            var packet = new FruitConsumptionResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;
            packet.StatPoints = @statPoints;
            packet.StatType = @statType;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="EffectItemConsumption" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="origin">The origin.</param>
    /// <param name="type">The type.</param>
    /// <param name="action">The action.</param>
    /// <param name="remainingSeconds">The remaining seconds.</param>
    /// <param name="magicEffectNumber">The magic effect number.</param>
    /// <remarks>
    /// Is sent by the server when: The player requested to consume an item which gives a magic effect.
    /// Causes reaction on client side: The client updates the user interface, it shows the remaining time at the effect icon.
    /// </remarks>
    public static async ValueTask SendEffectItemConsumptionAsync(this IConnection? connection, EffectItemConsumption.EffectOrigin @origin, EffectItemConsumption.EffectType @type, EffectItemConsumption.EffectAction @action, uint @remainingSeconds, byte @magicEffectNumber)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = EffectItemConsumptionRef.Length;
            var packet = new EffectItemConsumptionRef(connection.Output.GetSpan(length)[..length]);
            packet.Origin = @origin;
            packet.Type = @type;
            packet.Action = @action;
            packet.RemainingSeconds = @remainingSeconds;
            packet.MagicEffectNumber = @magicEffectNumber;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="NpcWindowResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="window">The window.</param>
    /// <remarks>
    /// Is sent by the server when: After the client talked to an NPC which should cause a dialog to open on the client side.
    /// Causes reaction on client side: The client opens the specified dialog.
    /// </remarks>
    public static async ValueTask SendNpcWindowResponseAsync(this IConnection? connection, NpcWindowResponse.NpcWindow @window)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = NpcWindowResponseRef.Length;
            var packet = new NpcWindowResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Window = @window;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="NpcItemBuyFailed" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the server when: The request of buying an item from a NPC failed.
    /// Causes reaction on client side: The client is responsive again. Without this message, it may stuck.
    /// </remarks>
    public static async ValueTask SendNpcItemBuyFailedAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = NpcItemBuyFailedRef.Length;
            var packet = new NpcItemBuyFailedRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ItemBought" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="inventorySlot">The inventory slot.</param>
    /// <param name="itemData">The item data.</param>
    /// <remarks>
    /// Is sent by the server when: The request of buying an item from a player or npc was successful.
    /// Causes reaction on client side: The bought item is added to the inventory.
    /// </remarks>
    public static async ValueTask SendItemBoughtAsync(this IConnection? connection, byte @inventorySlot, Memory<byte> @itemData)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ItemBoughtRef.GetRequiredSize(itemData.Length);
            var packet = new ItemBoughtRef(connection.Output.GetSpan(length)[..length]);
            packet.InventorySlot = @inventorySlot;
            @itemData.Span.CopyTo(packet.ItemData);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="NpcItemSellResult" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="success">The success.</param>
    /// <param name="money">The money.</param>
    /// <remarks>
    /// Is sent by the server when: The result of a previous item sell request.
    /// Causes reaction on client side: The amount of specified money is set at the players inventory.
    /// </remarks>
    public static async ValueTask SendNpcItemSellResultAsync(this IConnection? connection, bool @success, uint @money)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = NpcItemSellResultRef.Length;
            var packet = new NpcItemSellResultRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;
            packet.Money = @money;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PlayerShopSetItemPriceResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="inventorySlot">The inventory slot.</param>
    /// <param name="result">The result.</param>
    /// <remarks>
    /// Is sent by the server when: The player requested to set a price for an item of the players shop.
    /// Causes reaction on client side: The item gets a price on the user interface.
    /// </remarks>
    public static async ValueTask SendPlayerShopSetItemPriceResponseAsync(this IConnection? connection, byte @inventorySlot, PlayerShopSetItemPriceResponse.ItemPriceSetResult @result)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PlayerShopSetItemPriceResponseRef.Length;
            var packet = new PlayerShopSetItemPriceResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.InventorySlot = @inventorySlot;
            packet.Result = @result;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PlayerShopClosed" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="success">The success.</param>
    /// <remarks>
    /// Is sent by the server when: After a player in scope requested to close his shop or after all items has been sold.
    /// Causes reaction on client side: The player shop not shown as open anymore.
    /// </remarks>
    public static async ValueTask SendPlayerShopClosedAsync(this IConnection? connection, ushort @playerId, bool @success = true)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PlayerShopClosedRef.Length;
            var packet = new PlayerShopClosedRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;
            packet.PlayerId = @playerId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PlayerShopItemSoldToPlayer" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="inventorySlot">The inventory slot.</param>
    /// <param name="buyerName">The buyer name.</param>
    /// <remarks>
    /// Is sent by the server when: An item of the players shop was sold to another player.
    /// Causes reaction on client side: The item is removed from the players inventory and a blue system message appears.
    /// </remarks>
    public static async ValueTask SendPlayerShopItemSoldToPlayerAsync(this IConnection? connection, byte @inventorySlot, string @buyerName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PlayerShopItemSoldToPlayerRef.Length;
            var packet = new PlayerShopItemSoldToPlayerRef(connection.Output.GetSpan(length)[..length]);
            packet.InventorySlot = @inventorySlot;
            packet.BuyerName = @buyerName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ClosePlayerShopDialog" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerId">The player id.</param>
    /// <remarks>
    /// Is sent by the server when: After the player requested to close his shop or after all items has been sold.
    /// Causes reaction on client side: The player shop dialog is closed for the shop of the specified player.
    /// </remarks>
    public static async ValueTask SendClosePlayerShopDialogAsync(this IConnection? connection, ushort @playerId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ClosePlayerShopDialogRef.Length;
            var packet = new ClosePlayerShopDialogRef(connection.Output.GetSpan(length)[..length]);
            packet.PlayerId = @playerId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ShowEffect" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="effect">The effect.</param>
    /// <remarks>
    /// Is sent by the server when: After a player achieved or lost something.
    /// Causes reaction on client side: An effect is shown for the affected player.
    /// </remarks>
    public static async ValueTask SendShowEffectAsync(this IConnection? connection, ushort @playerId, ShowEffect.EffectType @effect)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ShowEffectRef.Length;
            var packet = new ShowEffectRef(connection.Output.GetSpan(length)[..length]);
            packet.PlayerId = @playerId;
            packet.Effect = @effect;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CharacterClassCreationUnlock" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="unlockFlags">The unlock flags.</param>
    /// <remarks>
    /// Is sent by the server when: It's send right after the CharacterList, in the character selection screen, if the account has any unlocked character classes.
    /// Causes reaction on client side: The client unlocks the specified character classes, so they can be created.
    /// </remarks>
    public static async ValueTask SendCharacterClassCreationUnlockAsync(this IConnection? connection, CharacterCreationUnlockFlags @unlockFlags)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CharacterClassCreationUnlockRef.Length;
            var packet = new CharacterClassCreationUnlockRef(connection.Output.GetSpan(length)[..length]);
            packet.UnlockFlags = @unlockFlags;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CharacterCreationSuccessful" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="characterName">The character name.</param>
    /// <param name="characterSlot">The character slot.</param>
    /// <param name="level">The level.</param>
    /// <param name="class">The class.</param>
    /// <param name="characterStatus">The character status.</param>
    /// <param name="previewData">The preview data.</param>
    /// <param name="success">The success.</param>
    /// <remarks>
    /// Is sent by the server when: After the server successfully processed a character creation request.
    /// Causes reaction on client side: The new character is shown in the character list
    /// </remarks>
    public static async ValueTask SendCharacterCreationSuccessfulAsync(this IConnection? connection, string @characterName, byte @characterSlot, ushort @level, CharacterClassNumber @class, byte @characterStatus, Memory<byte> @previewData, bool @success = true)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CharacterCreationSuccessfulRef.Length;
            var packet = new CharacterCreationSuccessfulRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;
            packet.CharacterName = @characterName;
            packet.CharacterSlot = @characterSlot;
            packet.Level = @level;
            packet.Class = @class;
            packet.CharacterStatus = @characterStatus;
            @previewData.Span.CopyTo(packet.PreviewData);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CharacterCreationFailed" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the server when: After the server processed a character creation request without success.
    /// Causes reaction on client side: A message is shown that it failed. 
    /// </remarks>
    public static async ValueTask SendCharacterCreationFailedAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CharacterCreationFailedRef.Length;
            var packet = new CharacterCreationFailedRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RespawnAfterDeath075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="positionX">The position x.</param>
    /// <param name="positionY">The position y.</param>
    /// <param name="mapNumber">The map number.</param>
    /// <param name="direction">The direction.</param>
    /// <param name="currentHealth">The current health.</param>
    /// <param name="currentMana">The current mana.</param>
    /// <param name="experience">The experience.</param>
    /// <param name="money">The money.</param>
    /// <remarks>
    /// Is sent by the server when: The character respawned after death.
    /// Causes reaction on client side: The character respawns with the specified attributes at the specified map.
    /// </remarks>
    public static async ValueTask SendRespawnAfterDeath075Async(this IConnection? connection, byte @positionX, byte @positionY, byte @mapNumber, byte @direction, ushort @currentHealth, ushort @currentMana, uint @experience, uint @money)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RespawnAfterDeath075Ref.Length;
            var packet = new RespawnAfterDeath075Ref(connection.Output.GetSpan(length)[..length]);
            packet.PositionX = @positionX;
            packet.PositionY = @positionY;
            packet.MapNumber = @mapNumber;
            packet.Direction = @direction;
            packet.CurrentHealth = @currentHealth;
            packet.CurrentMana = @currentMana;
            packet.Experience = @experience;
            packet.Money = @money;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RespawnAfterDeath095" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="positionX">The position x.</param>
    /// <param name="positionY">The position y.</param>
    /// <param name="mapNumber">The map number.</param>
    /// <param name="direction">The direction.</param>
    /// <param name="currentHealth">The current health.</param>
    /// <param name="currentMana">The current mana.</param>
    /// <param name="currentAbility">The current ability.</param>
    /// <param name="experience">The experience.</param>
    /// <param name="money">The money.</param>
    /// <remarks>
    /// Is sent by the server when: The character respawned after death.
    /// Causes reaction on client side: The character respawns with the specified attributes at the specified map.
    /// </remarks>
    public static async ValueTask SendRespawnAfterDeath095Async(this IConnection? connection, byte @positionX, byte @positionY, byte @mapNumber, byte @direction, ushort @currentHealth, ushort @currentMana, ushort @currentAbility, uint @experience, uint @money)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RespawnAfterDeath095Ref.Length;
            var packet = new RespawnAfterDeath095Ref(connection.Output.GetSpan(length)[..length]);
            packet.PositionX = @positionX;
            packet.PositionY = @positionY;
            packet.MapNumber = @mapNumber;
            packet.Direction = @direction;
            packet.CurrentHealth = @currentHealth;
            packet.CurrentMana = @currentMana;
            packet.CurrentAbility = @currentAbility;
            packet.Experience = @experience;
            packet.Money = @money;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PoisonDamage" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="healthDamage">The health damage.</param>
    /// <param name="currentShield">The current shield.</param>
    /// <remarks>
    /// Is sent by the server when: The character got damaged by being poisoned on old client versions.
    /// Causes reaction on client side: Removes the damage from the health without showing a damage number.
    /// </remarks>
    public static async ValueTask SendPoisonDamageAsync(this IConnection? connection, ushort @healthDamage, ushort @currentShield)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PoisonDamageRef.Length;
            var packet = new PoisonDamageRef(connection.Output.GetSpan(length)[..length]);
            packet.HealthDamage = @healthDamage;
            packet.CurrentShield = @currentShield;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="HeroStateChanged" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="newState">The new state.</param>
    /// <remarks>
    /// Is sent by the server when: After a the hero state of an observed character changed.
    /// Causes reaction on client side: The color of the name of the character is changed accordingly and a message is shown.
    /// </remarks>
    public static async ValueTask SendHeroStateChangedAsync(this IConnection? connection, ushort @playerId, CharacterHeroState @newState)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = HeroStateChangedRef.Length;
            var packet = new HeroStateChangedRef(connection.Output.GetSpan(length)[..length]);
            packet.PlayerId = @playerId;
            packet.NewState = @newState;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SkillAdded" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillIndex">The skill index.</param>
    /// <param name="skillNumber">The skill number.</param>
    /// <param name="skillLevel">The skill level.</param>
    /// <param name="flag">The flag.</param>
    /// <remarks>
    /// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </remarks>
    public static async ValueTask SendSkillAddedAsync(this IConnection? connection, byte @skillIndex, ushort @skillNumber, byte @skillLevel, byte @flag = 0xFE)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SkillAddedRef.Length;
            var packet = new SkillAddedRef(connection.Output.GetSpan(length)[..length]);
            packet.Flag = @flag;
            packet.SkillIndex = @skillIndex;
            packet.SkillNumber = @skillNumber;
            packet.SkillLevel = @skillLevel;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SkillRemoved" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillIndex">The skill index.</param>
    /// <param name="skillNumber">The skill number.</param>
    /// <param name="flag">The flag.</param>
    /// <remarks>
    /// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </remarks>
    public static async ValueTask SendSkillRemovedAsync(this IConnection? connection, byte @skillIndex, ushort @skillNumber, byte @flag = 0xFF)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SkillRemovedRef.Length;
            var packet = new SkillRemovedRef(connection.Output.GetSpan(length)[..length]);
            packet.Flag = @flag;
            packet.SkillIndex = @skillIndex;
            packet.SkillNumber = @skillNumber;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SkillAdded075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillIndex">The skill index.</param>
    /// <param name="skillNumberAndLevel">The skill number and level.</param>
    /// <param name="flag">The flag.</param>
    /// <remarks>
    /// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </remarks>
    public static async ValueTask SendSkillAdded075Async(this IConnection? connection, byte @skillIndex, ushort @skillNumberAndLevel, byte @flag = 1)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SkillAdded075Ref.Length;
            var packet = new SkillAdded075Ref(connection.Output.GetSpan(length)[..length]);
            packet.Flag = @flag;
            packet.SkillIndex = @skillIndex;
            packet.SkillNumberAndLevel = @skillNumberAndLevel;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SkillRemoved075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillIndex">The skill index.</param>
    /// <param name="skillNumberAndLevel">The skill number and level.</param>
    /// <param name="flag">The flag.</param>
    /// <remarks>
    /// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </remarks>
    public static async ValueTask SendSkillRemoved075Async(this IConnection? connection, byte @skillIndex, ushort @skillNumberAndLevel, byte @flag = 0)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SkillRemoved075Ref.Length;
            var packet = new SkillRemoved075Ref(connection.Output.GetSpan(length)[..length]);
            packet.Flag = @flag;
            packet.SkillIndex = @skillIndex;
            packet.SkillNumberAndLevel = @skillNumberAndLevel;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SkillAdded095" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillIndex">The skill index.</param>
    /// <param name="skillNumberAndLevel">The skill number and level.</param>
    /// <param name="flag">The flag.</param>
    /// <remarks>
    /// Is sent by the server when: After a skill got added to the skill list, e.g. by equipping an item or learning a skill.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </remarks>
    public static async ValueTask SendSkillAdded095Async(this IConnection? connection, byte @skillIndex, ushort @skillNumberAndLevel, byte @flag = 0xFE)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SkillAdded095Ref.Length;
            var packet = new SkillAdded095Ref(connection.Output.GetSpan(length)[..length]);
            packet.Flag = @flag;
            packet.SkillIndex = @skillIndex;
            packet.SkillNumberAndLevel = @skillNumberAndLevel;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SkillRemoved095" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillIndex">The skill index.</param>
    /// <param name="skillNumberAndLevel">The skill number and level.</param>
    /// <param name="flag">The flag.</param>
    /// <remarks>
    /// Is sent by the server when: After a skill got removed from the skill list, e.g. by removing an equipped item.
    /// Causes reaction on client side: The skill is added to the skill list on client side.
    /// </remarks>
    public static async ValueTask SendSkillRemoved095Async(this IConnection? connection, byte @skillIndex, ushort @skillNumberAndLevel, byte @flag = 0xFF)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SkillRemoved095Ref.Length;
            var packet = new SkillRemoved095Ref(connection.Output.GetSpan(length)[..length]);
            packet.Flag = @flag;
            packet.SkillIndex = @skillIndex;
            packet.SkillNumberAndLevel = @skillNumberAndLevel;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CharacterFocused" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="characterName">The character name.</param>
    /// <remarks>
    /// Is sent by the server when: After the client focused the character successfully on the server side.
    /// Causes reaction on client side: The client highlights the focused character.
    /// </remarks>
    public static async ValueTask SendCharacterFocusedAsync(this IConnection? connection, string @characterName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CharacterFocusedRef.Length;
            var packet = new CharacterFocusedRef(connection.Output.GetSpan(length)[..length]);
            packet.CharacterName = @characterName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CharacterStatIncreaseResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="success">The success.</param>
    /// <param name="attribute">The attribute.</param>
    /// <param name="updatedDependentMaximumStat">The updated dependent maximum stat.</param>
    /// <param name="updatedMaximumShield">The updated maximum shield.</param>
    /// <param name="updatedMaximumAbility">The updated maximum ability.</param>
    /// <remarks>
    /// Is sent by the server when: After the server processed a character stat increase request packet.
    /// Causes reaction on client side: If it was successful, adds a point to the requested stat type.
    /// </remarks>
    public static async ValueTask SendCharacterStatIncreaseResponseAsync(this IConnection? connection, bool @success, CharacterStatAttribute @attribute, ushort @updatedDependentMaximumStat, ushort @updatedMaximumShield, ushort @updatedMaximumAbility)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CharacterStatIncreaseResponseRef.Length;
            var packet = new CharacterStatIncreaseResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;
            packet.Attribute = @attribute;
            packet.UpdatedDependentMaximumStat = @updatedDependentMaximumStat;
            packet.UpdatedMaximumShield = @updatedMaximumShield;
            packet.UpdatedMaximumAbility = @updatedMaximumAbility;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CharacterDeleteResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <remarks>
    /// Is sent by the server when: After the server processed a character delete response of the client.
    /// Causes reaction on client side: If successful, the character is deleted from the character selection screen. Otherwise, a message is shown.
    /// </remarks>
    public static async ValueTask SendCharacterDeleteResponseAsync(this IConnection? connection, CharacterDeleteResponse.CharacterDeleteResult @result)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CharacterDeleteResponseRef.Length;
            var packet = new CharacterDeleteResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CharacterLevelUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="level">The level.</param>
    /// <param name="levelUpPoints">The level up points.</param>
    /// <param name="maximumHealth">The maximum health.</param>
    /// <param name="maximumMana">The maximum mana.</param>
    /// <param name="maximumShield">The maximum shield.</param>
    /// <param name="maximumAbility">The maximum ability.</param>
    /// <param name="fruitPoints">The fruit points.</param>
    /// <param name="maximumFruitPoints">The maximum fruit points.</param>
    /// <param name="negativeFruitPoints">The negative fruit points.</param>
    /// <param name="maximumNegativeFruitPoints">The maximum negative fruit points.</param>
    /// <remarks>
    /// Is sent by the server when: After a character leveled up.
    /// Causes reaction on client side: Updates the level (and other related stats) in the game client and shows an effect.
    /// </remarks>
    public static async ValueTask SendCharacterLevelUpdateAsync(this IConnection? connection, ushort @level, ushort @levelUpPoints, ushort @maximumHealth, ushort @maximumMana, ushort @maximumShield, ushort @maximumAbility, ushort @fruitPoints, ushort @maximumFruitPoints, ushort @negativeFruitPoints, ushort @maximumNegativeFruitPoints)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CharacterLevelUpdateRef.Length;
            var packet = new CharacterLevelUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.Level = @level;
            packet.LevelUpPoints = @levelUpPoints;
            packet.MaximumHealth = @maximumHealth;
            packet.MaximumMana = @maximumMana;
            packet.MaximumShield = @maximumShield;
            packet.MaximumAbility = @maximumAbility;
            packet.FruitPoints = @fruitPoints;
            packet.MaximumFruitPoints = @maximumFruitPoints;
            packet.NegativeFruitPoints = @negativeFruitPoints;
            packet.MaximumNegativeFruitPoints = @maximumNegativeFruitPoints;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CharacterInformation" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="x">The x.</param>
    /// <param name="y">The y.</param>
    /// <param name="mapId">The map id.</param>
    /// <param name="currentExperience">The current experience.</param>
    /// <param name="experienceForNextLevel">The experience for next level.</param>
    /// <param name="levelUpPoints">The level up points.</param>
    /// <param name="strength">The strength.</param>
    /// <param name="agility">The agility.</param>
    /// <param name="vitality">The vitality.</param>
    /// <param name="energy">The energy.</param>
    /// <param name="currentHealth">The current health.</param>
    /// <param name="maximumHealth">The maximum health.</param>
    /// <param name="currentMana">The current mana.</param>
    /// <param name="maximumMana">The maximum mana.</param>
    /// <param name="currentShield">The current shield.</param>
    /// <param name="maximumShield">The maximum shield.</param>
    /// <param name="currentAbility">The current ability.</param>
    /// <param name="maximumAbility">The maximum ability.</param>
    /// <param name="money">The money.</param>
    /// <param name="heroState">The hero state.</param>
    /// <param name="status">The status.</param>
    /// <param name="usedFruitPoints">The used fruit points.</param>
    /// <param name="maxFruitPoints">The max fruit points.</param>
    /// <param name="leadership">The leadership.</param>
    /// <param name="usedNegativeFruitPoints">The used negative fruit points.</param>
    /// <param name="maxNegativeFruitPoints">The max negative fruit points.</param>
    /// <param name="inventoryExtensions">The inventory extensions.</param>
    /// <remarks>
    /// Is sent by the server when: After the character was selected by the player and entered the game.
    /// Causes reaction on client side: The characters enters the game world.
    /// </remarks>
    public static async ValueTask SendCharacterInformationAsync(this IConnection? connection, byte @x, byte @y, ushort @mapId, ulong @currentExperience, ulong @experienceForNextLevel, ushort @levelUpPoints, ushort @strength, ushort @agility, ushort @vitality, ushort @energy, ushort @currentHealth, ushort @maximumHealth, ushort @currentMana, ushort @maximumMana, ushort @currentShield, ushort @maximumShield, ushort @currentAbility, ushort @maximumAbility, uint @money, CharacterHeroState @heroState, CharacterStatus @status, ushort @usedFruitPoints, ushort @maxFruitPoints, ushort @leadership, ushort @usedNegativeFruitPoints, ushort @maxNegativeFruitPoints, byte @inventoryExtensions)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CharacterInformationRef.Length;
            var packet = new CharacterInformationRef(connection.Output.GetSpan(length)[..length]);
            packet.X = @x;
            packet.Y = @y;
            packet.MapId = @mapId;
            packet.CurrentExperience = @currentExperience;
            packet.ExperienceForNextLevel = @experienceForNextLevel;
            packet.LevelUpPoints = @levelUpPoints;
            packet.Strength = @strength;
            packet.Agility = @agility;
            packet.Vitality = @vitality;
            packet.Energy = @energy;
            packet.CurrentHealth = @currentHealth;
            packet.MaximumHealth = @maximumHealth;
            packet.CurrentMana = @currentMana;
            packet.MaximumMana = @maximumMana;
            packet.CurrentShield = @currentShield;
            packet.MaximumShield = @maximumShield;
            packet.CurrentAbility = @currentAbility;
            packet.MaximumAbility = @maximumAbility;
            packet.Money = @money;
            packet.HeroState = @heroState;
            packet.Status = @status;
            packet.UsedFruitPoints = @usedFruitPoints;
            packet.MaxFruitPoints = @maxFruitPoints;
            packet.Leadership = @leadership;
            packet.UsedNegativeFruitPoints = @usedNegativeFruitPoints;
            packet.MaxNegativeFruitPoints = @maxNegativeFruitPoints;
            packet.InventoryExtensions = @inventoryExtensions;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CharacterInformation075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="x">The x.</param>
    /// <param name="y">The y.</param>
    /// <param name="mapId">The map id.</param>
    /// <param name="currentExperience">The current experience.</param>
    /// <param name="experienceForNextLevel">The experience for next level.</param>
    /// <param name="levelUpPoints">The level up points.</param>
    /// <param name="strength">The strength.</param>
    /// <param name="agility">The agility.</param>
    /// <param name="vitality">The vitality.</param>
    /// <param name="energy">The energy.</param>
    /// <param name="currentHealth">The current health.</param>
    /// <param name="maximumHealth">The maximum health.</param>
    /// <param name="currentMana">The current mana.</param>
    /// <param name="maximumMana">The maximum mana.</param>
    /// <param name="money">The money.</param>
    /// <param name="heroState">The hero state.</param>
    /// <param name="status">The status.</param>
    /// <remarks>
    /// Is sent by the server when: After the character was selected by the player and entered the game.
    /// Causes reaction on client side: The characters enters the game world.
    /// </remarks>
    public static async ValueTask SendCharacterInformation075Async(this IConnection? connection, byte @x, byte @y, byte @mapId, uint @currentExperience, uint @experienceForNextLevel, ushort @levelUpPoints, ushort @strength, ushort @agility, ushort @vitality, ushort @energy, ushort @currentHealth, ushort @maximumHealth, ushort @currentMana, ushort @maximumMana, uint @money, CharacterHeroState @heroState, CharacterStatus @status)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CharacterInformation075Ref.Length;
            var packet = new CharacterInformation075Ref(connection.Output.GetSpan(length)[..length]);
            packet.X = @x;
            packet.Y = @y;
            packet.MapId = @mapId;
            packet.CurrentExperience = @currentExperience;
            packet.ExperienceForNextLevel = @experienceForNextLevel;
            packet.LevelUpPoints = @levelUpPoints;
            packet.Strength = @strength;
            packet.Agility = @agility;
            packet.Vitality = @vitality;
            packet.Energy = @energy;
            packet.CurrentHealth = @currentHealth;
            packet.MaximumHealth = @maximumHealth;
            packet.CurrentMana = @currentMana;
            packet.MaximumMana = @maximumMana;
            packet.Money = @money;
            packet.HeroState = @heroState;
            packet.Status = @status;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CharacterInformation097" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="x">The x.</param>
    /// <param name="y">The y.</param>
    /// <param name="mapId">The map id.</param>
    /// <param name="direction">The direction.</param>
    /// <param name="currentExperience">The current experience.</param>
    /// <param name="experienceForNextLevel">The experience for next level.</param>
    /// <param name="levelUpPoints">The level up points.</param>
    /// <param name="strength">The strength.</param>
    /// <param name="agility">The agility.</param>
    /// <param name="vitality">The vitality.</param>
    /// <param name="energy">The energy.</param>
    /// <param name="currentHealth">The current health.</param>
    /// <param name="maximumHealth">The maximum health.</param>
    /// <param name="currentMana">The current mana.</param>
    /// <param name="maximumMana">The maximum mana.</param>
    /// <param name="currentAbility">The current ability.</param>
    /// <param name="maximumAbility">The maximum ability.</param>
    /// <param name="money">The money.</param>
    /// <param name="heroState">The hero state.</param>
    /// <param name="status">The status.</param>
    /// <param name="usedFruitPoints">The used fruit points.</param>
    /// <param name="maxFruitPoints">The max fruit points.</param>
    /// <param name="leadership">The leadership.</param>
    /// <remarks>
    /// Is sent by the server when: After the character was selected by the player and entered the game.
    /// Causes reaction on client side: The characters enters the game world.
    /// </remarks>
    public static async ValueTask SendCharacterInformation097Async(this IConnection? connection, byte @x, byte @y, byte @mapId, byte @direction, uint @currentExperience, uint @experienceForNextLevel, ushort @levelUpPoints, ushort @strength, ushort @agility, ushort @vitality, ushort @energy, ushort @currentHealth, ushort @maximumHealth, ushort @currentMana, ushort @maximumMana, ushort @currentAbility, ushort @maximumAbility, uint @money, CharacterHeroState @heroState, CharacterStatus @status, ushort @usedFruitPoints, ushort @maxFruitPoints, ushort @leadership)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CharacterInformation097Ref.Length;
            var packet = new CharacterInformation097Ref(connection.Output.GetSpan(length)[..length]);
            packet.X = @x;
            packet.Y = @y;
            packet.MapId = @mapId;
            packet.Direction = @direction;
            packet.CurrentExperience = @currentExperience;
            packet.ExperienceForNextLevel = @experienceForNextLevel;
            packet.LevelUpPoints = @levelUpPoints;
            packet.Strength = @strength;
            packet.Agility = @agility;
            packet.Vitality = @vitality;
            packet.Energy = @energy;
            packet.CurrentHealth = @currentHealth;
            packet.MaximumHealth = @maximumHealth;
            packet.CurrentMana = @currentMana;
            packet.MaximumMana = @maximumMana;
            packet.CurrentAbility = @currentAbility;
            packet.MaximumAbility = @maximumAbility;
            packet.Money = @money;
            packet.HeroState = @heroState;
            packet.Status = @status;
            packet.UsedFruitPoints = @usedFruitPoints;
            packet.MaxFruitPoints = @maxFruitPoints;
            packet.Leadership = @leadership;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="InventoryItemUpgraded" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="inventorySlot">The inventory slot.</param>
    /// <param name="itemData">The item data.</param>
    /// <remarks>
    /// Is sent by the server when: An item in the inventory got upgraded by the player, e.g. by applying a jewel.
    /// Causes reaction on client side: The item is updated on the user interface.
    /// </remarks>
    public static async ValueTask SendInventoryItemUpgradedAsync(this IConnection? connection, byte @inventorySlot, Memory<byte> @itemData)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = InventoryItemUpgradedRef.GetRequiredSize(itemData.Length);
            var packet = new InventoryItemUpgradedRef(connection.Output.GetSpan(length)[..length]);
            packet.InventorySlot = @inventorySlot;
            @itemData.Span.CopyTo(packet.ItemData);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SummonHealthUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="healthPercent">The health percent.</param>
    /// <remarks>
    /// Is sent by the server when: When health of a summoned monster (Elf Skill) changed.
    /// Causes reaction on client side: The health is updated on the user interface.
    /// </remarks>
    public static async ValueTask SendSummonHealthUpdateAsync(this IConnection? connection, byte @healthPercent)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SummonHealthUpdateRef.Length;
            var packet = new SummonHealthUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.HealthPercent = @healthPercent;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildSoccerTimeUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="seconds">The seconds.</param>
    /// <remarks>
    /// Is sent by the server when: Every second during a guild soccer match.
    /// Causes reaction on client side: The time is updated on the user interface.
    /// </remarks>
    public static async ValueTask SendGuildSoccerTimeUpdateAsync(this IConnection? connection, ushort @seconds)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildSoccerTimeUpdateRef.Length;
            var packet = new GuildSoccerTimeUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.Seconds = @seconds;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildSoccerScoreUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="redTeamName">The red team name.</param>
    /// <param name="redTeamGoals">The red team goals.</param>
    /// <param name="blueTeamName">The blue team name.</param>
    /// <param name="blueTeamGoals">The blue team goals.</param>
    /// <remarks>
    /// Is sent by the server when: Whenever the score of the soccer game changed, and at the beginning of the match.
    /// Causes reaction on client side: The score is updated on the user interface.
    /// </remarks>
    public static async ValueTask SendGuildSoccerScoreUpdateAsync(this IConnection? connection, string @redTeamName, byte @redTeamGoals, string @blueTeamName, byte @blueTeamGoals)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildSoccerScoreUpdateRef.Length;
            var packet = new GuildSoccerScoreUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.RedTeamName = @redTeamName;
            packet.RedTeamGoals = @redTeamGoals;
            packet.BlueTeamName = @blueTeamName;
            packet.BlueTeamGoals = @blueTeamGoals;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ServerCommand" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="commandType">The command type.</param>
    /// <param name="parameter1">The parameter 1.</param>
    /// <param name="parameter2">The parameter 2.</param>
    /// <remarks>
    /// Is sent by the server when: E.g. when event items are dropped to the floor, or a specific dialog should be shown.
    /// Causes reaction on client side: The client shows an effect, e.g. a firework.
    /// </remarks>
    public static async ValueTask SendServerCommandAsync(this IConnection? connection, byte @commandType, byte @parameter1, byte @parameter2)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ServerCommandRef.Length;
            var packet = new ServerCommandRef(connection.Output.GetSpan(length)[..length]);
            packet.CommandType = @commandType;
            packet.Parameter1 = @parameter1;
            packet.Parameter2 = @parameter2;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ShowFireworks" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="x">The x.</param>
    /// <param name="y">The y.</param>
    /// <param name="effectType">The effect type.</param>
    /// <remarks>
    /// Is sent by the server when: E.g. when event items are dropped to the floor.
    /// Causes reaction on client side: The client shows an fireworks effect at the specified coordinates.
    /// </remarks>
    public static async ValueTask SendShowFireworksAsync(this IConnection? connection, byte @x, byte @y, byte @effectType = 0)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ShowFireworksRef.Length;
            var packet = new ShowFireworksRef(connection.Output.GetSpan(length)[..length]);
            packet.EffectType = @effectType;
            packet.X = @x;
            packet.Y = @y;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ShowChristmasFireworks" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="x">The x.</param>
    /// <param name="y">The y.</param>
    /// <param name="effectType">The effect type.</param>
    /// <remarks>
    /// Is sent by the server when: E.g. when event items are dropped to the floor.
    /// Causes reaction on client side: The client shows an christmas fireworks effect at the specified coordinates.
    /// </remarks>
    public static async ValueTask SendShowChristmasFireworksAsync(this IConnection? connection, byte @x, byte @y, byte @effectType = 59)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ShowChristmasFireworksRef.Length;
            var packet = new ShowChristmasFireworksRef(connection.Output.GetSpan(length)[..length]);
            packet.EffectType = @effectType;
            packet.X = @x;
            packet.Y = @y;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PlayFanfareSound" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="x">The x.</param>
    /// <param name="y">The y.</param>
    /// <param name="effectType">The effect type.</param>
    /// <remarks>
    /// Is sent by the server when: E.g. when event items are dropped to the floor.
    /// Causes reaction on client side: The client plays a fanfare sound at the specified coordinates.
    /// </remarks>
    public static async ValueTask SendPlayFanfareSoundAsync(this IConnection? connection, byte @x, byte @y, byte @effectType = 2)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PlayFanfareSoundRef.Length;
            var packet = new PlayFanfareSoundRef(connection.Output.GetSpan(length)[..length]);
            packet.EffectType = @effectType;
            packet.X = @x;
            packet.Y = @y;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ShowSwirl" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="targetObjectId">The target object id.</param>
    /// <param name="effectType">The effect type.</param>
    /// <remarks>
    /// Is sent by the server when: E.g. when event items are dropped to the floor.
    /// Causes reaction on client side: The client shows a swirl effect at the specified object.
    /// </remarks>
    public static async ValueTask SendShowSwirlAsync(this IConnection? connection, ushort @targetObjectId, byte @effectType = 58)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ShowSwirlRef.Length;
            var packet = new ShowSwirlRef(connection.Output.GetSpan(length)[..length]);
            packet.EffectType = @effectType;
            packet.TargetObjectId = @targetObjectId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MasterStatsUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="masterLevel">The master level.</param>
    /// <param name="masterExperience">The master experience.</param>
    /// <param name="masterExperienceOfNextLevel">The master experience of next level.</param>
    /// <param name="masterLevelUpPoints">The master level up points.</param>
    /// <param name="maximumHealth">The maximum health.</param>
    /// <param name="maximumMana">The maximum mana.</param>
    /// <param name="maximumShield">The maximum shield.</param>
    /// <param name="maximumAbility">The maximum ability.</param>
    /// <remarks>
    /// Is sent by the server when: After entering the game with a master class character.
    /// Causes reaction on client side: The master related data is available.
    /// </remarks>
    public static async ValueTask SendMasterStatsUpdateAsync(this IConnection? connection, ushort @masterLevel, ulong @masterExperience, ulong @masterExperienceOfNextLevel, ushort @masterLevelUpPoints, ushort @maximumHealth, ushort @maximumMana, ushort @maximumShield, ushort @maximumAbility)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MasterStatsUpdateRef.Length;
            var packet = new MasterStatsUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.MasterLevel = @masterLevel;
            packet.MasterExperience = @masterExperience;
            packet.MasterExperienceOfNextLevel = @masterExperienceOfNextLevel;
            packet.MasterLevelUpPoints = @masterLevelUpPoints;
            packet.MaximumHealth = @maximumHealth;
            packet.MaximumMana = @maximumMana;
            packet.MaximumShield = @maximumShield;
            packet.MaximumAbility = @maximumAbility;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MasterCharacterLevelUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="masterLevel">The master level.</param>
    /// <param name="gainedMasterPoints">The gained master points.</param>
    /// <param name="currentMasterPoints">The current master points.</param>
    /// <param name="maximumMasterPoints">The maximum master points.</param>
    /// <param name="maximumHealth">The maximum health.</param>
    /// <param name="maximumMana">The maximum mana.</param>
    /// <param name="maximumShield">The maximum shield.</param>
    /// <param name="maximumAbility">The maximum ability.</param>
    /// <remarks>
    /// Is sent by the server when: After a master character leveled up.
    /// Causes reaction on client side: Updates the master level (and other related stats) in the game client and shows an effect.
    /// </remarks>
    public static async ValueTask SendMasterCharacterLevelUpdateAsync(this IConnection? connection, ushort @masterLevel, ushort @gainedMasterPoints, ushort @currentMasterPoints, ushort @maximumMasterPoints, ushort @maximumHealth, ushort @maximumMana, ushort @maximumShield, ushort @maximumAbility)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MasterCharacterLevelUpdateRef.Length;
            var packet = new MasterCharacterLevelUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.MasterLevel = @masterLevel;
            packet.GainedMasterPoints = @gainedMasterPoints;
            packet.CurrentMasterPoints = @currentMasterPoints;
            packet.MaximumMasterPoints = @maximumMasterPoints;
            packet.MaximumHealth = @maximumHealth;
            packet.MaximumMana = @maximumMana;
            packet.MaximumShield = @maximumShield;
            packet.MaximumAbility = @maximumAbility;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MasterSkillLevelUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="success">The success.</param>
    /// <param name="masterLevelUpPoints">The master level up points.</param>
    /// <param name="masterSkillIndex">The index of the master skill on the clients master skill tree for the given character class.</param>
    /// <param name="masterSkillNumber">The master skill number.</param>
    /// <param name="level">The level.</param>
    /// <param name="displayValue">The display value.</param>
    /// <param name="displayValueOfNextLevel">The display value of next level.</param>
    /// <remarks>
    /// Is sent by the server when: After a master skill level has been changed (usually increased).
    /// Causes reaction on client side: The level is updated in the master skill tree.
    /// </remarks>
    public static async ValueTask SendMasterSkillLevelUpdateAsync(this IConnection? connection, bool @success, ushort @masterLevelUpPoints, byte @masterSkillIndex, ushort @masterSkillNumber, byte @level, float @displayValue, float @displayValueOfNextLevel)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MasterSkillLevelUpdateRef.Length;
            var packet = new MasterSkillLevelUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;
            packet.MasterLevelUpPoints = @masterLevelUpPoints;
            packet.MasterSkillIndex = @masterSkillIndex;
            packet.MasterSkillNumber = @masterSkillNumber;
            packet.Level = @level;
            packet.DisplayValue = @displayValue;
            packet.DisplayValueOfNextLevel = @displayValueOfNextLevel;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ServerMessage" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="type">The type.</param>
    /// <param name="message">The message.</param>
    /// <remarks>
    /// Is sent by the server when: 
    /// Causes reaction on client side: 
    /// </remarks>
    public static async ValueTask SendServerMessageAsync(this IConnection? connection, ServerMessage.MessageType @type, string @message)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ServerMessageRef.GetRequiredSize(message);
            var packet = new ServerMessageRef(connection.Output.GetSpan(length)[..length]);
            packet.Type = @type;
            packet.Message = @message;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildJoinRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="requesterId">The requester id.</param>
    /// <remarks>
    /// Is sent by the server when: A player requested to join a guild. This message is sent then to the guild master.
    /// Causes reaction on client side: The guild master gets a message box with the request popping up.
    /// </remarks>
    public static async ValueTask SendGuildJoinRequestAsync(this IConnection? connection, ushort @requesterId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildJoinRequestRef.Length;
            var packet = new GuildJoinRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.RequesterId = @requesterId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildJoinResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <remarks>
    /// Is sent by the server when: After a guild master responded to a request of a player to join his guild. This message is sent back to the requesting player.
    /// Causes reaction on client side: The requester gets a corresponding message showing.
    /// </remarks>
    public static async ValueTask SendGuildJoinResponseAsync(this IConnection? connection, GuildJoinResponse.GuildJoinRequestResult @result)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildJoinResponseRef.Length;
            var packet = new GuildJoinResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildKickResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <remarks>
    /// Is sent by the server when: After a guild master sent a request to kick a player from its guild and the server processed this request.
    /// Causes reaction on client side: The client shows a message depending on the result.
    /// </remarks>
    public static async ValueTask SendGuildKickResponseAsync(this IConnection? connection, GuildKickResponse.GuildKickSuccess @result)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildKickResponseRef.Length;
            var packet = new GuildKickResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ShowGuildMasterDialog" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the server when: After a player started talking to the guild master NPC and the player is allowed to create a guild.
    /// Causes reaction on client side: The client shows the guild master dialog.
    /// </remarks>
    public static async ValueTask SendShowGuildMasterDialogAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ShowGuildMasterDialogRef.Length;
            var packet = new ShowGuildMasterDialogRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ShowGuildCreationDialog" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the server when: After a player started talking to the guild master NPC and the player proceeds to create a guild.
    /// Causes reaction on client side: The client shows the guild creation dialog.
    /// </remarks>
    public static async ValueTask SendShowGuildCreationDialogAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ShowGuildCreationDialogRef.Length;
            var packet = new ShowGuildCreationDialogRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildCreationResult" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="success">The success.</param>
    /// <param name="error">The error.</param>
    /// <remarks>
    /// Is sent by the server when: After a player requested to create a guild at the guild master NPC.
    /// Causes reaction on client side: Depending on the result, a message is shown.
    /// </remarks>
    public static async ValueTask SendGuildCreationResultAsync(this IConnection? connection, bool @success, GuildCreationResult.GuildCreationErrorType @error)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildCreationResultRef.Length;
            var packet = new GuildCreationResultRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;
            packet.Error = @error;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildMemberLeftGuild" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="isGuildMaster">The is guild master.</param>
    /// <remarks>
    /// Is sent by the server when: A player left a guild. This message is sent to the player and all surrounding players.
    /// Causes reaction on client side: The player is not longer shown as a guild member.
    /// </remarks>
    public static async ValueTask SendGuildMemberLeftGuildAsync(this IConnection? connection, ushort @playerId, bool @isGuildMaster)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildMemberLeftGuildRef.Length;
            var packet = new GuildMemberLeftGuildRef(connection.Output.GetSpan(length)[..length]);
            packet.PlayerId = @playerId;
            packet.IsGuildMaster = @isGuildMaster;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildWarRequestResult" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <remarks>
    /// Is sent by the server when: A guild master requested a guild war against another guild.
    /// Causes reaction on client side: The guild master of the other guild gets this request.
    /// </remarks>
    public static async ValueTask SendGuildWarRequestResultAsync(this IConnection? connection, GuildWarRequestResult.RequestResult @result)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildWarRequestResultRef.Length;
            var packet = new GuildWarRequestResultRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildWarRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="guildName">The guild name.</param>
    /// <param name="type">The type.</param>
    /// <remarks>
    /// Is sent by the server when: A guild master requested a guild war against another guild.
    /// Causes reaction on client side: The guild master of the other guild gets this request.
    /// </remarks>
    public static async ValueTask SendGuildWarRequestAsync(this IConnection? connection, string @guildName, GuildWarType @type)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildWarRequestRef.Length;
            var packet = new GuildWarRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.GuildName = @guildName;
            packet.Type = @type;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildWarDeclared" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="guildName">The guild name.</param>
    /// <param name="type">The type.</param>
    /// <param name="teamCode">The team code.</param>
    /// <remarks>
    /// Is sent by the server when: A guild master requested a guild war against another guild.
    /// Causes reaction on client side: The guild master of the other guild gets this request.
    /// </remarks>
    public static async ValueTask SendGuildWarDeclaredAsync(this IConnection? connection, string @guildName, GuildWarType @type, byte @teamCode)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildWarDeclaredRef.Length;
            var packet = new GuildWarDeclaredRef(connection.Output.GetSpan(length)[..length]);
            packet.GuildName = @guildName;
            packet.Type = @type;
            packet.TeamCode = @teamCode;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildWarEnded" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <param name="guildName">The guild name.</param>
    /// <remarks>
    /// Is sent by the server when: The guild war ended.
    /// Causes reaction on client side: The guild war is shown as ended on the client side.
    /// </remarks>
    public static async ValueTask SendGuildWarEndedAsync(this IConnection? connection, GuildWarEnded.GuildWarResult @result, string @guildName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildWarEndedRef.Length;
            var packet = new GuildWarEndedRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;
            packet.GuildName = @guildName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildWarScoreUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="scoreOfOwnGuild">The score of own guild.</param>
    /// <param name="scoreOfEnemyGuild">The score of enemy guild.</param>
    /// <param name="type">The type.</param>
    /// <remarks>
    /// Is sent by the server when: The guild war score changed.
    /// Causes reaction on client side: The guild score is updated on the client side.
    /// </remarks>
    public static async ValueTask SendGuildWarScoreUpdateAsync(this IConnection? connection, byte @scoreOfOwnGuild, byte @scoreOfEnemyGuild, byte @type = 0)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildWarScoreUpdateRef.Length;
            var packet = new GuildWarScoreUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.ScoreOfOwnGuild = @scoreOfOwnGuild;
            packet.ScoreOfEnemyGuild = @scoreOfEnemyGuild;
            packet.Type = @type;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="GuildInformation" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="guildId">The guild id.</param>
    /// <param name="guildType">The guild type.</param>
    /// <param name="allianceGuildName">The alliance guild name.</param>
    /// <param name="guildName">The guild name.</param>
    /// <param name="logo">The logo.</param>
    /// <remarks>
    /// Is sent by the server when: A game client requested the (public) info of a guild, e.g. when it met a player of previously unknown guild.
    /// Causes reaction on client side: The players which belong to the guild are shown as guild players.
    /// </remarks>
    public static async ValueTask SendGuildInformationAsync(this IConnection? connection, uint @guildId, byte @guildType, string @allianceGuildName, string @guildName, Memory<byte> @logo)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = GuildInformationRef.Length;
            var packet = new GuildInformationRef(connection.Output.GetSpan(length)[..length]);
            packet.GuildId = @guildId;
            packet.GuildType = @guildType;
            packet.AllianceGuildName = @allianceGuildName;
            packet.GuildName = @guildName;
            @logo.Span.CopyTo(packet.Logo);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SingleGuildInformation075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="guildId">The guild id.</param>
    /// <param name="guildName">The guild name.</param>
    /// <param name="logo">The logo.</param>
    /// <remarks>
    /// Is sent by the server when: After a guild has been created. However, in OpenMU, we just send the GuildInformations075 message, because it works just the same.
    /// Causes reaction on client side: The players which belong to the guild are shown as guild players.
    /// </remarks>
    public static async ValueTask SendSingleGuildInformation075Async(this IConnection? connection, ushort @guildId, string @guildName, Memory<byte> @logo)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SingleGuildInformation075Ref.Length;
            var packet = new SingleGuildInformation075Ref(connection.Output.GetSpan(length)[..length]);
            packet.GuildId = @guildId;
            packet.GuildName = @guildName;
            @logo.Span.CopyTo(packet.Logo);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="VaultMoneyUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="success">The success.</param>
    /// <param name="vaultMoney">The vault money.</param>
    /// <param name="inventoryMoney">The inventory money.</param>
    /// <remarks>
    /// Is sent by the server when: After the player requested to move money between the vault and inventory.
    /// Causes reaction on client side: The game client updates the money values of vault and inventory.
    /// </remarks>
    public static async ValueTask SendVaultMoneyUpdateAsync(this IConnection? connection, bool @success, uint @vaultMoney, uint @inventoryMoney)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = VaultMoneyUpdateRef.Length;
            var packet = new VaultMoneyUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;
            packet.VaultMoney = @vaultMoney;
            packet.InventoryMoney = @inventoryMoney;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="VaultClosed" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the server when: After the player requested to close the vault, this confirmation is sent back to the client.
    /// Causes reaction on client side: The game client closes the vault dialog.
    /// </remarks>
    public static async ValueTask SendVaultClosedAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = VaultClosedRef.Length;
            var packet = new VaultClosedRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="VaultProtectionInformation" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="protectionState">The protection state.</param>
    /// <remarks>
    /// Is sent by the server when: After the player requested to open the vault.
    /// Causes reaction on client side: The game client updates the UI to show the current vault protection state.
    /// </remarks>
    public static async ValueTask SendVaultProtectionInformationAsync(this IConnection? connection, VaultProtectionInformation.VaultProtectionState @protectionState)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = VaultProtectionInformationRef.Length;
            var packet = new VaultProtectionInformationRef(connection.Output.GetSpan(length)[..length]);
            packet.ProtectionState = @protectionState;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ItemCraftingResult" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <param name="itemData">The item data.</param>
    /// <remarks>
    /// Is sent by the server when: After the player requested to execute an item crafting, e.g. at the chaos machine.
    /// Causes reaction on client side: The game client updates the UI to show the resulting item.
    /// </remarks>
    public static async ValueTask SendItemCraftingResultAsync(this IConnection? connection, ItemCraftingResult.CraftingResult @result, Memory<byte> @itemData)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ItemCraftingResultRef.GetRequiredSize(itemData.Length);
            var packet = new ItemCraftingResultRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;
            @itemData.Span.CopyTo(packet.ItemData);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="CraftingDialogClosed075" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the server when: After the player requested to close the crafting dialog, this confirmation is sent back to the client.
    /// Causes reaction on client side: The game client closes the crafting dialog.
    /// </remarks>
    public static async ValueTask SendCraftingDialogClosed075Async(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = CraftingDialogClosed075Ref.Length;
            var packet = new CraftingDialogClosed075Ref(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LegacyQuestStateDialog" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="questIndex">The quest index.</param>
    /// <param name="state">This is the complete byte with the state of four quests within the same byte.</param>
    /// <remarks>
    /// Is sent by the server when: When the player clicks on the quest npc.
    /// Causes reaction on client side: The game client shows the next steps in the quest dialog.
    /// </remarks>
    public static async ValueTask SendLegacyQuestStateDialogAsync(this IConnection? connection, byte @questIndex, byte @state)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LegacyQuestStateDialogRef.Length;
            var packet = new LegacyQuestStateDialogRef(connection.Output.GetSpan(length)[..length]);
            packet.QuestIndex = @questIndex;
            packet.State = @state;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LegacySetQuestStateResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="questIndex">The quest index.</param>
    /// <param name="result">This value is 0 if successful. Otherwise, 0xFF or even other magic values.</param>
    /// <param name="newState">This is the complete byte with the state of four quests within the same byte.</param>
    /// <remarks>
    /// Is sent by the server when: As response to the set state request (C1A2).
    /// Causes reaction on client side: The game client shows the new quest state.
    /// </remarks>
    public static async ValueTask SendLegacySetQuestStateResponseAsync(this IConnection? connection, byte @questIndex, byte @result, byte @newState)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LegacySetQuestStateResponseRef.Length;
            var packet = new LegacySetQuestStateResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.QuestIndex = @questIndex;
            packet.Result = @result;
            packet.NewState = @newState;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LegacyQuestReward" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="playerId">The player id.</param>
    /// <param name="reward">The reward.</param>
    /// <param name="count">The count.</param>
    /// <remarks>
    /// Is sent by the server when: As response to the completed quest of a player in scope.
    /// Causes reaction on client side: The game client shows the reward accordingly.
    /// </remarks>
    public static async ValueTask SendLegacyQuestRewardAsync(this IConnection? connection, ushort @playerId, LegacyQuestReward.QuestRewardType @reward, byte @count)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LegacyQuestRewardRef.Length;
            var packet = new LegacyQuestRewardRef(connection.Output.GetSpan(length)[..length]);
            packet.PlayerId = @playerId;
            packet.Reward = @reward;
            packet.Count = @count;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PetMode" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="petCommandMode">The pet command mode.</param>
    /// <param name="targetId">The target id.</param>
    /// <param name="pet">The pet.</param>
    /// <remarks>
    /// Is sent by the server when: After the client sent a PetAttackCommand (as confirmation), or when the previous command finished and the pet is reset to Normal-mode.
    /// Causes reaction on client side: The client updates the pet mode in its user interface.
    /// </remarks>
    public static async ValueTask SendPetModeAsync(this IConnection? connection, ClientToServer.PetCommandMode @petCommandMode, ushort @targetId, ClientToServer.PetType @pet = ClientToServer.PetType.DarkRaven)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PetModeRef.Length;
            var packet = new PetModeRef(connection.Output.GetSpan(length)[..length]);
            packet.Pet = @pet;
            packet.PetCommandMode = @petCommandMode;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PetAttack" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillType">The skill type.</param>
    /// <param name="ownerId">The owner id.</param>
    /// <param name="targetId">The target id.</param>
    /// <param name="pet">The pet.</param>
    /// <remarks>
    /// Is sent by the server when: After the client sent a PetAttackCommand, the pet attacks automatically. For each attack, the player and all observing players get this message.
    /// Causes reaction on client side: The client shows the pet attacking the target.
    /// </remarks>
    public static async ValueTask SendPetAttackAsync(this IConnection? connection, PetAttack.PetSkillType @skillType, ushort @ownerId, ushort @targetId, ClientToServer.PetType @pet = ClientToServer.PetType.DarkRaven)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PetAttackRef.Length;
            var packet = new PetAttackRef(connection.Output.GetSpan(length)[..length]);
            packet.Pet = @pet;
            packet.SkillType = @skillType;
            packet.OwnerId = @ownerId;
            packet.TargetId = @targetId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="PetInfoResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="pet">The pet.</param>
    /// <param name="storage">The storage.</param>
    /// <param name="itemSlot">The item slot.</param>
    /// <param name="level">The level.</param>
    /// <param name="experience">The experience.</param>
    /// <param name="health">The health.</param>
    /// <remarks>
    /// Is sent by the server when: After the client sent a PetInfoRequest for a pet (dark raven, horse).
    /// Causes reaction on client side: The client shows the information about the pet.
    /// </remarks>
    public static async ValueTask SendPetInfoResponseAsync(this IConnection? connection, ClientToServer.PetType @pet, ClientToServer.StorageType @storage, byte @itemSlot, byte @level, uint @experience, byte @health)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = PetInfoResponseRef.Length;
            var packet = new PetInfoResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.Pet = @pet;
            packet.Storage = @storage;
            packet.ItemSlot = @itemSlot;
            packet.Level = @level;
            packet.Experience = @experience;
            packet.Health = @health;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelStartResult" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <param name="opponentId">The opponent id.</param>
    /// <param name="opponentName">The opponent name.</param>
    /// <remarks>
    /// Is sent by the server when: After the client sent a DuelStartRequest, and it either failed or the requested player sent a response.
    /// Causes reaction on client side: The client shows the started or aborted duel.
    /// </remarks>
    public static async ValueTask SendDuelStartResultAsync(this IConnection? connection, DuelStartResult.DuelStartResultType @result, ushort @opponentId, string @opponentName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelStartResultRef.Length;
            var packet = new DuelStartResultRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;
            packet.OpponentId = @opponentId;
            packet.OpponentName = @opponentName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelStartRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="requesterId">The requester id.</param>
    /// <param name="requesterName">The requester name.</param>
    /// <remarks>
    /// Is sent by the server when: After another client sent a DuelStartRequest, to ask the requested player for a response.
    /// Causes reaction on client side: The client shows the duel request.
    /// </remarks>
    public static async ValueTask SendDuelStartRequestAsync(this IConnection? connection, ushort @requesterId, string @requesterName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelStartRequestRef.Length;
            var packet = new DuelStartRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.RequesterId = @requesterId;
            packet.RequesterName = @requesterName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelEnd" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="opponentId">The opponent id.</param>
    /// <param name="opponentName">The opponent name.</param>
    /// <param name="result">The result.</param>
    /// <remarks>
    /// Is sent by the server when: After a duel ended.
    /// Causes reaction on client side: The client updates its state.
    /// </remarks>
    public static async ValueTask SendDuelEndAsync(this IConnection? connection, ushort @opponentId, string @opponentName, byte @result = 0)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelEndRef.Length;
            var packet = new DuelEndRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;
            packet.OpponentId = @opponentId;
            packet.OpponentName = @opponentName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelScore" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="player1Id">The player 1 id.</param>
    /// <param name="player2Id">The player 2 id.</param>
    /// <param name="player1Score">The player 1 score.</param>
    /// <param name="player2Score">The player 2 score.</param>
    /// <remarks>
    /// Is sent by the server when: When the score of the duel has been changed.
    /// Causes reaction on client side: The client updates the displayed duel score.
    /// </remarks>
    public static async ValueTask SendDuelScoreAsync(this IConnection? connection, ushort @player1Id, ushort @player2Id, byte @player1Score, byte @player2Score)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelScoreRef.Length;
            var packet = new DuelScoreRef(connection.Output.GetSpan(length)[..length]);
            packet.Player1Id = @player1Id;
            packet.Player2Id = @player2Id;
            packet.Player1Score = @player1Score;
            packet.Player2Score = @player2Score;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelHealthUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="player1Id">The player 1 id.</param>
    /// <param name="player2Id">The player 2 id.</param>
    /// <param name="player1HealthPercentage">The player 1 health percentage.</param>
    /// <param name="player2HealthPercentage">The player 2 health percentage.</param>
    /// <param name="player1ShieldPercentage">The player 1 shield percentage.</param>
    /// <param name="player2ShieldPercentage">The player 2 shield percentage.</param>
    /// <remarks>
    /// Is sent by the server when: When the health/shield of the duel players has been changed.
    /// Causes reaction on client side: The client updates the displayed health and shield bars.
    /// </remarks>
    public static async ValueTask SendDuelHealthUpdateAsync(this IConnection? connection, ushort @player1Id, ushort @player2Id, byte @player1HealthPercentage, byte @player2HealthPercentage, byte @player1ShieldPercentage, byte @player2ShieldPercentage)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelHealthUpdateRef.Length;
            var packet = new DuelHealthUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.Player1Id = @player1Id;
            packet.Player2Id = @player2Id;
            packet.Player1HealthPercentage = @player1HealthPercentage;
            packet.Player2HealthPercentage = @player2HealthPercentage;
            packet.Player1ShieldPercentage = @player1ShieldPercentage;
            packet.Player2ShieldPercentage = @player2ShieldPercentage;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelInit" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <param name="roomIndex">The room index.</param>
    /// <param name="player1Name">The player 1 name.</param>
    /// <param name="player2Name">The player 2 name.</param>
    /// <param name="player1Id">The player 1 id.</param>
    /// <param name="player2Id">The player 2 id.</param>
    /// <remarks>
    /// Is sent by the server when: When the duel starts.
    /// Causes reaction on client side: The client initializes the duel state.
    /// </remarks>
    public static async ValueTask SendDuelInitAsync(this IConnection? connection, byte @result, byte @roomIndex, string @player1Name, string @player2Name, ushort @player1Id, ushort @player2Id)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelInitRef.Length;
            var packet = new DuelInitRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;
            packet.RoomIndex = @roomIndex;
            packet.Player1Name = @player1Name;
            packet.Player2Name = @player2Name;
            packet.Player1Id = @player1Id;
            packet.Player2Id = @player2Id;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelHealthBarInit" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <remarks>
    /// Is sent by the server when: When the duel starts, after the DuelInit message.
    /// Causes reaction on client side: The client updates the displayed health and shield bars.
    /// </remarks>
    public static async ValueTask SendDuelHealthBarInitAsync(this IConnection? connection)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelHealthBarInitRef.Length;
            var packet = new DuelHealthBarInitRef(connection.Output.GetSpan(length)[..length]);
            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelSpectatorAdded" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="name">The name.</param>
    /// <remarks>
    /// Is sent by the server when: When a spectator joins a duel.
    /// Causes reaction on client side: The client updates the list of spectators.
    /// </remarks>
    public static async ValueTask SendDuelSpectatorAddedAsync(this IConnection? connection, string @name)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelSpectatorAddedRef.Length;
            var packet = new DuelSpectatorAddedRef(connection.Output.GetSpan(length)[..length]);
            packet.Name = @name;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelSpectatorRemoved" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="name">The name.</param>
    /// <remarks>
    /// Is sent by the server when: When a spectator joins a duel.
    /// Causes reaction on client side: The client updates the list of spectators.
    /// </remarks>
    public static async ValueTask SendDuelSpectatorRemovedAsync(this IConnection? connection, string @name)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelSpectatorRemovedRef.Length;
            var packet = new DuelSpectatorRemovedRef(connection.Output.GetSpan(length)[..length]);
            packet.Name = @name;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DuelFinished" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="winner">The winner.</param>
    /// <param name="loser">The loser.</param>
    /// <remarks>
    /// Is sent by the server when: When the duel finished.
    /// Causes reaction on client side: The client shows the winner and loser names.
    /// </remarks>
    public static async ValueTask SendDuelFinishedAsync(this IConnection? connection, string @winner, string @loser)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DuelFinishedRef.Length;
            var packet = new DuelFinishedRef(connection.Output.GetSpan(length)[..length]);
            packet.Winner = @winner;
            packet.Loser = @loser;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="SkillStageUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="objectId">The object id.</param>
    /// <param name="stage">The stage.</param>
    /// <param name="skillNumber">The skill number.</param>
    /// <remarks>
    /// Is sent by the server when: After a player started a skill which needs to load up, like Nova.
    /// Causes reaction on client side: The client may show the loading intensity.
    /// </remarks>
    public static async ValueTask SendSkillStageUpdateAsync(this IConnection? connection, ushort @objectId, byte @stage, byte @skillNumber = 0x28)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = SkillStageUpdateRef.Length;
            var packet = new SkillStageUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.ObjectId = @objectId;
            packet.SkillNumber = @skillNumber;
            packet.Stage = @stage;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="IllusionTempleEnterResult" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <remarks>
    /// Is sent by the server when: The player requested to enter the illusion temple event.
    /// Causes reaction on client side: The client shows the result.
    /// </remarks>
    public static async ValueTask SendIllusionTempleEnterResultAsync(this IConnection? connection, byte @result)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = IllusionTempleEnterResultRef.Length;
            var packet = new IllusionTempleEnterResultRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="IllusionTempleSkillUsageResult" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <param name="skillNumber">The skill number.</param>
    /// <param name="sourceObjectId">The source object id.</param>
    /// <param name="targetObjectId">The target object id.</param>
    /// <remarks>
    /// Is sent by the server when: A player requested to use a specific skill in the illusion temple event.
    /// Causes reaction on client side: The client shows the result.
    /// </remarks>
    public static async ValueTask SendIllusionTempleSkillUsageResultAsync(this IConnection? connection, byte @result, ushort @skillNumber, ushort @sourceObjectId, ushort @targetObjectId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = IllusionTempleSkillUsageResultRef.Length;
            var packet = new IllusionTempleSkillUsageResultRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;
            packet.SkillNumber = @skillNumber;
            packet.SourceObjectId = @sourceObjectId;
            packet.TargetObjectId = @targetObjectId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="IllusionTempleUserCount" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="userCount1">The user count 1.</param>
    /// <param name="userCount2">The user count 2.</param>
    /// <param name="userCount3">The user count 3.</param>
    /// <param name="userCount4">The user count 4.</param>
    /// <param name="userCount5">The user count 5.</param>
    /// <param name="userCount6">The user count 6.</param>
    /// <remarks>
    /// Is sent by the server when: ?
    /// Causes reaction on client side: The client shows the counts.
    /// </remarks>
    public static async ValueTask SendIllusionTempleUserCountAsync(this IConnection? connection, byte @userCount1, byte @userCount2, byte @userCount3, byte @userCount4, byte @userCount5, byte @userCount6)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = IllusionTempleUserCountRef.Length;
            var packet = new IllusionTempleUserCountRef(connection.Output.GetSpan(length)[..length]);
            packet.UserCount1 = @userCount1;
            packet.UserCount2 = @userCount2;
            packet.UserCount3 = @userCount3;
            packet.UserCount4 = @userCount4;
            packet.UserCount5 = @userCount5;
            packet.UserCount6 = @userCount6;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="IllusionTempleSkillPointUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillPoints">The skill points.</param>
    /// <remarks>
    /// Is sent by the server when: ?
    /// Causes reaction on client side: The client shows the skill points.
    /// </remarks>
    public static async ValueTask SendIllusionTempleSkillPointUpdateAsync(this IConnection? connection, byte @skillPoints)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = IllusionTempleSkillPointUpdateRef.Length;
            var packet = new IllusionTempleSkillPointUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillPoints = @skillPoints;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="IllusionTempleSkillEnded" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="skillNumber">The skill number.</param>
    /// <param name="objectIndex">The object index.</param>
    /// <remarks>
    /// Is sent by the server when: ?
    /// Causes reaction on client side: The client shows the skill points.
    /// </remarks>
    public static async ValueTask SendIllusionTempleSkillEndedAsync(this IConnection? connection, ushort @skillNumber, ushort @objectIndex)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = IllusionTempleSkillEndedRef.Length;
            var packet = new IllusionTempleSkillEndedRef(connection.Output.GetSpan(length)[..length]);
            packet.SkillNumber = @skillNumber;
            packet.ObjectIndex = @objectIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="IllusionTempleHolyItemRelics" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="userIndex">The user index.</param>
    /// <param name="name">The name.</param>
    /// <remarks>
    /// Is sent by the server when: ?
    /// Causes reaction on client side: ?.
    /// </remarks>
    public static async ValueTask SendIllusionTempleHolyItemRelicsAsync(this IConnection? connection, ushort @userIndex, string @name)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = IllusionTempleHolyItemRelicsRef.Length;
            var packet = new IllusionTempleHolyItemRelicsRef(connection.Output.GetSpan(length)[..length]);
            packet.UserIndex = @userIndex;
            packet.Name = @name;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="IllusionTempleSkillEnd" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="templeNumber">The temple number.</param>
    /// <param name="state">The state.</param>
    /// <remarks>
    /// Is sent by the server when: ?
    /// Causes reaction on client side: The client shows the skill points.
    /// </remarks>
    public static async ValueTask SendIllusionTempleSkillEndAsync(this IConnection? connection, byte @templeNumber, byte @state)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = IllusionTempleSkillEndRef.Length;
            var packet = new IllusionTempleSkillEndRef(connection.Output.GetSpan(length)[..length]);
            packet.TempleNumber = @templeNumber;
            packet.State = @state;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MuHelperStatusUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="consumeMoney">The flag, if money should be consumed. If this is 'true', setting PauseStatus to 'false' doesn't cause starting the helper.</param>
    /// <param name="money">The money.</param>
    /// <param name="pauseStatus">The pause status. A value of 'true' always works to stop the helper. However, it can only be started, with ConsumeMoney set to 'false'.</param>
    /// <remarks>
    /// Is sent by the server when: The server validated or changed the status of the MU Helper.
    /// Causes reaction on client side: The client toggle the MU Helper status.
    /// </remarks>
    public static async ValueTask SendMuHelperStatusUpdateAsync(this IConnection? connection, bool @consumeMoney, uint @money, bool @pauseStatus)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MuHelperStatusUpdateRef.Length;
            var packet = new MuHelperStatusUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.ConsumeMoney = @consumeMoney;
            packet.Money = @money;
            packet.PauseStatus = @pauseStatus;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MuHelperConfigurationData" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="helperData">The helper data.</param>
    /// <remarks>
    /// Is sent by the server when: The server saved the users MU Helper data.
    /// Causes reaction on client side: The user wants to save the MU Helper data.
    /// </remarks>
    public static async ValueTask SendMuHelperConfigurationDataAsync(this IConnection? connection, Memory<byte> @helperData)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MuHelperConfigurationDataRef.Length;
            var packet = new MuHelperConfigurationDataRef(connection.Output.GetSpan(length)[..length]);
            @helperData.Span.CopyTo(packet.HelperData);

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="FriendAdded" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="friendName">The friend name.</param>
    /// <param name="serverId">The server id on which the player currently is online. 0xFF means offline.</param>
    /// <remarks>
    /// Is sent by the server when: After a friend has been added to the friend list.
    /// Causes reaction on client side: The friend appears in the friend list.
    /// </remarks>
    public static async ValueTask SendFriendAddedAsync(this IConnection? connection, string @friendName, byte @serverId = 0xFF)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = FriendAddedRef.Length;
            var packet = new FriendAddedRef(connection.Output.GetSpan(length)[..length]);
            packet.FriendName = @friendName;
            packet.ServerId = @serverId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="FriendRequest" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="requester">The requester.</param>
    /// <remarks>
    /// Is sent by the server when: After a player has requested to add another player as friend. This other player gets this message.
    /// Causes reaction on client side: The friend request appears on the user interface.
    /// </remarks>
    public static async ValueTask SendFriendRequestAsync(this IConnection? connection, string @requester)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = FriendRequestRef.Length;
            var packet = new FriendRequestRef(connection.Output.GetSpan(length)[..length]);
            packet.Requester = @requester;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="FriendDeleted" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="friendName">The friend name.</param>
    /// <remarks>
    /// Is sent by the server when: After a friend has been removed from the friend list.
    /// Causes reaction on client side: The friend is removed from the friend list.
    /// </remarks>
    public static async ValueTask SendFriendDeletedAsync(this IConnection? connection, string @friendName)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = FriendDeletedRef.Length;
            var packet = new FriendDeletedRef(connection.Output.GetSpan(length)[..length]);
            packet.FriendName = @friendName;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="FriendOnlineStateUpdate" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="friendName">The friend name.</param>
    /// <param name="serverId">The server id on which the player currently is online. 0xFF means offline.</param>
    /// <remarks>
    /// Is sent by the server when: After a friend has been added to the friend list.
    /// Causes reaction on client side: The friend appears in the friend list.
    /// </remarks>
    public static async ValueTask SendFriendOnlineStateUpdateAsync(this IConnection? connection, string @friendName, byte @serverId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = FriendOnlineStateUpdateRef.Length;
            var packet = new FriendOnlineStateUpdateRef(connection.Output.GetSpan(length)[..length]);
            packet.FriendName = @friendName;
            packet.ServerId = @serverId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="LetterSendResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="letterId">The letter id.</param>
    /// <param name="result">The result.</param>
    /// <remarks>
    /// Is sent by the server when: After the player requested to send a letter to another player.
    /// Causes reaction on client side: Depending on the result, the letter send dialog closes or an error message appears.
    /// </remarks>
    public static async ValueTask SendLetterSendResponseAsync(this IConnection? connection, uint @letterId, LetterSendResponse.LetterSendRequestResult @result)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = LetterSendResponseRef.Length;
            var packet = new LetterSendResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.LetterId = @letterId;
            packet.Result = @result;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="AddLetter" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="letterIndex">The letter index.</param>
    /// <param name="senderName">The sender name.</param>
    /// <param name="timestamp">The timestamp.</param>
    /// <param name="subject">The subject.</param>
    /// <param name="state">The state.</param>
    /// <remarks>
    /// Is sent by the server when: After a letter has been received or after the player entered the game with a character.
    /// Causes reaction on client side: The letter appears in the letter list.
    /// </remarks>
    public static async ValueTask SendAddLetterAsync(this IConnection? connection, ushort @letterIndex, string @senderName, string @timestamp, string @subject, AddLetter.LetterState @state)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = AddLetterRef.Length;
            var packet = new AddLetterRef(connection.Output.GetSpan(length)[..length]);
            packet.LetterIndex = @letterIndex;
            packet.SenderName = @senderName;
            packet.Timestamp = @timestamp;
            packet.Subject = @subject;
            packet.State = @state;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="OpenLetter" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="letterIndex">The letter index.</param>
    /// <param name="messageSize">The message size.</param>
    /// <param name="senderAppearance">The sender appearance.</param>
    /// <param name="rotation">The rotation.</param>
    /// <param name="animation">The animation.</param>
    /// <param name="message">The message.</param>
    /// <remarks>
    /// Is sent by the server when: After the player requested to read a letter.
    /// Causes reaction on client side: The letter is opened in a new dialog.
    /// </remarks>
    public static async ValueTask SendOpenLetterAsync(this IConnection? connection, ushort @letterIndex, ushort @messageSize, Memory<byte> @senderAppearance, byte @rotation, byte @animation, string @message)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = OpenLetterRef.GetRequiredSize(message);
            var packet = new OpenLetterRef(connection.Output.GetSpan(length)[..length]);
            packet.LetterIndex = @letterIndex;
            packet.MessageSize = @messageSize;
            @senderAppearance.Span.CopyTo(packet.SenderAppearance);
            packet.Rotation = @rotation;
            packet.Animation = @animation;
            packet.Message = @message;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="RemoveLetter" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="letterIndex">The letter index.</param>
    /// <param name="requestSuccessful">The request successful.</param>
    /// <remarks>
    /// Is sent by the server when: After a letter has been deleted by the request of the player.
    /// Causes reaction on client side: The letter is removed from the letter list.
    /// </remarks>
    public static async ValueTask SendRemoveLetterAsync(this IConnection? connection, ushort @letterIndex, bool @requestSuccessful = true)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = RemoveLetterRef.Length;
            var packet = new RemoveLetterRef(connection.Output.GetSpan(length)[..length]);
            packet.RequestSuccessful = @requestSuccessful;
            packet.LetterIndex = @letterIndex;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ChatRoomConnectionInfo" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="chatServerIp">The chat server ip.</param>
    /// <param name="chatRoomId">The chat room id.</param>
    /// <param name="authenticationToken">The authentication token.</param>
    /// <param name="friendName">The friend name.</param>
    /// <param name="success">The success.</param>
    /// <param name="type">The type.</param>
    /// <remarks>
    /// Is sent by the server when: The player is invited to join a chat room on the chat server.
    /// Causes reaction on client side: The game client connects to the chat server and joins the chat room with the specified authentication data.
    /// </remarks>
    public static async ValueTask SendChatRoomConnectionInfoAsync(this IConnection? connection, string @chatServerIp, ushort @chatRoomId, uint @authenticationToken, string @friendName, bool @success, byte @type = 1)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ChatRoomConnectionInfoRef.Length;
            var packet = new ChatRoomConnectionInfoRef(connection.Output.GetSpan(length)[..length]);
            packet.ChatServerIp = @chatServerIp;
            packet.ChatRoomId = @chatRoomId;
            packet.AuthenticationToken = @authenticationToken;
            packet.Type = @type;
            packet.FriendName = @friendName;
            packet.Success = @success;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="FriendInvitationResult" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="success">The success.</param>
    /// <param name="requestId">The request id.</param>
    /// <remarks>
    /// Is sent by the server when: The player requested to add another player to his friend list and the server processed this request.
    /// Causes reaction on client side: The game client knows if the invitation could be sent to the other player.
    /// </remarks>
    public static async ValueTask SendFriendInvitationResultAsync(this IConnection? connection, bool @success, uint @requestId)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = FriendInvitationResultRef.Length;
            var packet = new FriendInvitationResultRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;
            packet.RequestId = @requestId;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="QuestStepInfo" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="questStepNumber">A number specifying the description: A) when selecting a quest in the quest list, it's the "StartingNumber"; B) when a quest has been started it's the quest number; C) when the starting number has been sent previously and the player refused to start the quest, it sends a "RefuseNumber".</param>
    /// <param name="questGroup">The quest group.</param>
    /// <remarks>
    /// Is sent by the server when: After the game client clicked on a quest in the quest list, proceeded with a quest or refused to start a quest.
    /// Causes reaction on client side: The client shows the corresponding description about the current quest step.
    /// </remarks>
    public static async ValueTask SendQuestStepInfoAsync(this IConnection? connection, ushort @questStepNumber, ushort @questGroup)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = QuestStepInfoRef.Length;
            var packet = new QuestStepInfoRef(connection.Output.GetSpan(length)[..length]);
            packet.QuestStepNumber = @questStepNumber;
            packet.QuestGroup = @questGroup;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="QuestCompletionResponse" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="questNumber">The quest number.</param>
    /// <param name="questGroup">The quest group.</param>
    /// <param name="isQuestCompleted">The is quest completed.</param>
    /// <remarks>
    /// Is sent by the server when: The server acknowledges the completion of a quest.
    /// Causes reaction on client side: The client shows the success and possibly requests for the next available quests.
    /// </remarks>
    public static async ValueTask SendQuestCompletionResponseAsync(this IConnection? connection, ushort @questNumber, ushort @questGroup, bool @isQuestCompleted)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = QuestCompletionResponseRef.Length;
            var packet = new QuestCompletionResponseRef(connection.Output.GetSpan(length)[..length]);
            packet.QuestNumber = @questNumber;
            packet.QuestGroup = @questGroup;
            packet.IsQuestCompleted = @isQuestCompleted;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="QuestCancelled" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="questNumber">The current quest number. In this message, it's always 0, because the group is relevant for the client.</param>
    /// <param name="questGroup">The quest group.</param>
    /// <remarks>
    /// Is sent by the server when: The server acknowledges the requested cancellation of a quest.
    /// Causes reaction on client side: The client resets the state of the quest and can request a new list of available quests again. This list would then probably contain the cancelled quest again.
    /// </remarks>
    public static async ValueTask SendQuestCancelledAsync(this IConnection? connection, ushort @questNumber, ushort @questGroup)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = QuestCancelledRef.Length;
            var packet = new QuestCancelledRef(connection.Output.GetSpan(length)[..length]);
            packet.QuestNumber = @questNumber;
            packet.QuestGroup = @questGroup;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="OpenNpcDialog" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="npcNumber">The npc number.</param>
    /// <param name="gensContributionPoints">The gens contribution points.</param>
    /// <remarks>
    /// Is sent by the server when: The server acknowledges the requested opening of an npc dialog.
    /// Causes reaction on client side: The client opens the dialog of the specified npc.
    /// </remarks>
    public static async ValueTask SendOpenNpcDialogAsync(this IConnection? connection, ushort @npcNumber, uint @gensContributionPoints)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = OpenNpcDialogRef.Length;
            var packet = new OpenNpcDialogRef(connection.Output.GetSpan(length)[..length]);
            packet.NpcNumber = @npcNumber;
            packet.GensContributionPoints = @gensContributionPoints;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="DevilSquareEnterResult" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <remarks>
    /// Is sent by the server when: The player requested to enter the devil square mini game through the Charon NPC.
    /// Causes reaction on client side: In case it failed, it shows the corresponding error message.
    /// </remarks>
    public static async ValueTask SendDevilSquareEnterResultAsync(this IConnection? connection, DevilSquareEnterResult.EnterResult @result)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = DevilSquareEnterResultRef.Length;
            var packet = new DevilSquareEnterResultRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MiniGameOpeningState" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="gameType">The game type.</param>
    /// <param name="remainingEnteringTimeMinutes">The remaining entering time minutes.</param>
    /// <param name="userCount">The user count.</param>
    /// <param name="remainingEnteringTimeMinutesLow">Just used for Chaos Castle. In this case, this field contains the lower byte of the remaining minutes. For other event types, this field is not used.</param>
    /// <remarks>
    /// Is sent by the server when: The player requests to get the current opening state of a mini game event, by clicking on an ticket item.
    /// Causes reaction on client side: The opening state of the event (remaining entering time, etc.) is shown at the client.
    /// </remarks>
    public static async ValueTask SendMiniGameOpeningStateAsync(this IConnection? connection, MiniGameType @gameType, byte @remainingEnteringTimeMinutes, byte @userCount, byte @remainingEnteringTimeMinutesLow)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MiniGameOpeningStateRef.Length;
            var packet = new MiniGameOpeningStateRef(connection.Output.GetSpan(length)[..length]);
            packet.GameType = @gameType;
            packet.RemainingEnteringTimeMinutes = @remainingEnteringTimeMinutes;
            packet.UserCount = @userCount;
            packet.RemainingEnteringTimeMinutesLow = @remainingEnteringTimeMinutesLow;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="UpdateMiniGameState" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="state">The state.</param>
    /// <remarks>
    /// Is sent by the server when: The state of a mini game event is about to change in 30 seconds.
    /// Causes reaction on client side: The client side shows a message about the changing state.
    /// </remarks>
    public static async ValueTask SendUpdateMiniGameStateAsync(this IConnection? connection, UpdateMiniGameState.MiniGameTypeState @state)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = UpdateMiniGameStateRef.Length;
            var packet = new UpdateMiniGameStateRef(connection.Output.GetSpan(length)[..length]);
            packet.State = @state;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="BloodCastleScore" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="success">The success.</param>
    /// <param name="playerName">The player name.</param>
    /// <param name="totalScore">The total score.</param>
    /// <param name="bonusExperience">The bonus experience.</param>
    /// <param name="bonusMoney">The bonus money.</param>
    /// <param name="type">The type.</param>
    /// <remarks>
    /// Is sent by the server when: The blood castle mini game ended and the score of the player is sent to the player.
    /// Causes reaction on client side: The score is shown at the client.
    /// </remarks>
    public static async ValueTask SendBloodCastleScoreAsync(this IConnection? connection, bool @success, string @playerName, uint @totalScore, uint @bonusExperience, uint @bonusMoney, byte @type = 0xFF)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = BloodCastleScoreRef.Length;
            var packet = new BloodCastleScoreRef(connection.Output.GetSpan(length)[..length]);
            packet.Success = @success;
            packet.Type = @type;
            packet.PlayerName = @playerName;
            packet.TotalScore = @totalScore;
            packet.BonusExperience = @bonusExperience;
            packet.BonusMoney = @bonusMoney;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="BloodCastleEnterResult" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <remarks>
    /// Is sent by the server when: The player requested to enter the blood castle mini game through the Archangel Messenger NPC.
    /// Causes reaction on client side: In case it failed, it shows the corresponding error message.
    /// </remarks>
    public static async ValueTask SendBloodCastleEnterResultAsync(this IConnection? connection, BloodCastleEnterResult.EnterResult @result)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = BloodCastleEnterResultRef.Length;
            var packet = new BloodCastleEnterResultRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="BloodCastleState" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="state">The state.</param>
    /// <param name="remainSecond">The remain second.</param>
    /// <param name="maxMonster">The max monster.</param>
    /// <param name="curMonster">The cur monster.</param>
    /// <param name="itemOwnerId">The item owner id.</param>
    /// <param name="itemLevel">The item level.</param>
    /// <remarks>
    /// Is sent by the server when: The state of a blood castle event is about to change.
    /// Causes reaction on client side: The client side shows a message about the changing state.
    /// </remarks>
    public static async ValueTask SendBloodCastleStateAsync(this IConnection? connection, BloodCastleState.Status @state, ushort @remainSecond, ushort @maxMonster, ushort @curMonster, ushort @itemOwnerId, byte @itemLevel)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = BloodCastleStateRef.Length;
            var packet = new BloodCastleStateRef(connection.Output.GetSpan(length)[..length]);
            packet.State = @state;
            packet.RemainSecond = @remainSecond;
            packet.MaxMonster = @maxMonster;
            packet.CurMonster = @curMonster;
            packet.ItemOwnerId = @itemOwnerId;
            packet.ItemLevel = @itemLevel;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="ChaosCastleEnterResult" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="result">The result.</param>
    /// <remarks>
    /// Is sent by the server when: The player requested to enter the chaos castle mini game by using the 'Armor of Guardsman' item.
    /// Causes reaction on client side: In case it failed, it shows the corresponding error message.
    /// </remarks>
    public static async ValueTask SendChaosCastleEnterResultAsync(this IConnection? connection, ChaosCastleEnterResult.EnterResult @result)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = ChaosCastleEnterResultRef.Length;
            var packet = new ChaosCastleEnterResultRef(connection.Output.GetSpan(length)[..length]);
            packet.Result = @result;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }

    /// <summary>
    /// Sends a <see cref="MapEventState" /> to this connection.
    /// </summary>
    /// <param name="connection">The connection.</param>
    /// <param name="enable">The enable.</param>
    /// <param name="event">The event.</param>
    /// <remarks>
    /// Is sent by the server when: The state of event is about to change.
    /// Causes reaction on client side: The event's effect is shown.
    /// </remarks>
    public static async ValueTask SendMapEventStateAsync(this IConnection? connection, bool @enable, MapEventState.Events @event)
    {
        if (connection is null)
        {
            return;
        }

        int WritePacket()
        {
            var length = MapEventStateRef.Length;
            var packet = new MapEventStateRef(connection.Output.GetSpan(length)[..length]);
            packet.Enable = @enable;
            packet.Event = @event;

            return packet.Header.Length;
        }

        await connection.SendAsync(WritePacket).ConfigureAwait(false);
    }}