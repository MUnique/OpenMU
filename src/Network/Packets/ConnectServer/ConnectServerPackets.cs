// <copyright file="ConnectServerPackets.cs" company="MUnique">
// Licensed under the MIT License. See LICENSE file in the project root for full license information.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by an XSL transformation.
//     Do not change this file. Instead, change the XML data which contains
//     the packet definitions and re-run the transformation (rebuild this project).
// </auto-generated>
//------------------------------------------------------------------------------

namespace MUnique.OpenMU.Network.Packets.ConnectServer
{
    using System;
    using static System.Buffers.Binary.BinaryPrimitives;

    /// <summary>
    /// Is sent by the client when: This packet is sent by the client after the user clicked on an entry of the server list.
    /// Causes reaction on server side: The server will send a ConnectionInfo back to the client.
    /// </summary>
    public readonly ref struct ConnectionInfoRequest
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectionInfoRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ConnectionInfoRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectionInfoRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ConnectionInfoRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF4;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x03;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the server id.
        /// </summary>
        public ushort ServerId
        {
            get => ReadUInt16LittleEndian(this.data.Slice(4));
            set => WriteUInt16LittleEndian(this.data.Slice(4), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ConnectionInfoRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ConnectionInfoRequest(Span<byte> packet) => new ConnectionInfoRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ConnectionInfoRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ConnectionInfoRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: This packet is sent by the server after the client requested the connection information of a server. This happens after the user clicked on a server.
    /// Causes reaction on client side: The client will try to connect to the server with the specified information.
    /// </summary>
    public readonly ref struct ConnectionInfo
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectionInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ConnectionInfo(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectionInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ConnectionInfo(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF4;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x03;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 22;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the ip address.
        /// </summary>
        public string IpAddress
        {
            get => this.data.ExtractString(4, 16, System.Text.Encoding.UTF8);
            set => this.data.Slice(4, 16).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Gets or sets the port.
        /// </summary>
        public ushort Port
        {
            get => ReadUInt16LittleEndian(this.data.Slice(20));
            set => WriteUInt16LittleEndian(this.data.Slice(20), value);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ConnectionInfo"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ConnectionInfo(Span<byte> packet) => new ConnectionInfo(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ConnectionInfo"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ConnectionInfo packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: This packet is sent by the client after it connected and received the 'Hello' message.
    /// Causes reaction on server side: The server will send a ServerListResponse back to the client.
    /// </summary>
    public readonly ref struct ServerListRequest
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerListRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ServerListRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerListRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ServerListRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF4;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x06;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerListRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ServerListRequest(Span<byte> packet) => new ServerListRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ServerListRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ServerListRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: This packet is sent by the server after the client requested the current server list.
    /// Causes reaction on client side: The client shows the available servers with their load information.
    /// </summary>
    public readonly ref struct ServerListResponse
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerListResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ServerListResponse(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerListResponse"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ServerListResponse(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF4;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x06;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2HeaderWithSubCode Header => new C2HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the server count.
        /// </summary>
        public ushort ServerCount
        {
            get => ReadUInt16BigEndian(this.data.Slice(5));
            set => WriteUInt16BigEndian(this.data.Slice(5), value);
        }

        /// <summary>
        /// Gets the <see cref="ServerLoadInfo"/> of the specified index.
        /// </summary>
        public ServerLoadInfo this[int index] => new ServerLoadInfo(this.data.Slice(7 + (index * ServerLoadInfo.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerListResponse"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ServerListResponse(Span<byte> packet) => new ServerListResponse(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ServerListResponse"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ServerListResponse packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="ServerLoadInfo"/>.
        /// </summary>
        /// <param name="serversCount">The count of <see cref="ServerLoadInfo"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int serversCount) => serversCount * ServerLoadInfo.Length + 7;


    /// <summary>
    /// Contains the id and the load of a server..
    /// </summary>
    public readonly ref struct ServerLoadInfo
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerLoadInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ServerLoadInfo(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets or sets the server id.
        /// </summary>
        public ushort ServerId
        {
            get => ReadUInt16LittleEndian(this.data.Slice(0));
            set => WriteUInt16LittleEndian(this.data.Slice(0), value);
        }

        /// <summary>
        /// Gets or sets the load percentage.
        /// </summary>
        public byte LoadPercentage
        {
            get => this.data[2];
            set => this.data[2] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the client when: This packet is sent by the client (below season 1) after it connected and received the 'Hello' message.
    /// Causes reaction on server side: The server will send a ServerListResponseOld back to the client.
    /// </summary>
    public readonly ref struct ServerListRequestOld
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerListRequestOld"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ServerListRequestOld(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerListRequestOld"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ServerListRequestOld(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF4;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x02;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerListRequestOld"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ServerListRequestOld(Span<byte> packet) => new ServerListRequestOld(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ServerListRequestOld"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ServerListRequestOld packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: This packet is sent by the server (below season 1) after the client requested the current server list.
    /// Causes reaction on client side: The client shows the available servers with their load information.
    /// </summary>
    public readonly ref struct ServerListResponseOld
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerListResponseOld"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ServerListResponseOld(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerListResponseOld"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ServerListResponseOld(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (ushort)data.Length;
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC2;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0xF4;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x02;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C2HeaderWithSubCode Header => new C2HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the server count.
        /// </summary>
        public byte ServerCount
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Gets the <see cref="ServerLoadInfo"/> of the specified index.
        /// </summary>
        public ServerLoadInfo this[int index] => new ServerLoadInfo(this.data.Slice(6 + (index * ServerLoadInfo.Length)));

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ServerListResponseOld"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ServerListResponseOld(Span<byte> packet) => new ServerListResponseOld(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ServerListResponseOld"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ServerListResponseOld packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified count of <see cref="ServerLoadInfo"/>.
        /// </summary>
        /// <param name="serversCount">The count of <see cref="ServerLoadInfo"/> from which the size will be calculated.</param>
        public static int GetRequiredSize(int serversCount) => serversCount * ServerLoadInfo.Length + 6;


    /// <summary>
    /// Contains the id and the load of a server..
    /// </summary>
    public readonly ref struct ServerLoadInfo
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ServerLoadInfo"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ServerLoadInfo(Span<byte> data)
        {
            this.data = data;
        }

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 2;

        /// <summary>
        /// Gets or sets the server id.
        /// </summary>
        public byte ServerId
        {
            get => this.data[0];
            set => this.data[0] = value;
        }

        /// <summary>
        /// Gets or sets the load percentage.
        /// </summary>
        public byte LoadPercentage
        {
            get => this.data[1];
            set => this.data[1] = value;
        }
    }
    }


    /// <summary>
    /// Is sent by the server when: This packet is sent by the server after the client connected to the server.
    /// Causes reaction on client side: A game client will request the server list. The launcher would request the patch state.
    /// </summary>
    public readonly ref struct Hello
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="Hello"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public Hello(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Hello"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private Hello(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x00;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x01;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="Hello"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator Hello(Span<byte> packet) => new Hello(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="Hello"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(Hello packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the client when: This packet is sent by the client (launcher) to check if the patch version is high enough to be able to connect to the server.
    /// Causes reaction on server side: The connect server will check the version and sends a 'PatchVersionOkay' or a 'ClientNeedsPatch' message.
    /// </summary>
    public readonly ref struct PatchCheckRequest
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PatchCheckRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PatchCheckRequest(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PatchCheckRequest"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PatchCheckRequest(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x02;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 6;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Gets or sets the major version.
        /// </summary>
        public byte MajorVersion
        {
            get => this.data[3];
            set => this.data[3] = value;
        }

        /// <summary>
        /// Gets or sets the minor version.
        /// </summary>
        public byte MinorVersion
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the patch version.
        /// </summary>
        public byte PatchVersion
        {
            get => this.data[5];
            set => this.data[5] = value;
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PatchCheckRequest"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PatchCheckRequest(Span<byte> packet) => new PatchCheckRequest(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PatchCheckRequest"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PatchCheckRequest packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: This packet is sent by the server after the client (launcher) requested the to check the patch version and it was high enough.
    /// Causes reaction on client side: The launcher will activate its start button.
    /// </summary>
    public readonly ref struct PatchVersionOkay
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="PatchVersionOkay"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public PatchVersionOkay(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PatchVersionOkay"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private PatchVersionOkay(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x02;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 4;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1Header Header => new C1Header(this.data);

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="PatchVersionOkay"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator PatchVersionOkay(Span<byte> packet) => new PatchVersionOkay(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="PatchVersionOkay"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(PatchVersionOkay packet) => packet.data; 
    }


    /// <summary>
    /// Is sent by the server when: This packet is sent by the server after the client (launcher) requested to check the patch version and it requires an update.
    /// Causes reaction on client side: The launcher will download the required patches and then activate the start button.
    /// </summary>
    public readonly ref struct ClientNeedsPatch
    {
        private readonly Span<byte> data;

        /// <summary>
        /// Initializes a new instance of the <see cref="ClientNeedsPatch"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        public ClientNeedsPatch(Span<byte> data)
            : this(data, true)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ClientNeedsPatch"/> struct.
        /// </summary>
        /// <param name="data">The underlying data.</param>
        /// <param name="initialize">If set to <c>true</c>, the header data is automatically initialized and written to the underlying span.</param>
        private ClientNeedsPatch(Span<byte> data, bool initialize)
        {
            this.data = data;
            if (initialize)
            {
                var header = this.Header;
                header.Type = HeaderType;
                header.Code = Code;
                header.Length = (byte)Math.Min(data.Length, Length);
                header.SubCode = SubCode;
            }
        }

        /// <summary>
        /// Gets the header type of this data packet.
        /// </summary>
        public static byte HeaderType => 0xC1;

        /// <summary>
        /// Gets the operation code of this data packet.
        /// </summary>
        public static byte Code => 0x05;

        /// <summary>
        /// Gets the operation sub-code of this data packet.
        /// The <see cref="Code" /> is used as a grouping key.
        /// </summary>
        public static byte SubCode => 0x1;

        /// <summary>
        /// Gets the initial length of this data packet. When the size is dynamic, this value may be bigger than actually needed.
        /// </summary>
        public static int Length => 138;

        /// <summary>
        /// Gets the header of this packet.
        /// </summary>
        public C1HeaderWithSubCode Header => new C1HeaderWithSubCode(this.data);

        /// <summary>
        /// Gets or sets the patch version.
        /// </summary>
        public byte PatchVersion
        {
            get => this.data[4];
            set => this.data[4] = value;
        }

        /// <summary>
        /// Gets or sets the patch address, usually to a ftp server. The address is usually "encrypted" with the 3-byte XOR key (FC CF AB).
        /// </summary>
        public string PatchAddress
        {
            get => this.data.ExtractString(6, this.data.Length - 6, System.Text.Encoding.UTF8);
            set => this.data.Slice(6).WriteString(value, System.Text.Encoding.UTF8);
        }

        /// <summary>
        /// Performs an implicit conversion from a Span of bytes to a <see cref="ClientNeedsPatch"/>.
        /// </summary>
        /// <param name="packet">The packet as span.</param>
        /// <returns>The packet as struct.</returns>
        public static implicit operator ClientNeedsPatch(Span<byte> packet) => new ClientNeedsPatch(packet, false);

        /// <summary>
        /// Performs an implicit conversion from <see cref="ClientNeedsPatch"/> to a Span of bytes.
        /// </summary>
        /// <param name="packet">The packet as struct.</param>
        /// <returns>The packet as byte span.</returns>
        public static implicit operator Span<byte>(ClientNeedsPatch packet) => packet.data; 

        /// <summary>
        /// Calculates the size of the packet for the specified field content.
        /// </summary>
        /// <param name="content">The content of the variable 'PatchAddress' field from which the size will be calculated.</param>
        public static int GetRequiredSize(string content) => System.Text.Encoding.UTF8.GetByteCount(content) + 1 + 6;
    }
}